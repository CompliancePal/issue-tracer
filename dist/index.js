require('./sourcemap-register.js');module.exports =
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 3321:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issuesHandler = void 0;
const core = __importStar(__webpack_require__(2186));
const github = __importStar(__webpack_require__(5438));
const Issue_1 = __webpack_require__(2422);
const Issues_1 = __webpack_require__(2724);
const issuesHandler = (ghToken) => __awaiter(void 0, void 0, void 0, function* () {
    let issue, repo, relatedIssue;
    switch (github.context.payload.action) {
        case 'edited':
        case 'opened':
        case 'closed':
        case 'reopened':
            issue = Issue_1.Issue.fromEventPayload(github.context.payload);
            core.info(`Issue ${issue.number} parsed successfuly`);
            if (issue.partOf === undefined) {
                core.info('Issue is not partOf other issues');
                return;
            }
            repo = new Issues_1.IssuesRepo(ghToken);
            relatedIssue = yield repo.get(issue.partOf);
            if (relatedIssue === undefined) {
                core.setFailed(`Action could not find the related issue `);
                return;
            }
            core.info(`Related issue ${relatedIssue.number} found sucessfuly`);
            core.info(`Related issue ${relatedIssue.number} has ${relatedIssue.subtasks.size} subtasks`);
            relatedIssue.addSubtask({
                id: issue.number.toString(),
                title: issue.title,
                closed: issue.closed,
                removed: false,
                owner: issue.owner,
                repo: issue.repo
            });
            yield relatedIssue.save(repo);
            // await repo.save(relatedIssue)
            core.info(`Related issue ${relatedIssue.number} updated sucessfuly`);
            core.setOutput('partOf', issue.partOf);
            break;
        default:
    }
});
exports.issuesHandler = issuesHandler;


/***/ }),

/***/ 6895:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pullRequestHandler = void 0;
const core = __importStar(__webpack_require__(2186));
const github = __importStar(__webpack_require__(5438));
const PullRequest_1 = __webpack_require__(3340);
const Issues_1 = __webpack_require__(2724);
const pullRequestHandler = (ghToken) => __awaiter(void 0, void 0, void 0, function* () {
    let issue, repo, pullRequest;
    switch (github.context.payload.action) {
        case 'opened':
        case 'edited':
        case 'synchronize':
            pullRequest = yield PullRequest_1.PullRequest.fromEventPayload(github.context.payload);
            if (pullRequest.resolvesRequirement === undefined) {
                core.setFailed(`Action could not identify the resolved issue`);
                return;
            }
            core.info(`Pull request contains ${pullRequest.testCases.length} test cases`);
            repo = new Issues_1.IssuesRepo(ghToken);
            issue = yield repo.get({
                owner: pullRequest.owner,
                repo: pullRequest.repo,
                issue_number: pullRequest.resolvesRequirement
            });
            if (issue === undefined) {
                core.setFailed(`Action could not retrieve the issue resolved by the pull request ${pullRequest.resolvesRequirement}`);
                return;
            }
            // github.getOctokit(ghToken).graphql({
            //   query: `query timeline($name: String!, $owner: String!, $number: Int!) {
            //     repository(name: $name, owner: $owner) {
            //       issue(number: $number) {
            //         id
            //         number
            //         timelineItems(first: 10) {
            //           nodes {
            //             ... on CrossReferencedEvent {
            //               id
            //               source {
            //                 ... on PullRequest {
            //                   id
            //                   number
            //                 }
            //               }
            //               willCloseTarget
            //             }
            //           }
            //         }
            //       }
            //     }
            //   }`,
            //   name: 'repo_name',
            //   owner: 'owner'
            // })
            issue.setResolvedBy(pullRequest);
            issue.save(repo);
            core.info(`Resolved issue ${issue.number} updated sucessfuly`);
            break;
        default:
    }
    // core.info(JSON.stringify(github.context.payload))
});
exports.pullRequestHandler = pullRequestHandler;


/***/ }),

/***/ 6217:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Entity = void 0;
class Entity {
    constructor(props) {
        this.props = props;
    }
}
exports.Entity = Entity;


/***/ }),

/***/ 2422:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Issue = void 0;
const Entity_1 = __webpack_require__(6217);
const BodyIssueRels_1 = __webpack_require__(5710);
class Issue extends Entity_1.Entity {
    constructor(issue, owner, repo) {
        super(issue);
        this.props = issue;
        this.owner = owner;
        this.repo = repo;
        // this.partOf = this.detectsPartOf()
        this.subtasks = new Map();
        const rels = new BodyIssueRels_1.BodyIssueRels();
        this.relsBackend = rels;
        this.detectsRelationships();
    }
    static fromEventPayload({ issue, repository: { name: repo, owner: { login: owner } } }) {
        const result = new Issue(issue, owner, repo);
        return result;
    }
    static fromApiPayload(payload, owner, repo) {
        const result = new Issue(payload, owner, repo);
        return result;
    }
    get body() {
        return this.props.body;
    }
    set body(content) {
        this.props.body = content;
    }
    get labels() {
        return Array.from(this.props.labels || []).map(label => label.name);
    }
    get id() {
        return this.props.id;
    }
    get number() {
        return this.props.number;
    }
    get closed() {
        return this.props.state === 'closed';
    }
    get title() {
        return this.props.title;
    }
    hasParent() {
        return this.partOf !== undefined;
    }
    equals(issue) {
        return (this.number === issue.number &&
            this.owner === issue.owner &&
            this.repo === issue.repo);
    }
    save(repo) {
        return __awaiter(this, void 0, void 0, function* () {
            return repo.save(this);
        });
    }
    /**
     * Is cross reference when the owner or the repo name are different
     */
    isCrossReference(issue) {
        return this.owner !== issue.owner || this.repo !== issue.repo;
    }
    addSubtask(subtask) {
        const id = this.isCrossReference(subtask)
            ? `${subtask.owner}/${subtask.repo}#${subtask.id}`
            : subtask.id.startsWith('#')
                ? subtask.id
                : `#${subtask.id}`;
        this.subtasks.set(id, subtask);
        this.updateRelationships();
    }
    setResolvedBy(pullRequest) {
        this.resolvedBy = pullRequest;
        this.updateRelationships();
        return this;
    }
    updateRelationships() {
        this.relsBackend.save(this);
    }
    detectsRelationships() {
        this.relsBackend.load(this);
    }
}
exports.Issue = Issue;


/***/ }),

/***/ 3340:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PullRequest = void 0;
const path_1 = __webpack_require__(5622);
const core = __importStar(__webpack_require__(2186));
const glob = __importStar(__webpack_require__(8090));
const jest_cucumber_1 = __webpack_require__(5550);
const unified_1 = __importDefault(__webpack_require__(5075));
const remark_parse_1 = __importDefault(__webpack_require__(4859));
const remark_gfm_1 = __importDefault(__webpack_require__(5772));
const unist_util_visit_1 = __importDefault(__webpack_require__(199));
const Entity_1 = __webpack_require__(6217);
const findFeatures = (issue_number) => __awaiter(void 0, void 0, void 0, function* () {
    var e_1, _a;
    core.info(`Running in ${process.cwd()}`);
    const result = [];
    const globber = yield glob.create([`**/*.feature`, `!.git`, `!.private-action`].join('\n'));
    for (const path of globber.getSearchPaths()) {
        core.debug(`Looking for feature files in ${path}`);
    }
    try {
        for (var _b = __asyncValues(globber.globGenerator()), _c; _c = yield _b.next(), !_c.done;) {
            const file = _c.value;
            core.info(`Processing feature file: ${file}`);
            const feature = jest_cucumber_1.loadFeature(file);
            for (const scenario of feature.scenarios) {
                if (scenario.tags.includes(`@issue-${issue_number}`)) {
                    result.push({
                        filename: path_1.relative(process.cwd(), file),
                        feature: feature.title,
                        title: scenario.title,
                        steps: scenario.steps,
                        lineNumber: scenario.lineNumber
                    });
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
});
class PullRequest extends Entity_1.Entity {
    constructor(pr, owner, repo) {
        super(pr);
        this.owner = owner;
        this.repo = repo;
        this.resolvesRequirement = this.detectRequirement();
        this.testCases = [];
    }
    static fromEventPayload(event) {
        return __awaiter(this, void 0, void 0, function* () {
            //TODO: move the feature globbing into a repository
            const pullRequest = new PullRequest(event.pull_request, event.repository.owner.login, event.repository.name);
            if (pullRequest.resolvesRequirement) {
                pullRequest.testCases = yield findFeatures(pullRequest.resolvesRequirement);
            }
            return pullRequest;
        });
    }
    get number() {
        return this.props.number;
    }
    // get testCases(): Promise<TestCase[]> {
    //   return (async () => {
    //     try {
    //       return await this.findFeatures()
    //     } catch (error) {
    //       return []
    //     }
    //   })()
    // }
    detectRequirement() {
        let issue_number;
        const tree = unified_1.default()
            .use(remark_parse_1.default)
            .use(remark_gfm_1.default)
            .parse(this.props.body);
        const paragraph = tree.children[0];
        if (paragraph !== undefined && paragraph.type === 'paragraph') {
            unist_util_visit_1.default(paragraph, 'text', (node) => {
                const m = node.value.match(/Resolves #(?<issue>[0-9]*)/);
                if (m && m.groups) {
                    issue_number = parseInt(m.groups.issue);
                }
            });
        }
        return issue_number;
    }
}
exports.PullRequest = PullRequest;


/***/ }),

/***/ 3109:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const core = __importStar(__webpack_require__(2186));
const github = __importStar(__webpack_require__(5438));
const issues_1 = __webpack_require__(3321);
const pull_request_1 = __webpack_require__(6895);
const ghToken = process.env.GITHUB_TOKEN;
function run() {
    return __awaiter(this, void 0, void 0, function* () {
        if (ghToken === undefined) {
            core.setFailed(`GITHUB_TOKEN not provided`);
            return;
        }
        try {
            switch (github.context.eventName) {
                case 'issues':
                    yield issues_1.issuesHandler(ghToken);
                    break;
                case 'pull_request':
                    yield pull_request_1.pullRequestHandler(ghToken);
                    break;
                default:
            }
        }
        catch (error) {
            core.setFailed(error.message);
        }
    });
}
run();


/***/ }),

/***/ 4079:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.styleMarkdownOutput = void 0;
/**
 * Further customisation options on plugin homepage
 * https://github.com/syntax-tree/mdast-util-to-markdown
 */
function styleMarkdownOutput(options) {
    //@ts-ignore
    const data = this.data();
    data.toMarkdownExtensions.push({
        bullet: '-',
        listItemIndent: 'one',
        rule: '-',
        join: [
            //@ts-ignore
            (first, second) => {
                // do not add space between the heading and the comment
                if (first.type === 'heading' &&
                    second.type === 'html' &&
                    second.value === options.comment) {
                    return 0;
                }
                // do not add space in frontmatter
                if (first.type === 'thematicBreak' && second.type === 'paragraph') {
                    return 0;
                }
                return true;
            }
        ]
    });
}
exports.styleMarkdownOutput = styleMarkdownOutput;


/***/ }),

/***/ 5710:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BodyIssueRels = void 0;
// import * as core from '@actions/core'
const unified_1 = __importDefault(__webpack_require__(5075));
const remark_parse_1 = __importDefault(__webpack_require__(4859));
const remark_frontmatter_1 = __importDefault(__webpack_require__(762));
const remark_gfm_1 = __importDefault(__webpack_require__(5772));
const remark_stringify_1 = __importDefault(__webpack_require__(7114));
const unist_util_visit_1 = __importDefault(__webpack_require__(199));
const yaml_1 = __importDefault(__webpack_require__(3552));
const Section_1 = __webpack_require__(7980);
const SectionExporter_1 = __webpack_require__(1120);
const unified_2 = __webpack_require__(4079);
class BodyIssueRels {
    static parsePartOf(raw, owner, repo) {
        const re = /^(([-\w]+)\/([-\w]+))?#([0-9]+)$/;
        const res = raw.match(re);
        return res
            ? {
                owner: res[2] ? res[2] : owner,
                repo: res[3] ? res[3] : repo,
                issue_number: parseInt(res[4])
            }
            : undefined;
    }
    get processor() {
        return (unified_1.default()
            .use(remark_parse_1.default)
            .use(remark_gfm_1.default)
            .use(remark_frontmatter_1.default, [
            {
                type: 'yaml',
                marker: {
                    open: '-',
                    close: '-'
                },
                anywhere: true
            }
        ])
            .use(unified_2.styleMarkdownOutput, {
            comment: SectionExporter_1.SectionExporter.COMMENT
        })
            //TODO: investigate why we need the previous plugin
            .use(remark_stringify_1.default
        // , {
        // extensions: [
        //   {
        //     bullet: '-',
        //     listItemIndent: 'one',
        //     rule: '-',
        //     join: [
        //       (first: Node, second: Node) => {
        //         // do not add space between the heading and the comment
        //         if (
        //           first.type === 'heading' &&
        //           second.type === 'html' &&
        //           second.value === SectionExporter.COMMENT
        //         ) {
        //           core.debug('handled comment')
        //           // join signature does not allow to return number
        //           return (0 as unknown) as boolean
        //         }
        //         // do not add space in frontmatter
        //         if (
        //           first.type === 'thematicBreak' &&
        //           second.type === 'paragraph'
        //         ) {
        //           // join signature does not allow to return number
        //           return (0 as unknown) as boolean
        //         }
        //         return true
        //       }
        //     ]
        //   }
        // ]
        // }
        ));
    }
    load(issue) {
        const tree = this.processor.parse(issue.body);
        this.findsPartOf(issue, tree);
        this.findsSubtasks(issue, tree);
    }
    save(issue) {
        const stringifier = this.processor.use(() => {
            return tree => {
                const section = new Section_1.Section('traceability');
                const exporter = new SectionExporter_1.SectionExporter(2);
                const sectionHeading = exporter.heading();
                const resolvedBySection = exporter.resolvedBy(issue.resolvedBy);
                const testCasesSection = issue.resolvedBy && exporter.testCases(issue.resolvedBy);
                const subtasksSection = `### Related issues\n\n${Array.from(issue.subtasks.values())
                    .map(_subtask => `* [${_subtask.closed ? 'x' : ' '}] ${_subtask.title} (${subtaskToString(_subtask, issue.isCrossReference(_subtask))})`)
                    .join('\n')}\n`;
                const processor = this.processor;
                unist_util_visit_1.default(tree, 'heading', (node, position) => {
                    if (section.isStartMarker(node)) {
                        section.enter(position, node.depth);
                    }
                    else {
                        // inside section
                        if (section.isInside()) {
                            // end
                            if (section.isEndMarker(node.depth)) {
                                section.leave(position);
                            }
                        }
                    }
                });
                if (section.isInside()) {
                    section.leave(tree.children.length);
                }
                if (!section.found)
                    return tree;
                const before = tree.children.filter((node, index) => index < (section.start || 0));
                const after = tree.children.filter((node, index) => index >= (section.end || tree.children.length));
                const sectionTree = processor.parse([sectionHeading, resolvedBySection, testCasesSection, subtasksSection]
                    .filter(part => part !== null)
                    .join('\n'));
                const result = processor.parse('');
                result.children = before.concat(sectionTree.children).concat(after);
                return result;
            };
        });
        const sectionBody = stringifier.processSync(issue.body);
        issue.body = sectionBody.contents.trim();
    }
    findsPartOf(issue, tree) {
        unist_util_visit_1.default(tree, 'yaml', node => {
            // core.debug(JSON.stringify(node))
            const patched = node.value.replace(/partOf: (#[0-9]*)/, 'partOf: "$1"');
            const data = yaml_1.default.parse(patched);
            if (data && data.partOf) {
                issue.partOf = BodyIssueRels.parsePartOf(data.partOf, issue.owner, issue.repo);
            }
        });
    }
    findsSubtasks(issue, tree) {
        const section = new Section_1.Section('traceability');
        unist_util_visit_1.default(tree, ['heading', 'list'], (node, position) => {
            switch (node.type) {
                case 'heading':
                    // no information
                    if (section.isStartMarker(node)) {
                        section.enter(position, node.depth);
                    }
                    else {
                        // inside section
                        if (section.isInside()) {
                            // end
                            if (section.isEndMarker(node.depth)) {
                                section.leave(position);
                            }
                        }
                    }
                    break;
                case 'list':
                    if (section.isInside()) {
                        unist_util_visit_1.default(node, 'listItem', item => {
                            unist_util_visit_1.default(item, 'paragraph', p => {
                                unist_util_visit_1.default(p, 'text', text => {
                                    const raw = text.value
                                        .split('(')[1]
                                        .replace(')', '');
                                    const title = text.value.split(' (')[0];
                                    const parsed = BodyIssueRels.parsePartOf(raw, issue.owner, issue.repo);
                                    if (parsed) {
                                        const { issue_number, owner, repo } = parsed;
                                        issue.subtasks.set(raw, {
                                            id: issue_number.toString(),
                                            title,
                                            removed: false,
                                            closed: !!item.checked,
                                            owner,
                                            repo
                                        });
                                    }
                                });
                            });
                        });
                    }
            }
        });
    }
}
exports.BodyIssueRels = BodyIssueRels;
const subtaskToString = (subtask, isCrossReference) => {
    const reference = isCrossReference ? `${subtask.owner}/${subtask.repo}` : '';
    return `${reference}#${subtask.id}`;
};


/***/ }),

/***/ 2724:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IssuesRepo = void 0;
const github = __importStar(__webpack_require__(5438));
const Issue_1 = __webpack_require__(2422);
class IssuesRepo {
    constructor(token) {
        this.token = token;
    }
    get({ owner, repo, issue_number }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const gh = github.getOctokit(this.token);
                const response = yield gh.issues.get({
                    owner,
                    repo,
                    issue_number
                });
                return Issue_1.Issue.fromApiPayload(response.data, owner, repo);
            }
            catch (error) {
                return;
            }
        });
    }
    save(issue) {
        return __awaiter(this, void 0, void 0, function* () {
            const gh = github.getOctokit(this.token);
            yield gh.issues.update({
                owner: issue.owner,
                repo: issue.repo,
                issue_number: issue.number,
                body: issue.body
            });
        });
    }
}
exports.IssuesRepo = IssuesRepo;


/***/ }),

/***/ 7980:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Section = void 0;
const structured_field_values_1 = __webpack_require__(2363);
class Section {
    constructor(flag) {
        this.props = {
            flag
        };
    }
    get start() {
        return this.props.start;
    }
    get end() {
        return this.props.end;
    }
    get found() {
        return this.props.start !== undefined && this.props.end !== undefined;
    }
    get depth() {
        return this.props.depth;
    }
    enter(start, depth) {
        this.props.start = start;
        this.props.depth = depth;
    }
    leave(end) {
        this.props.end = end;
    }
    isEndMarker(depth) {
        if (this.props.depth === undefined)
            return false;
        return depth <= this.props.depth;
    }
    isInside() {
        return this.props.start !== undefined && this.props.end === undefined;
    }
    isStartMarker(node) {
        if (node.type === 'heading') {
            if (node.children.length === 2) {
                if (node.children[1].type === 'html') {
                    const value = node.children[1].value;
                    const m = value.match(/^<!-- (?<meta>.*) -->$/);
                    if (m !== null && m.groups) {
                        const { [this.props.flag]: { value: traceability } = {
                            value: false
                        } } = structured_field_values_1.decodeDict(m.groups.meta);
                        if (traceability) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
}
exports.Section = Section;


/***/ }),

/***/ 1120:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SectionExporter = void 0;
class SectionExporter {
    constructor(depth) {
        this.depth = depth;
    }
    headingString(increment) {
        return '#'.repeat(this.depth + increment);
    }
    heading() {
        return `${this.headingString(0)} Traceability <!-- traceability -->\n${SectionExporter.COMMENT}\n`;
    }
    resolvedBy(pullRequest) {
        return pullRequest
            ? `${this.headingString(1)} Resolved by\n\nChange request #${pullRequest.number} will close this issue.`
            : null;
    }
    testCases({ testCases }) {
        const details = testCases
            .map((testCase) => {
            return this.testCaseDetails(testCase);
        })
            .join('\n');
        return testCases.length > 0
            ? `${this.headingString(1)} Test cases\n\n${details}\n`
            : null;
    }
    testCaseDetails(testCase) {
        return `<details>
<summary>:cucumber: ${testCase.feature} - ${testCase.title}</summary>
\n
\`\`\`gherkin
Feature: ${testCase.feature}
\n
  Scenario: ${testCase.title}
${testCase.steps
            .map(step => {
            // process.stdout.write(JSON.stringify(step))
            return `${this.leftPad(this.capitalize(step.keyword), 11)} ${step.stepText}`;
        })
            .join('\n')}
\`\`\`
\n
</details>
`;
    }
    leftPad(text, length) {
        return text.padStart(length);
    }
    capitalize(input) {
        return input[0].toUpperCase() + input.substring(1);
    }
}
exports.SectionExporter = SectionExporter;
SectionExporter.COMMENT = '<!-- Section created by CompliancePal. Do not edit -->';


/***/ }),

/***/ 2363:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.base64encode = exports.base64decode = exports.parseBoolean = exports.parseByteSequence = exports.parseToken = exports.parseString = exports.parseIntegerOrDecimal = exports.parseKey = exports.parseParameters = exports.parseBareItem = exports.parseItem = exports.parseDictionary = exports.parseInnerList = exports.parseItemOrInnerList = exports.parseList = exports.serializeByteSequence = exports.serializeBoolean = exports.serializeToken = exports.serializeString = exports.serializeDecimal = exports.serializeInteger = exports.serializeBareItem = exports.serializeItem = exports.serializeDict = exports.serializeKey = exports.serializeParams = exports.serializeInnerList = exports.serializeList = exports.decodeDict = exports.decodeList = exports.decodeItem = exports.encodeDict = exports.encodeList = exports.encodeItem = exports.Item = void 0;
//@ts-nocheck
class Item {
    /**
     * @property {BareItem} value
     * @property {Parameters} params
     */
    constructor(value, params = null) {
        if (Array.isArray(value)) {
            value = value.map(v => {
                if (v instanceof Item)
                    return v;
                return new Item(v);
            });
        }
        this.value = value;
        this.params = params;
    }
}
exports.Item = Item;
/////////////////////////
// public interface
/////////////////////////
// 4.1.  Serializing Structured Fields
//
// 1.  If the structure is a Dictionary or List and its value is empty
//     (i.e., it has no members), do not serialize the field at all
//     (i.e., omit both the field-name and field-value).
//
// 2.  If the structure is a List, let output_string be the result of
//     running Serializing a List (Section 4.1.1) with the structure.
//
// 3.  Else if the structure is a Dictionary, let output_string be the
//     result of running Serializing a Dictionary (Section 4.1.2) with
//     the structure.
//
// 4.  Else if the structure is an Item, let output_string be the result
//     of running Serializing an Item (Section 4.1.3) with the
//     structure.
//
// 5.  Else, fail serialization.
//
// 6.  Return output_string converted into an array of bytes, using
//     ASCII encoding [RFC0020].
/**
 * @param {Item} value
 * @returns {string}
 */
function encodeItem(value) {
    return serializeItem(value);
}
exports.encodeItem = encodeItem;
/**
 * @param {MemberList} value
 * @returns {string}
 */
function encodeList(value) {
    return serializeList(value);
}
exports.encodeList = encodeList;
/**
 * @param {Dictionary} value
 * @returns {string}
 */
function encodeDict(value) {
    return serializeDict(value);
}
exports.encodeDict = encodeDict;
// 4.2.  Parsing Structured Fields
//
// 1.  Convert input_bytes into an ASCII string input_string; if
//     conversion fails, fail parsing.
//
// 2.  Discard any leading SP characters from input_string.
//
// 3.  If field_type is "list", let output be the result of running
//     Parsing a List (Section 4.2.1) with input_string.
//
// 4.  If field_type is "dictionary", let output be the result of
//     running Parsing a Dictionary (Section 4.2.2) with input_string.
//
// 5.  If field_type is "item", let output be the result of running
//     Parsing an Item (Section 4.2.3) with input_string.
//
// 6.  Discard any leading SP characters from input_string.
//
// 7.  If input_string is not empty, fail parsing.
//
// 8.  Otherwise, return output.
/**
 * @param {string} input
 * @returns {Item}
 */
function decodeItem(input) {
    const { input_string, value } = parseItem(input.trim());
    if (input_string !== '')
        throw new Error(`failed to parse ${input_string} as Item`);
    return value;
}
exports.decodeItem = decodeItem;
/**
 * @param {string} input
 * @returns {MemberList}
 */
function decodeList(input) {
    const { input_string, value } = parseList(input.trim());
    if (input_string !== '')
        throw new Error(`failed to parse ${input_string} as List`);
    return value;
}
exports.decodeList = decodeList;
/**
 * @param {string} input
 * @returns {Dictionary}
 */
function decodeDict(input) {
    const { input_string, value } = parseDictionary(input.trim());
    if (input_string !== '')
        throw new Error(`failed to parse ${input_string} as Dict`);
    return value;
}
exports.decodeDict = decodeDict;
// 4.1.1.  Serializing a List
//
// Given an array of (member_value, parameters) tuples as input_list,
// return an ASCII string suitable for use in a HTTP field value.
//
// 1.  Let output be an empty string.
//
// 2.  For each (member_value, parameters) of input_list:
//
//     1.  If member_value is an array, append the result of running
//         Serializing an Inner List (Section 4.1.1.1) with
//         (member_value, parameters) to output.
//
//     2.  Otherwise, append the result of running Serializing an Item
//         (Section 4.1.3) with (member_value, parameters) to output.
//
//     3.  If more member_values remain in input_list:
//
//         1.  Append "," to output.
//
//         2.  Append a single SP to output.
//
// 3.  Return output.
/**
 * @param {MemberList} list
 * @return {string}
 */
function serializeList(list) {
    if (Array.isArray(list) === false)
        throw new Error(`failed to serialize ${list} as List`);
    return list
        .map(item => {
        if (item instanceof Item === false)
            item = new Item(item);
        if (Array.isArray(item.value)) {
            return serializeInnerList(item);
        }
        return serializeItem(item);
    })
        .join(', ');
}
exports.serializeList = serializeList;
// 4.1.1.1.  Serializing an Inner List
//
// Given an array of (member_value, parameters) tuples as inner_list,
// and parameters as list_parameters, return an ASCII string suitable
// for use in a HTTP field value.
//
// 1.  Let output be the string "(".
//
// 2.  For each (member_value, parameters) of inner_list:
//
//     1.  Append the result of running Serializing an Item
//         (Section 4.1.3) with (member_value, parameters) to output.
//
//     2.  If more values remain in inner_list, append a single SP to
//         output.
//
// 3.  Append ")" to output.
//
// 4.  Append the result of running Serializing Parameters
//     (Section 4.1.1.2) with list_parameters to output.
//
// 5.  Return output.
/**
 * @param {Object} value
 * @return {string}
 */
function serializeInnerList(value) {
    return `(${value.value.map(serializeItem).join(' ')})${serializeParams(value.params)}`;
}
exports.serializeInnerList = serializeInnerList;
// 4.1.1.2.  Serializing Parameters
//
// Given an ordered Dictionary as input_parameters (each member having a
// param_name and a param_value), return an ASCII string suitable for
// use in a HTTP field value.
//
// 1.  Let output be an empty string.
//
// 2.  For each param_name with a value of param_value in
//     input_parameters:
//
//     1.  Append ";" to output.
//
//     2.  Append the result of running Serializing a Key
//         (Section 4.1.1.3) with param_name to output.
//
//     3.  If param_value is not Boolean true:
//
//         1.  Append "=" to output.
//
//         2.  Append the result of running Serializing a bare Item
//             (Section 4.1.3.1) with param_value to output.
//
// 3.  Return output.
/**
 * @param {Object} params
 * @return {string}
 */
function serializeParams(params) {
    if (params === null)
        return '';
    return Object.entries(params)
        .map(([key, value]) => {
        if (value === true)
            return `;${serializeKey(key)}`; // omit true
        return `;${serializeKey(key)}=${serializeBareItem(value)}`;
    })
        .join('');
}
exports.serializeParams = serializeParams;
// 4.1.1.3.  Serializing a Key
//
// Given a key as input_key, return an ASCII string suitable for use in
// a HTTP field value.
//
// 1.  Convert input_key into a sequence of ASCII characters; if
//     conversion fails, fail serialization.
//
// 2.  If input_key contains characters not in lcalpha, DIGIT, "_", "-",
//     ".", or "*" fail serialization.
//
// 3.  If the first character of input_key is not lcalpha or "*", fail
//     serialization.
//
// 4.  Let output be an empty string.
//
// 5.  Append input_key to output.
//
// 6.  Return output.
/**
 * @param {string} value
 * @return {string}
 */
function serializeKey(value) {
    if (/^[a-z\*][a-z0-9\-\_\.\*]*$/.test(value) === false) {
        throw new Error(`failed to serialize ${value} as Key`);
    }
    return value;
}
exports.serializeKey = serializeKey;
// 4.1.2.  Serializing a Dictionary
//
// Given an ordered Dictionary as input_dictionary (each member having a
// member_name and a tuple value of (member_value, parameters)), return
// an ASCII string suitable for use in a HTTP field value.
//
// 1.  Let output be an empty string.
//
// 2.  For each member_name with a value of (member_value, parameters)
//     in input_dictionary:
//
//     1.  Append the result of running Serializing a Key
//         (Section 4.1.1.3) with member's member_name to output.
//
//     2.  If member_value is Boolean true:
//
//         1.  Append the result of running Serializing Parameters
//             (Section 4.1.1.2) with parameters to output.
//
//     3.  Otherwise:
//
//         1.  Append "=" to output.
//
//         2.  If member_value is an array, append the result of running
//             Serializing an Inner List (Section 4.1.1.1) with
//             (member_value, parameters) to output.
//
//         3.  Otherwise, append the result of running Serializing an
//             Item (Section 4.1.3) with (member_value, parameters) to
//             output.
//
//     4.  If more members remain in input_dictionary:
//
//         1.  Append "," to output.
//
//         2.  Append a single SP to output.
//
// 3.  Return output.
/**
 * @param {Dictionary} dict
 * @return {string}
 */
function serializeDict(dict) {
    if (typeof dict !== 'object')
        throw new Error(`failed to serialize ${dict} as Dict`);
    const entries = dict instanceof Map ? dict.entries() : Object.entries(dict);
    return Array.from(entries)
        .map(([key, item]) => {
        if (item instanceof Item === false)
            item = new Item(item);
        let output = serializeKey(key);
        if (item.value === true) {
            output += serializeParams(item.params);
        }
        else {
            output += '=';
            if (Array.isArray(item.value)) {
                output += serializeInnerList(item);
            }
            else {
                output += serializeItem(item);
            }
        }
        return output;
    })
        .join(', ');
}
exports.serializeDict = serializeDict;
// 4.1.3.  Serializing an Item
//
// Given an Item as bare_item and Parameters as item_parameters, return
// an ASCII string suitable for use in a HTTP field value.
//
// 1.  Let output be an empty string.
//
// 2.  Append the result of running Serializing a Bare Item
//     Section 4.1.3.1 with bare_item to output.
//
// 3.  Append the result of running Serializing Parameters
//     Section 4.1.1.2 with item_parameters to output.
//
// 4.  Return output.
/**
 * @param {Item} value
 * @return {string}
 */
function serializeItem(value) {
    if (value === null ||
        value === undefined ||
        Array.isArray(value) === true ||
        value instanceof Map)
        throw new Error(`failed to serialize ${value} as Item`);
    if (value instanceof Item) {
        return `${serializeBareItem(value.value)}${serializeParams(value.params)}`;
    }
    else {
        return serializeBareItem(value);
    }
}
exports.serializeItem = serializeItem;
// 4.1.3.1.  Serializing a Bare Item
//
// Given an Item as input_item, return an ASCII string suitable for use
// in a HTTP field value.
//
// 1.  If input_item is an Integer, return the result of running
//     Serializing an Integer (Section 4.1.4) with input_item.
//
// 2.  If input_item is a Decimal, return the result of running
//     Serializing a Decimal (Section 4.1.5) with input_item.
//
// 3.  If input_item is a String, return the result of running
//     Serializing a String (Section 4.1.6) with input_item.
//
// 4.  If input_item is a Token, return the result of running
//     Serializing a Token (Section 4.1.7) with input_item.
//
// 5.  If input_item is a Boolean, return the result of running
//     Serializing a Boolean (Section 4.1.9) with input_item.
//
// 6.  If input_item is a Byte Sequence, return the result of running
//     Serializing a Byte Sequence (Section 4.1.8) with input_item.
//
// 7.  Otherwise, fail serialization.
/**
 * @param {any} value
 * @return {string}
 */
function serializeBareItem(value) {
    switch (typeof value) {
        case 'number':
            if (Number.isInteger(value)) {
                return serializeInteger(value);
            }
            return serializeDecimal(value);
        case 'string':
            return serializeString(value);
        case 'symbol':
            return serializeToken(value);
        case 'boolean':
            return serializeBoolean(value);
        case 'object':
            if (value instanceof Uint8Array) {
                return serializeByteSequence(value);
            }
        default:
            throw new Error(`failed to serialize ${value} as Bare Item`);
    }
}
exports.serializeBareItem = serializeBareItem;
// 4.1.4.  Serializing an Integer
//
// Given an Integer as input_integer, return an ASCII string suitable
// for use in a HTTP field value.
//
// 1.  If input_integer is not an integer in the range of
//     -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail
//     serialization.
//
// 2.  Let output be an empty string.
//
// 3.  If input_integer is less than (but not equal to) 0, append "-" to
//     output.
//
// 4.  Append input_integer's numeric value represented in base 10 using
//     only decimal digits to output.
//
// 5.  Return output.
/**
 * @param {number} value
 * @return {string}
 */
function serializeInteger(value) {
    if (value < -999999999999999n || 999999999999999n < value)
        throw new Error(`failed to serialize ${value} as Integer`);
    return value.toString();
}
exports.serializeInteger = serializeInteger;
// 4.1.5.  Serializing a Decimal
//
// Given a decimal number as input_decimal, return an ASCII string
// suitable for use in a HTTP field value.
//
// 1.   If input_decimal is not a decimal number, fail serialization.
//
// 2.   If input_decimal has more than three significant digits to the
//      right of the decimal point, round it to three decimal places,
//      rounding the final digit to the nearest value, or to the even
//      value if it is equidistant.
//
// 3.   If input_decimal has more than 12 significant digits to the left
//      of the decimal point after rounding, fail serialization.
//
// 4.   Let output be an empty string.
//
// 5.   If input_decimal is less than (but not equal to) 0, append "-"
//      to output.
//
// 6.   Append input_decimal's integer component represented in base 10
//      (using only decimal digits) to output; if it is zero, append
//      "0".
//
// 7.   Append "." to output.
//
// 8.   If input_decimal's fractional component is zero, append "0" to
//      output.
//
// 9.   Otherwise, append the significant digits of input_decimal's
//      fractional component represented in base 10 (using only decimal
//      digits) to output.
//
// 10.  Return output.
/**
 * @param {number} value
 * @return {string}
 */
function serializeDecimal(value) {
    const roundedValue = roundToEven(value, 3); // round to 3 decimal places
    if (Math.floor(Math.abs(roundedValue)).toString().length > 12)
        throw new Error(`failed to serialize ${value} as Decimal`);
    const stringValue = roundedValue.toString();
    return stringValue.includes('.') ? stringValue : `${stringValue}.0`;
}
exports.serializeDecimal = serializeDecimal;
/**
 * This implements the rounding procedure described in step 2 of the "Serializing a Decimal" specification.
 * This rounding style is known as "even rounding", "banker's rounding", or "commercial rounding".
 *
 * @param {number} value
 * @param {number} precision - decimal places to round to
 * @return {number}
 */
function roundToEven(value, precision) {
    if (value < 0) {
        return -roundToEven(-value, precision);
    }
    const decimalShift = Math.pow(10, precision);
    const isEquidistant = Math.abs(((value * decimalShift) % 1) - 0.5) < Number.EPSILON;
    if (isEquidistant) {
        // If the tail of the decimal place is 'equidistant' we round to the nearest even value
        const flooredValue = Math.floor(value * decimalShift);
        return ((flooredValue % 2 === 0 ? flooredValue : flooredValue + 1) / decimalShift);
    }
    else {
        // Otherwise, proceed as normal
        return Math.round(value * decimalShift) / decimalShift;
    }
}
// 4.1.6.  Serializing a String
//
// Given a String as input_string, return an ASCII string suitable for
// use in a HTTP field value.
//
// 1.  Convert input_string into a sequence of ASCII characters; if
//     conversion fails, fail serialization.
//
// 2.  If input_string contains characters in the range %x00-1f or %x7f
//     (i.e., not in VCHAR or SP), fail serialization.
//
// 3.  Let output be the string DQUOTE.
//
// 4.  For each character char in input_string:
//
//     1.  If char is "\" or DQUOTE:
//
//         1.  Append "\" to output.
//
//     2.  Append char to output.
//
// 5.  Append DQUOTE to output.
//
// 6.  Return output.
/**
 * @param {string} value
 * @return {string}
 */
function serializeString(value) {
    if (/[\x00-\x1f\x7f]+/.test(value))
        throw new Error(`failed to serialize ${value} as string`);
    return `"${value.replace(/\\/g, `\\\\`).replace(/"/g, `\\\"`)}"`;
}
exports.serializeString = serializeString;
// 4.1.7.  Serializing a Token
//
// Given a Token as input_token, return an ASCII string suitable for use
// in a HTTP field value.
//
// 1.  Convert input_token into a sequence of ASCII characters; if
//     conversion fails, fail serialization.
//
// 2.  If the first character of input_token is not ALPHA or "*", or the
//     remaining portion contains a character not in tchar, ":" or "/",
//     fail serialization.
//
// 3.  Let output be an empty string.
//
// 4.  Append input_token to output.
//
// 5.  Return output.
/**
 * @param {symbol} token
 * @return {string}
 */
function serializeToken(token) {
    /** @type {string} */
    const value = Symbol.keyFor(token);
    if (/^([a-zA-Z\*])([\!\#\$\%\&\'\*\+\-\.\^\_\`\|\~\w\:\/]*)$/.test(value) ===
        false) {
        throw new Error(`failed to serialize ${value} as token`);
    }
    return value;
}
exports.serializeToken = serializeToken;
// 4.1.9.  Serializing a Boolean
//
// Given a Boolean as input_boolean, return an ASCII string suitable for
// use in a HTTP field value.
//
// 1.  If input_boolean is not a boolean, fail serialization.
//
// 2.  Let output be an empty string.
//
// 3.  Append "?" to output.
//
// 4.  If input_boolean is true, append "1" to output.
//
// 5.  If input_boolean is false, append "0" to output.
//
// 6.  Return output.
/**
 * @param {boolean} value
 * @return {string}
 */
function serializeBoolean(value) {
    if (typeof value !== 'boolean')
        throw new Error(`failed to serialize ${value} as boolean`);
    return value ? '?1' : '?0';
}
exports.serializeBoolean = serializeBoolean;
// 4.1.8.  Serializing a Byte Sequence
//
// Given a Byte Sequence as input_bytes, return an ASCII string suitable
// for use in a HTTP field value.
//
// 1.  If input_bytes is not a sequence of bytes, fail serialization.
//
// 2.  Let output be an empty string.
//
// 3.  Append ":" to output.
//
// 4.  Append the result of base64-encoding input_bytes as per
//     [RFC4648], Section 4, taking account of the requirements below.
//
// 5.  Append ":" to output.
//
// 6.  Return output.
//
// The encoded data is required to be padded with "=", as per [RFC4648],
// Section 3.2.
//
// Likewise, encoded data SHOULD have pad bits set to zero, as per
// [RFC4648], Section 3.5, unless it is not possible to do so due to
// implementation constraints.
/**
 * @param {Uint8Array} value
 * @return {string}
 */
function serializeByteSequence(value) {
    if (ArrayBuffer.isView(value) === false)
        throw new Error(`failed to serialize ${value} as Byte Sequence`);
    return `:${base64encode(value)}:`;
}
exports.serializeByteSequence = serializeByteSequence;
// 4.2.1.  Parsing a List
//
// Given an ASCII string as input_string, return an array of
// (item_or_inner_list, parameters) tuples. input_string is modified to
// remove the parsed value.
//
// 1.  Let members be an empty array.
//
// 2.  While input_string is not empty:
//
//     1.  Append the result of running Parsing an Item or Inner List
//         (Section 4.2.1.1) with input_string to members.
//
//     2.  Discard any leading OWS characters from input_string.
//
//     3.  If input_string is empty, return members.
//
//     4.  Consume the first character of input_string; if it is not
//         ",", fail parsing.
//
//     5.  Discard any leading OWS characters from input_string.
//
//     6.  If input_string is empty, there is a trailing comma; fail
//         parsing.
//
// 3.  No structured data has been found; return members (which is
//     empty).
/**
 * @typedef {Array.<Item|InnerList>} MemberList
 *
 * @typedef {Object} ParsedList
 * @property {MemberList} value
 * @property {string} input_string
 *
 * @param {string} input_string
 * @return {ParsedList}
 */
function parseList(input_string) {
    /** @type {MemberList} */
    const members = [];
    while (input_string.length > 0) {
        /** @type {ParsedItemOrInnerList} */
        const parsedItemOrInnerList = parseItemOrInnerList(input_string);
        members.push(parsedItemOrInnerList.value);
        input_string = parsedItemOrInnerList.input_string.trim();
        if (input_string.length === 0)
            return { input_string, value: members };
        if (input_string[0] !== ',')
            throw new Error(`failed to parse ${input_string} as List`);
        input_string = input_string.substr(1).trim();
        if (input_string.length === 0 || input_string[0] === ',')
            throw new Error(`failed to parse ${input_string} as List`);
    }
    return {
        value: members,
        input_string
    };
}
exports.parseList = parseList;
// 4.2.1.1.  Parsing an Item or Inner List
//
// Given an ASCII string as input_string, return the tuple
// (item_or_inner_list, parameters), where item_or_inner_list can be
// either a single bare item, or an array of (bare_item, parameters)
// tuples. input_string is modified to remove the parsed value.
//
// 1.  If the first character of input_string is "(", return the result
//     of running Parsing an Inner List (Section 4.2.1.2) with
//     input_string.
//
// 2.  Return the result of running Parsing an Item (Section 4.2.3) with
//     input_string.
/**
 * @typedef {ParsedItem|ParsedInnerList} ParsedItemOrInnerList
 *
 * @param {string} input_string
 * @return {ParsedItemOrInnerList}
 */
function parseItemOrInnerList(input_string) {
    if (input_string[0] === '(') {
        return parseInnerList(input_string);
    }
    return parseItem(input_string);
}
exports.parseItemOrInnerList = parseItemOrInnerList;
// 4.2.1.2.  Parsing an Inner List
//
// Given an ASCII string as input_string, return the tuple (inner_list,
// parameters), where inner_list is an array of (bare_item, parameters)
// tuples. input_string is modified to remove the parsed value.
//
// 1.  Consume the first character of input_string; if it is not "(",
//     fail parsing.
//
// 2.  Let inner_list be an empty array.
//
// 3.  While input_string is not empty:
//
//     1.  Discard any leading SP characters from input_string.
//
//     2.  If the first character of input_string is ")":
//
//         1.  Consume the first character of input_string.
//
//         2.  Let parameters be the result of running Parsing
//             Parameters (Section 4.2.3.2) with input_string.
//
//         3.  Return the tuple (inner_list, parameters).
//
//     3.  Let item be the result of running Parsing an Item
//         (Section 4.2.3) with input_string.
//
//     4.  Append item to inner_list.
//
//     5.  If the first character of input_string is not SP or ")", fail
//         parsing.
//
// 4.  The end of the inner list was not found; fail parsing.
/**
 * @typedef {Array.<Item>} ItemList
 *
 * @typedef {{value: ItemList, params: Parameters}} InnerList
 *
 * @typedef {Object} ParsedInnerList
 * @property {InnerList} value
 * @property {string} input_string
 *
 * @param {string} input_string
 * @return {ParsedInnerList}
 */
function parseInnerList(input_string) {
    if (input_string[0] !== '(')
        throw new Error(`failed to parse ${input_string} as Inner List`);
    input_string = input_string.substr(1);
    /** @type {ItemList}  */
    const inner_list = [];
    while (input_string.length > 0) {
        input_string = input_string.trim();
        if (input_string[0] === ')') {
            input_string = input_string.substr(1);
            const parsedParameters = parseParameters(input_string);
            return {
                value: new Item(inner_list, parsedParameters.value),
                input_string: parsedParameters.input_string
            };
        }
        /** @type {ParsedItem} */
        const parsedItem = parseItem(input_string);
        inner_list.push(parsedItem.value);
        input_string = parsedItem.input_string;
        if (input_string[0] !== ' ' && input_string[0] !== ')')
            throw new Error(`failed to parse ${input_string} as Inner List`);
    }
    throw new Error(`failed to parse ${input_string} as Inner List`);
}
exports.parseInnerList = parseInnerList;
// 4.2.2.  Parsing a Dictionary
//
// Given an ASCII string as input_string, return an ordered map whose
// values are (item_or_inner_list, parameters) tuples. input_string is
// modified to remove the parsed value.
//
// 1.  Let dictionary be an empty, ordered map.
//
// 2.  While input_string is not empty:
//
//     1.  Let this_key be the result of running Parsing a Key
//         (Section 4.2.3.3) with input_string.
//
//     2.  If the first character of input_string is "=":
//
//         1.  Consume the first character of input_string.
//
//         2.  Let member be the result of running Parsing an Item or
//             Inner List (Section 4.2.1.1) with input_string.
//
//     3.  Otherwise:
//
//         1.  Let value be Boolean true.
//
//         2.  Let parameters be the result of running Parsing
//             Parameters Section 4.2.3.2 with input_string.
//
//         3.  Let member be the tuple (value, parameters).
//
//     4.  Add name this_key with value member to dictionary.  If
//         dictionary already contains a name this_key (comparing
//         character-for-character), overwrite its value.
//
//     5.  Discard any leading OWS characters from input_string.
//
//     6.  If input_string is empty, return dictionary.
//
//     7.  Consume the first character of input_string; if it is not
//         ",", fail parsing.
//
//     8.  Discard any leading OWS characters from input_string.
//
//     9.  If input_string is empty, there is a trailing comma; fail
//         parsing.
//
// 3.  No structured data has been found; return dictionary (which is
//     empty).
//
// Note that when duplicate Dictionary keys are encountered, this has
// the effect of ignoring all but the last instance.
/**
 * @typedef {Object.<Key, Item|InnerList>|Map} Dictionary
 *
 * @typedef {Object} ParsedDictionary
 * @property {Dictionary} value
 * @property {string} input_string
 *
 * @param {string} input_string
 * @param {Object?} option
 * @return {ParsedDictionary}
 */
function parseDictionary(input_string, option = {}) {
    // TODO: option is not fully supported yet
    /** @type {Array.<[Key, Item|InnerList]>} */
    const value = []; // ordered map
    /**
     * @param {Array.<[Key, Item|InnerList]>} entries
     * @return {Dictionary}
     */
    function toDict(entries) {
        if ((option === null || option === void 0 ? void 0 : option.use_map) === true)
            return new Map(entries);
        return Object.fromEntries(entries);
    }
    while (input_string.length > 0) {
        /** @type {Item|InnerList} */
        let member;
        /** @type {ParsedKey} */
        const parsedKey = parseKey(input_string);
        /** @type {Key} */
        const this_key = parsedKey.value;
        input_string = parsedKey.input_string;
        if (input_string[0] === '=') {
            /** @type {ParsedItemOrInnerList} */
            const parsedItemOrInnerList = parseItemOrInnerList(input_string.substr(1));
            member = parsedItemOrInnerList.value;
            input_string = parsedItemOrInnerList.input_string;
        }
        else {
            /** @type {ParsedParameters} */
            const parsedParameters = parseParameters(input_string);
            member = new Item(true, parsedParameters.value);
            input_string = parsedParameters.input_string;
        }
        value.push([this_key, member]);
        input_string = input_string.trim();
        if (input_string.length === 0)
            return { input_string, value: toDict(value) };
        if (input_string[0] !== ',')
            throw new Error(`failed to parse ${input_string} as Dictionary`);
        input_string = input_string.substr(1).trim();
        if (input_string.length === 0 || input_string[0] === ',')
            throw new Error(`failed to parse ${input_string} as Dictionary`);
    }
    return {
        value: toDict(value),
        input_string
    };
}
exports.parseDictionary = parseDictionary;
// 4.2.3.  Parsing an Item
//
// Given an ASCII string as input_string, return a (bare_item,
// parameters) tuple. input_string is modified to remove the parsed
// value.
//
// 1.  Let bare_item be the result of running Parsing a Bare Item
//     (Section 4.2.3.1) with input_string.
//
// 2.  Let parameters be the result of running Parsing Parameters
//     (Section 4.2.3.2) with input_string.
//
// 3.  Return the tuple (bare_item, parameters).
/**
 * @typedef {Object} ParsedItem
 * @property {Item} value
 * @property {string} input_string
 *
 * @param {string} input_string
 * @return {ParsedItem}
 */
function parseItem(input_string) {
    const parsedBareItem = parseBareItem(input_string);
    const value = parsedBareItem.value;
    input_string = parsedBareItem.input_string;
    const parsedParameters = parseParameters(input_string);
    const params = parsedParameters.value;
    input_string = parsedParameters.input_string;
    /** @type {Item} */
    const item = new Item(value, params);
    return {
        value: item,
        input_string
    };
}
exports.parseItem = parseItem;
// 4.2.3.1.  Parsing a Bare Item
//
// Given an ASCII string as input_string, return a bare Item.
// input_string is modified to remove the parsed value.
//
// 1.  If the first character of input_string is a "-" or a DIGIT,
//     return the result of running Parsing an Integer or Decimal
//     (Section 4.2.4) with input_string.
//
// 2.  If the first character of input_string is a DQUOTE, return the
//     result of running Parsing a String (Section 4.2.5) with
//     input_string.
//
// 3.  If the first character of input_string is ":", return the result
//     of running Parsing a Byte Sequence (Section 4.2.7) with
//     input_string.
//
// 4.  If the first character of input_string is "?", return the result
//     of running Parsing a Boolean (Section 4.2.8) with input_string.
//
// 5.  If the first character of input_string is an ALPHA or "*", return
//     the result of running Parsing a Token (Section 4.2.6) with
//     input_string.
//
// 6.  Otherwise, the item type is unrecognized; fail parsing.
/**
 * @typedef {ParsedString|ParsedByteSequence|ParsedBoolean|ParsedIntegerOrDecimal|ParsedToken} ParsedBareItem
 *
 * @param {string} input_string
 * @return {ParsedBareItem}
 */
function parseBareItem(input_string) {
    const first = input_string[0];
    if (first === `"`) {
        return parseString(input_string);
    }
    if (first === `:`) {
        return parseByteSequence(input_string);
    }
    if (first === `?`) {
        return parseBoolean(input_string);
    }
    if (/^[\-0-9]/.test(first)) {
        return parseIntegerOrDecimal(input_string);
    }
    if (/^[a-zA-Z\*]/.test(first)) {
        return parseToken(input_string);
    }
    throw new Error(`failed to parse ${input_string} as Bare Item`);
}
exports.parseBareItem = parseBareItem;
// 4.2.3.2.  Parsing Parameters
//
// Given an ASCII string as input_string, return an ordered map whose
// values are bare Items. input_string is modified to remove the parsed
// value.
//
// 1.  Let parameters be an empty, ordered map.
//
// 2.  While input_string is not empty:
//
//     1.  If the first character of input_string is not ";", exit the
//         loop.
//
//     2.  Consume a ";" character from the beginning of input_string.
//
//     3.  Discard any leading SP characters from input_string.
//
//     4.  let param_name be the result of running Parsing a Key
//         (Section 4.2.3.3) with input_string.
//
//     5.  Let param_value be Boolean true.
//
//     6.  If the first character of input_string is "=":
//
//         1.  Consume the "=" character at the beginning of
//             input_string.
//
//         2.  Let param_value be the result of running Parsing a Bare
//             Item (Section 4.2.3.1) with input_string.
//
//     7.  Append key param_name with value param_value to parameters.
//         If parameters already contains a name param_name (comparing
//         character-for-character), overwrite its value.
//
// 3.  Return parameters.
//
// Note that when duplicate Parameter keys are encountered, this has the
// effect of ignoring all but the last instance.
/**
 * @typedef {string | Uint8Array | boolean | number | symbol} BareItem
 *
 * @typedef {Object.<Key, BareItem>} Parameters
 *
 * @typedef {Object} ParsedParameters
 * @property {Parameters} value
 * @property {string} input_string
 *
 * @param {string} input_string
 * @return {ParsedParameters}
 */
function parseParameters(input_string) {
    /**
     * null by default for easy to detect parameter existance.
     * @type {Parameters}
     */
    let parameters = null;
    while (input_string.length > 0) {
        if (input_string[0] !== ';')
            break;
        input_string = input_string.substr(1).trim();
        const parsedKey = parseKey(input_string);
        const param_name = parsedKey.value;
        /** @type {BareItem} */
        let param_value = true;
        input_string = parsedKey.input_string;
        if (input_string[0] === '=') {
            input_string = input_string.substr(1);
            const parsedBareItem = parseBareItem(input_string);
            param_value = parsedBareItem.value;
            input_string = parsedBareItem.input_string;
        }
        // initialize as object when params exists
        if (parameters === null)
            parameters = {};
        // override if param_name exists
        parameters[param_name] = param_value;
    }
    return {
        value: parameters,
        input_string
    };
}
exports.parseParameters = parseParameters;
// 4.2.3.3.  Parsing a Key
//
// Given an ASCII string as input_string, return a key. input_string is
// modified to remove the parsed value.
//
// 1.  If the first character of input_string is not lcalpha or "*",
//     fail parsing.
//
// 2.  Let output_string be an empty string.
//
// 3.  While input_string is not empty:
//
//     1.  If the first character of input_string is not one of lcalpha,
//         DIGIT, "_", "-", ".", or "*", return output_string.
//
//     2.  Let char be the result of consuming the first character of
//         input_string.
//
//     3.  Append char to output_string.
//
// 4.  Return output_string.
/**
 * @typedef {string} Key
 *
 * @typedef {Object} ParsedKey
 * @property {Key} value
 * @property {string} input_string
 *
 * @param {string} input_string
 * @return {ParsedKey}
 */
function parseKey(input_string) {
    let i = 0;
    if (/^[a-z\*]$/.test(input_string[i]) === false) {
        throw new Error(`failed to parse ${input_string} as Key`);
    }
    /** @type {Key} */
    let output_string = '';
    while (input_string.length > i) {
        if (/^[a-z0-9\_\-\.\*]$/.test(input_string[i]) === false) {
            return {
                value: output_string,
                input_string: input_string.substr(i)
            };
        }
        output_string += input_string[i];
        i++;
    }
    return {
        value: output_string,
        input_string: input_string.substr(i)
    };
}
exports.parseKey = parseKey;
// 4.2.4.  Parsing an Integer or Decimal
//
// Given an ASCII string as input_string, return an Integer or Decimal.
// input_string is modified to remove the parsed value.
//
// NOTE: This algorithm parses both Integers (Section 3.3.1) and
// Decimals (Section 3.3.2), and returns the corresponding structure.
//
// 1.   Let type be "integer".
//
// 2.   Let sign be 1.
//
// 3.   Let input_number be an empty string.
//
// 4.   If the first character of input_string is "-", consume it and
//      set sign to -1.
//
// 5.   If input_string is empty, there is an empty integer; fail
//      parsing.
//
// 6.   If the first character of input_string is not a DIGIT, fail
//      parsing.
//
// 7.   While input_string is not empty:
//
//      1.  Let char be the result of consuming the first character of
//          input_string.
//
//      2.  If char is a DIGIT, append it to input_number.
//
//      3.  Else, if type is "integer" and char is ".":
//
//          1.  If input_number contains more than 12 characters, fail
//              parsing.
//
//          2.  Otherwise, append char to input_number and set type to
//              "decimal".
//
//      4.  Otherwise, prepend char to input_string, and exit the loop.
//
//      5.  If type is "integer" and input_number contains more than 15
//          characters, fail parsing.
//
//      6.  If type is "decimal" and input_number contains more than 16
//          characters, fail parsing.
//
// 8.   If type is "integer":
//
//      1.  Parse input_number as an integer and let output_number be
//          the product of the result and sign.
//
//      2.  If output_number is outside the range -999,999,999,999,999
//          to 999,999,999,999,999 inclusive, fail parsing.
//
// 9.   Otherwise:
//
//      1.  If the final character of input_number is ".", fail parsing.
//
//      2.  If the number of characters after "." in input_number is
//          greater than three, fail parsing.
//
//      3.  Parse input_number as a decimal number and let output_number
//          be the product of the result and sign.
//
// 10.  Return output_number.
/**
 * @typedef {Object} ParsedIntegerOrDecimal
 * @property {number} value
 * @property {string} input_string
 *
 * @param {string} input_string
 * @return {ParsedIntegerOrDecimal}
 */
function parseIntegerOrDecimal(input_string) {
    let type = 'integer';
    let sign = 1;
    let input_number = '';
    let output_number;
    let i = 0;
    if (input_string[i] === '-') {
        sign = -1;
        input_string = input_string.substr(1);
    }
    if (input_string.length <= 0)
        throw new Error(`failed to parse ${input_string} as Integer or Decimal`);
    const re_integer = /^(\d+)?/g;
    const result_integer = re_integer.exec(input_string);
    if (result_integer[0].length === 0)
        throw new Error(`failed to parse ${input_string} as Integer or Decimal`);
    input_number += result_integer[1];
    input_string = input_string.substr(re_integer.lastIndex);
    if (input_string[0] === '.') {
        // decimal
        if (input_number.length > 12)
            throw new Error(`failed to parse ${input_string} as Integer or Decimal`);
        const re_decimal = /^(\.\d+)?/g;
        const result_decimal = re_decimal.exec(input_string);
        input_string = input_string.substr(re_decimal.lastIndex);
        // 9.2.  If the number of characters after "." in input_number is greater than three, fail parsing.
        if (result_decimal[0].length === 0 || result_decimal[1].length > 4)
            throw new Error(`failed to parse ${input_string} as Integer or Decimal`);
        input_number += result_decimal[1];
        // 7.6.  If type is "decimal" and input_number contains more than 16 characters, fail parsing.
        if (input_number.length > 16)
            throw new Error(`failed to parse ${input_string} as Integer or Decimal`);
        output_number = parseFloat(input_number) * sign;
    }
    else {
        // integer
        // 7.5.  If type is "integer" and input_number contains more than 15 characters, fail parsing.
        if (input_number.length > 15)
            throw new Error(`failed to parse ${input_string} as Integer or Decimal`);
        output_number = parseInt(input_number) * sign;
        if (output_number < -999999999999999n || 999999999999999n < output_number)
            throw new Error(`failed to parse integer: ${input_number} as Integer or Decimal`);
    }
    return {
        value: output_number,
        input_string
    };
}
exports.parseIntegerOrDecimal = parseIntegerOrDecimal;
// 4.2.5.  Parsing a String
//
// Given an ASCII string as input_string, return an unquoted String.
// input_string is modified to remove the parsed value.
//
// 1.  Let output_string be an empty string.
//
// 2.  If the first character of input_string is not DQUOTE, fail
//     parsing.
//
// 3.  Discard the first character of input_string.
//
// 4.  While input_string is not empty:
//
//     1.  Let char be the result of consuming the first character of
//         input_string.
//
//     2.  If char is a backslash ("\"):
//
//         1.  If input_string is now empty, fail parsing.
//
//         2.  Let next_char be the result of consuming the first
//             character of input_string.
//
//         3.  If next_char is not DQUOTE or "\", fail parsing.
//
//         4.  Append next_char to output_string.
//
//     3.  Else, if char is DQUOTE, return output_string.
//
//     4.  Else, if char is in the range %x00-1f or %x7f (i.e., is not
//         in VCHAR or SP), fail parsing.
//
//     5.  Else, append char to output_string.
//
// 5.  Reached the end of input_string without finding a closing DQUOTE;
//     fail parsing.
/**
 * @typedef {Object} ParsedString
 * @property {string} value
 * @property {string} input_string
 *
 * @param {string} input_string
 * @return {ParsedString}
 */
function parseString(input_string) {
    let output_string = '';
    let i = 0;
    if (input_string[i] !== `"`) {
        throw new Error(`failed to parse ${input_string} as String`);
    }
    i++;
    while (input_string.length > i) {
        // console.log(i, input_string[i], output_string)
        if (input_string[i] === `\\`) {
            if (input_string.length <= i + 1) {
                throw new Error(`failed to parse ${input_string} as String`);
            }
            i++;
            if (input_string[i] !== `"` && input_string[i] !== `\\`) {
                throw new Error(`failed to parse ${input_string} as String`);
            }
            output_string += input_string[i];
        }
        else if (input_string[i] === `"`) {
            return {
                value: output_string,
                input_string: input_string.substr(++i)
            };
        }
        else if (/[\x00-\x1f\x7f]+/.test(input_string[i])) {
            throw new Error(`failed to parse ${input_string} as String`);
        }
        else {
            output_string += input_string[i];
        }
        i++;
    }
    throw new Error(`failed to parse ${input_string} as String`);
}
exports.parseString = parseString;
// 4.2.6.  Parsing a Token
//
// Given an ASCII string as input_string, return a Token. input_string
// is modified to remove the parsed value.
//
// 1.  If the first character of input_string is not ALPHA or "*", fail
//     parsing.
//
// 2.  Let output_string be an empty string.
//
// 3.  While input_string is not empty:
//
//     1.  If the first character of input_string is not in tchar, ":"
//         or "/", return output_string.
//
//     2.  Let char be the result of consuming the first character of
//         input_string.
//
//     3.  Append char to output_string.
//
// 4.  Return output_string.
/**
 * @typedef {Object} ParsedToken
 * @property {symbol} value
 * @property {string} input_string
 *
 * @param {string} input_string
 * @return {ParsedToken}
 */
function parseToken(input_string) {
    if (/^[a-zA-Z\*]$/.test(input_string[0]) === false) {
        throw new Error(`failed to parse ${input_string} as Token`);
    }
    const re = /^([\!\#\$\%\&\'\*\+\-\.\^\_\`\|\~\w\:\/]+)/g;
    const output_string = re.exec(input_string)[1];
    input_string = input_string.substr(re.lastIndex);
    return {
        value: Symbol.for(output_string),
        input_string
    };
}
exports.parseToken = parseToken;
// 4.2.7.  Parsing a Byte Sequence
//
// Given an ASCII string as input_string, return a Byte Sequence.
// input_string is modified to remove the parsed value.
//
// 1.  If the first character of input_string is not ":", fail parsing.
//
// 2.  Discard the first character of input_string.
//
// 3.  If there is not a ":" character before the end of input_string,
//     fail parsing.
//
// 4.  Let b64_content be the result of consuming content of
//     input_string up to but not including the first instance of the
//     character ":".
//
// 5.  Consume the ":" character at the beginning of input_string.
//
// 6.  If b64_content contains a character not included in ALPHA, DIGIT,
//     "+", "/" and "=", fail parsing.
//
// 7.  Let binary_content be the result of Base 64 Decoding [RFC4648]
//     b64_content, synthesizing padding if necessary (note the
//     requirements about recipient behavior below).
//
// 8.  Return binary_content.
//
// Because some implementations of base64 do not allow rejection of
// encoded data that is not properly "=" padded (see [RFC4648],
// Section 3.2), parsers SHOULD NOT fail when "=" padding is not
// present, unless they cannot be configured to do so.
//
// Because some implementations of base64 do not allow rejection of
// encoded data that has non-zero pad bits (see [RFC4648], Section 3.5),
// parsers SHOULD NOT fail when non-zero pad bits are present, unless
// they cannot be configured to do so.
//
// This specification does not relax the requirements in [RFC4648],
// Section 3.1 and 3.3; therefore, parsers MUST fail on characters
// outside the base64 alphabet, and on line feeds in encoded data.
/**
 * @typedef {Object} ParsedByteSequence
 * @property {Uint8Array} value
 * @property {string} input_string
 *
 * @param {string} input_string
 * @return {ParsedByteSequence}
 */
function parseByteSequence(input_string) {
    if (input_string[0] !== ':')
        throw new Error(`failed to parse ${input_string} as Byte Sequence`);
    input_string = input_string.substr(1);
    if (input_string.includes(':') === false)
        throw new Error(`failed to parse ${input_string} as Byte Sequence`);
    const re = /(^.*?)(:)/g;
    const b64_content = re.exec(input_string)[1];
    input_string = input_string.substr(re.lastIndex);
    // pass b64_content char check step 6
    const binary_content = base64decode(b64_content);
    return {
        value: binary_content,
        input_string
    };
}
exports.parseByteSequence = parseByteSequence;
// 4.2.8.  Parsing a Boolean
//
// Given an ASCII string as input_string, return a Boolean. input_string
// is modified to remove the parsed value.
//
// 1.  If the first character of input_string is not "?", fail parsing.
//
// 2.  Discard the first character of input_string.
//
// 3.  If the first character of input_string matches "1", discard the
//     first character, and return true.
//
// 4.  If the first character of input_string matches "0", discard the
//     first character, and return false.
//
// 5.  No value has matched; fail parsing.
/**
 * @typedef {Object} ParsedBoolean
 * @property {boolean} value
 * @property {string} input_string
 *
 * @param {string} input_string
 * @return {ParsedBoolean}
 */
function parseBoolean(input_string) {
    let i = 0;
    if (input_string[i] !== '?') {
        throw new Error(`failed to parse ${input_string} as Boolean`);
    }
    i++;
    if (input_string[i] === '1') {
        return {
            value: true,
            input_string: input_string.substr(++i)
        };
    }
    if (input_string[i] === '0') {
        return {
            value: false,
            input_string: input_string.substr(++i)
        };
    }
    throw new Error(`failed to parse ${input_string} as Boolean`);
}
exports.parseBoolean = parseBoolean;
/////////////////////////
// base64 uility
/////////////////////////
/**
 * @param {string} str
 * @return {Uint8Array}
 */
function base64decode(str) {
    if (typeof window === `undefined`) {
        return Uint8Array.from(/**@type {node.Buffer}*/ Buffer.from(str, `base64`));
    }
    else {
        return new Uint8Array([...atob(str)].map(a => a.charCodeAt(0)));
    }
}
exports.base64decode = base64decode;
/**
 * @param {Uint8Array} binary
 * @return {string}
 */
function base64encode(binary) {
    if (typeof window === `undefined`) {
        return Buffer.from(binary).toString(`base64`);
    }
    else {
        return btoa(String.fromCharCode(...binary));
    }
}
exports.base64encode = base64encode;


/***/ }),

/***/ 7351:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const os = __importStar(__webpack_require__(2087));
const utils_1 = __webpack_require__(5278);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 2186:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const command_1 = __webpack_require__(7351);
const file_command_1 = __webpack_require__(717);
const utils_1 = __webpack_require__(5278);
const os = __importStar(__webpack_require__(2087));
const path = __importStar(__webpack_require__(5622));
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        const delimiter = '_GitHubActionsFileCommandDelimeter_';
        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;
        file_command_1.issueCommand('ENV', commandValue);
    }
    else {
        command_1.issueCommand('set-env', { name }, convertedVal);
    }
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.  The value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    command_1.issueCommand('set-output', { name }, value);
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 */
function error(message) {
    command_1.issue('error', message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds an warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 */
function warning(message) {
    command_1.issue('warning', message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    command_1.issueCommand('save-state', { name }, value);
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 717:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// For internal use, subject to change.
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__webpack_require__(5747));
const os = __importStar(__webpack_require__(2087));
const utils_1 = __webpack_require__(5278);
function issueCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueCommand = issueCommand;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 5278:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 4087:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Context = void 0;
const fs_1 = __webpack_require__(5747);
const os_1 = __webpack_require__(2087);
class Context {
    /**
     * Hydrate the context from the environment
     */
    constructor() {
        this.payload = {};
        if (process.env.GITHUB_EVENT_PATH) {
            if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {
                this.payload = JSON.parse(fs_1.readFileSync(process.env.GITHUB_EVENT_PATH, { encoding: 'utf8' }));
            }
            else {
                const path = process.env.GITHUB_EVENT_PATH;
                process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
            }
        }
        this.eventName = process.env.GITHUB_EVENT_NAME;
        this.sha = process.env.GITHUB_SHA;
        this.ref = process.env.GITHUB_REF;
        this.workflow = process.env.GITHUB_WORKFLOW;
        this.action = process.env.GITHUB_ACTION;
        this.actor = process.env.GITHUB_ACTOR;
        this.job = process.env.GITHUB_JOB;
        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
    }
    get issue() {
        const payload = this.payload;
        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
    }
    get repo() {
        if (process.env.GITHUB_REPOSITORY) {
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            return { owner, repo };
        }
        if (this.payload.repository) {
            return {
                owner: this.payload.repository.owner.login,
                repo: this.payload.repository.name
            };
        }
        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
    }
}
exports.Context = Context;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ 5438:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOctokit = exports.context = void 0;
const Context = __importStar(__webpack_require__(4087));
const utils_1 = __webpack_require__(3030);
exports.context = new Context.Context();
/**
 * Returns a hydrated octokit ready to use for GitHub Actions
 *
 * @param     token    the repo PAT or GITHUB_TOKEN
 * @param     options  other options to set
 */
function getOctokit(token, options) {
    return new utils_1.GitHub(utils_1.getOctokitOptions(token, options));
}
exports.getOctokit = getOctokit;
//# sourceMappingURL=github.js.map

/***/ }),

/***/ 7914:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getApiBaseUrl = exports.getProxyAgent = exports.getAuthString = void 0;
const httpClient = __importStar(__webpack_require__(9925));
function getAuthString(token, options) {
    if (!token && !options.auth) {
        throw new Error('Parameter token or opts.auth is required');
    }
    else if (token && options.auth) {
        throw new Error('Parameters token and opts.auth may not both be specified');
    }
    return typeof options.auth === 'string' ? options.auth : `token ${token}`;
}
exports.getAuthString = getAuthString;
function getProxyAgent(destinationUrl) {
    const hc = new httpClient.HttpClient();
    return hc.getAgent(destinationUrl);
}
exports.getProxyAgent = getProxyAgent;
function getApiBaseUrl() {
    return process.env['GITHUB_API_URL'] || 'https://api.github.com';
}
exports.getApiBaseUrl = getApiBaseUrl;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 3030:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOctokitOptions = exports.GitHub = exports.context = void 0;
const Context = __importStar(__webpack_require__(4087));
const Utils = __importStar(__webpack_require__(7914));
// octokit + plugins
const core_1 = __webpack_require__(6762);
const plugin_rest_endpoint_methods_1 = __webpack_require__(3044);
const plugin_paginate_rest_1 = __webpack_require__(4193);
exports.context = new Context.Context();
const baseUrl = Utils.getApiBaseUrl();
const defaults = {
    baseUrl,
    request: {
        agent: Utils.getProxyAgent(baseUrl)
    }
};
exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(defaults);
/**
 * Convience function to correctly format Octokit Options to pass into the constructor.
 *
 * @param     token    the repo PAT or GITHUB_TOKEN
 * @param     options  other options to set
 */
function getOctokitOptions(token, options) {
    const opts = Object.assign({}, options || {}); // Shallow clone - don't mutate the object provided by the caller
    // Auth
    const auth = Utils.getAuthString(token, opts);
    if (auth) {
        opts.auth = auth;
    }
    return opts;
}
exports.getOctokitOptions = getOctokitOptions;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 8090:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const internal_globber_1 = __webpack_require__(8298);
/**
 * Constructs a globber
 *
 * @param patterns  Patterns separated by newlines
 * @param options   Glob options
 */
function create(patterns, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield internal_globber_1.DefaultGlobber.create(patterns, options);
    });
}
exports.create = create;
//# sourceMappingURL=glob.js.map

/***/ }),

/***/ 1026:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const core = __importStar(__webpack_require__(2186));
/**
 * Returns a copy with defaults filled in.
 */
function getOptions(copy) {
    const result = {
        followSymbolicLinks: true,
        implicitDescendants: true,
        omitBrokenSymbolicLinks: true
    };
    if (copy) {
        if (typeof copy.followSymbolicLinks === 'boolean') {
            result.followSymbolicLinks = copy.followSymbolicLinks;
            core.debug(`followSymbolicLinks '${result.followSymbolicLinks}'`);
        }
        if (typeof copy.implicitDescendants === 'boolean') {
            result.implicitDescendants = copy.implicitDescendants;
            core.debug(`implicitDescendants '${result.implicitDescendants}'`);
        }
        if (typeof copy.omitBrokenSymbolicLinks === 'boolean') {
            result.omitBrokenSymbolicLinks = copy.omitBrokenSymbolicLinks;
            core.debug(`omitBrokenSymbolicLinks '${result.omitBrokenSymbolicLinks}'`);
        }
    }
    return result;
}
exports.getOptions = getOptions;
//# sourceMappingURL=internal-glob-options-helper.js.map

/***/ }),

/***/ 8298:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const core = __importStar(__webpack_require__(2186));
const fs = __importStar(__webpack_require__(5747));
const globOptionsHelper = __importStar(__webpack_require__(1026));
const path = __importStar(__webpack_require__(5622));
const patternHelper = __importStar(__webpack_require__(9005));
const internal_match_kind_1 = __webpack_require__(1063);
const internal_pattern_1 = __webpack_require__(4536);
const internal_search_state_1 = __webpack_require__(9117);
const IS_WINDOWS = process.platform === 'win32';
class DefaultGlobber {
    constructor(options) {
        this.patterns = [];
        this.searchPaths = [];
        this.options = globOptionsHelper.getOptions(options);
    }
    getSearchPaths() {
        // Return a copy
        return this.searchPaths.slice();
    }
    glob() {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            try {
                for (var _b = __asyncValues(this.globGenerator()), _c; _c = yield _b.next(), !_c.done;) {
                    const itemPath = _c.value;
                    result.push(itemPath);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        });
    }
    globGenerator() {
        return __asyncGenerator(this, arguments, function* globGenerator_1() {
            // Fill in defaults options
            const options = globOptionsHelper.getOptions(this.options);
            // Implicit descendants?
            const patterns = [];
            for (const pattern of this.patterns) {
                patterns.push(pattern);
                if (options.implicitDescendants &&
                    (pattern.trailingSeparator ||
                        pattern.segments[pattern.segments.length - 1] !== '**')) {
                    patterns.push(new internal_pattern_1.Pattern(pattern.negate, pattern.segments.concat('**')));
                }
            }
            // Push the search paths
            const stack = [];
            for (const searchPath of patternHelper.getSearchPaths(patterns)) {
                core.debug(`Search path '${searchPath}'`);
                // Exists?
                try {
                    // Intentionally using lstat. Detection for broken symlink
                    // will be performed later (if following symlinks).
                    yield __await(fs.promises.lstat(searchPath));
                }
                catch (err) {
                    if (err.code === 'ENOENT') {
                        continue;
                    }
                    throw err;
                }
                stack.unshift(new internal_search_state_1.SearchState(searchPath, 1));
            }
            // Search
            const traversalChain = []; // used to detect cycles
            while (stack.length) {
                // Pop
                const item = stack.pop();
                // Match?
                const match = patternHelper.match(patterns, item.path);
                const partialMatch = !!match || patternHelper.partialMatch(patterns, item.path);
                if (!match && !partialMatch) {
                    continue;
                }
                // Stat
                const stats = yield __await(DefaultGlobber.stat(item, options, traversalChain)
                // Broken symlink, or symlink cycle detected, or no longer exists
                );
                // Broken symlink, or symlink cycle detected, or no longer exists
                if (!stats) {
                    continue;
                }
                // Directory
                if (stats.isDirectory()) {
                    // Matched
                    if (match & internal_match_kind_1.MatchKind.Directory) {
                        yield yield __await(item.path);
                    }
                    // Descend?
                    else if (!partialMatch) {
                        continue;
                    }
                    // Push the child items in reverse
                    const childLevel = item.level + 1;
                    const childItems = (yield __await(fs.promises.readdir(item.path))).map(x => new internal_search_state_1.SearchState(path.join(item.path, x), childLevel));
                    stack.push(...childItems.reverse());
                }
                // File
                else if (match & internal_match_kind_1.MatchKind.File) {
                    yield yield __await(item.path);
                }
            }
        });
    }
    /**
     * Constructs a DefaultGlobber
     */
    static create(patterns, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = new DefaultGlobber(options);
            if (IS_WINDOWS) {
                patterns = patterns.replace(/\r\n/g, '\n');
                patterns = patterns.replace(/\r/g, '\n');
            }
            const lines = patterns.split('\n').map(x => x.trim());
            for (const line of lines) {
                // Empty or comment
                if (!line || line.startsWith('#')) {
                    continue;
                }
                // Pattern
                else {
                    result.patterns.push(new internal_pattern_1.Pattern(line));
                }
            }
            result.searchPaths.push(...patternHelper.getSearchPaths(result.patterns));
            return result;
        });
    }
    static stat(item, options, traversalChain) {
        return __awaiter(this, void 0, void 0, function* () {
            // Note:
            // `stat` returns info about the target of a symlink (or symlink chain)
            // `lstat` returns info about a symlink itself
            let stats;
            if (options.followSymbolicLinks) {
                try {
                    // Use `stat` (following symlinks)
                    stats = yield fs.promises.stat(item.path);
                }
                catch (err) {
                    if (err.code === 'ENOENT') {
                        if (options.omitBrokenSymbolicLinks) {
                            core.debug(`Broken symlink '${item.path}'`);
                            return undefined;
                        }
                        throw new Error(`No information found for the path '${item.path}'. This may indicate a broken symbolic link.`);
                    }
                    throw err;
                }
            }
            else {
                // Use `lstat` (not following symlinks)
                stats = yield fs.promises.lstat(item.path);
            }
            // Note, isDirectory() returns false for the lstat of a symlink
            if (stats.isDirectory() && options.followSymbolicLinks) {
                // Get the realpath
                const realPath = yield fs.promises.realpath(item.path);
                // Fixup the traversal chain to match the item level
                while (traversalChain.length >= item.level) {
                    traversalChain.pop();
                }
                // Test for a cycle
                if (traversalChain.some((x) => x === realPath)) {
                    core.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
                    return undefined;
                }
                // Update the traversal chain
                traversalChain.push(realPath);
            }
            return stats;
        });
    }
}
exports.DefaultGlobber = DefaultGlobber;
//# sourceMappingURL=internal-globber.js.map

/***/ }),

/***/ 1063:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Indicates whether a pattern matches a path
 */
var MatchKind;
(function (MatchKind) {
    /** Not matched */
    MatchKind[MatchKind["None"] = 0] = "None";
    /** Matched if the path is a directory */
    MatchKind[MatchKind["Directory"] = 1] = "Directory";
    /** Matched if the path is a regular file */
    MatchKind[MatchKind["File"] = 2] = "File";
    /** Matched */
    MatchKind[MatchKind["All"] = 3] = "All";
})(MatchKind = exports.MatchKind || (exports.MatchKind = {}));
//# sourceMappingURL=internal-match-kind.js.map

/***/ }),

/***/ 1849:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __importStar(__webpack_require__(5622));
const assert_1 = __importDefault(__webpack_require__(2357));
const IS_WINDOWS = process.platform === 'win32';
/**
 * Similar to path.dirname except normalizes the path separators and slightly better handling for Windows UNC paths.
 *
 * For example, on Linux/macOS:
 * - `/               => /`
 * - `/hello          => /`
 *
 * For example, on Windows:
 * - `C:\             => C:\`
 * - `C:\hello        => C:\`
 * - `C:              => C:`
 * - `C:hello         => C:`
 * - `\               => \`
 * - `\hello          => \`
 * - `\\hello         => \\hello`
 * - `\\hello\world   => \\hello\world`
 */
function dirname(p) {
    // Normalize slashes and trim unnecessary trailing slash
    p = safeTrimTrailingSeparator(p);
    // Windows UNC root, e.g. \\hello or \\hello\world
    if (IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p)) {
        return p;
    }
    // Get dirname
    let result = path.dirname(p);
    // Trim trailing slash for Windows UNC root, e.g. \\hello\world\
    if (IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result)) {
        result = safeTrimTrailingSeparator(result);
    }
    return result;
}
exports.dirname = dirname;
/**
 * Roots the path if not already rooted. On Windows, relative roots like `\`
 * or `C:` are expanded based on the current working directory.
 */
function ensureAbsoluteRoot(root, itemPath) {
    assert_1.default(root, `ensureAbsoluteRoot parameter 'root' must not be empty`);
    assert_1.default(itemPath, `ensureAbsoluteRoot parameter 'itemPath' must not be empty`);
    // Already rooted
    if (hasAbsoluteRoot(itemPath)) {
        return itemPath;
    }
    // Windows
    if (IS_WINDOWS) {
        // Check for itemPath like C: or C:foo
        if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
            let cwd = process.cwd();
            assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
            // Drive letter matches cwd? Expand to cwd
            if (itemPath[0].toUpperCase() === cwd[0].toUpperCase()) {
                // Drive only, e.g. C:
                if (itemPath.length === 2) {
                    // Preserve specified drive letter case (upper or lower)
                    return `${itemPath[0]}:\\${cwd.substr(3)}`;
                }
                // Drive + path, e.g. C:foo
                else {
                    if (!cwd.endsWith('\\')) {
                        cwd += '\\';
                    }
                    // Preserve specified drive letter case (upper or lower)
                    return `${itemPath[0]}:\\${cwd.substr(3)}${itemPath.substr(2)}`;
                }
            }
            // Different drive
            else {
                return `${itemPath[0]}:\\${itemPath.substr(2)}`;
            }
        }
        // Check for itemPath like \ or \foo
        else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
            const cwd = process.cwd();
            assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
            return `${cwd[0]}:\\${itemPath.substr(1)}`;
        }
    }
    assert_1.default(hasAbsoluteRoot(root), `ensureAbsoluteRoot parameter 'root' must have an absolute root`);
    // Otherwise ensure root ends with a separator
    if (root.endsWith('/') || (IS_WINDOWS && root.endsWith('\\'))) {
        // Intentionally empty
    }
    else {
        // Append separator
        root += path.sep;
    }
    return root + itemPath;
}
exports.ensureAbsoluteRoot = ensureAbsoluteRoot;
/**
 * On Linux/macOS, true if path starts with `/`. On Windows, true for paths like:
 * `\\hello\share` and `C:\hello` (and using alternate separator).
 */
function hasAbsoluteRoot(itemPath) {
    assert_1.default(itemPath, `hasAbsoluteRoot parameter 'itemPath' must not be empty`);
    // Normalize separators
    itemPath = normalizeSeparators(itemPath);
    // Windows
    if (IS_WINDOWS) {
        // E.g. \\hello\share or C:\hello
        return itemPath.startsWith('\\\\') || /^[A-Z]:\\/i.test(itemPath);
    }
    // E.g. /hello
    return itemPath.startsWith('/');
}
exports.hasAbsoluteRoot = hasAbsoluteRoot;
/**
 * On Linux/macOS, true if path starts with `/`. On Windows, true for paths like:
 * `\`, `\hello`, `\\hello\share`, `C:`, and `C:\hello` (and using alternate separator).
 */
function hasRoot(itemPath) {
    assert_1.default(itemPath, `isRooted parameter 'itemPath' must not be empty`);
    // Normalize separators
    itemPath = normalizeSeparators(itemPath);
    // Windows
    if (IS_WINDOWS) {
        // E.g. \ or \hello or \\hello
        // E.g. C: or C:\hello
        return itemPath.startsWith('\\') || /^[A-Z]:/i.test(itemPath);
    }
    // E.g. /hello
    return itemPath.startsWith('/');
}
exports.hasRoot = hasRoot;
/**
 * Removes redundant slashes and converts `/` to `\` on Windows
 */
function normalizeSeparators(p) {
    p = p || '';
    // Windows
    if (IS_WINDOWS) {
        // Convert slashes on Windows
        p = p.replace(/\//g, '\\');
        // Remove redundant slashes
        const isUnc = /^\\\\+[^\\]/.test(p); // e.g. \\hello
        return (isUnc ? '\\' : '') + p.replace(/\\\\+/g, '\\'); // preserve leading \\ for UNC
    }
    // Remove redundant slashes
    return p.replace(/\/\/+/g, '/');
}
exports.normalizeSeparators = normalizeSeparators;
/**
 * Normalizes the path separators and trims the trailing separator (when safe).
 * For example, `/foo/ => /foo` but `/ => /`
 */
function safeTrimTrailingSeparator(p) {
    // Short-circuit if empty
    if (!p) {
        return '';
    }
    // Normalize separators
    p = normalizeSeparators(p);
    // No trailing slash
    if (!p.endsWith(path.sep)) {
        return p;
    }
    // Check '/' on Linux/macOS and '\' on Windows
    if (p === path.sep) {
        return p;
    }
    // On Windows check if drive root. E.g. C:\
    if (IS_WINDOWS && /^[A-Z]:\\$/i.test(p)) {
        return p;
    }
    // Otherwise trim trailing slash
    return p.substr(0, p.length - 1);
}
exports.safeTrimTrailingSeparator = safeTrimTrailingSeparator;
//# sourceMappingURL=internal-path-helper.js.map

/***/ }),

/***/ 6836:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __importStar(__webpack_require__(5622));
const pathHelper = __importStar(__webpack_require__(1849));
const assert_1 = __importDefault(__webpack_require__(2357));
const IS_WINDOWS = process.platform === 'win32';
/**
 * Helper class for parsing paths into segments
 */
class Path {
    /**
     * Constructs a Path
     * @param itemPath Path or array of segments
     */
    constructor(itemPath) {
        this.segments = [];
        // String
        if (typeof itemPath === 'string') {
            assert_1.default(itemPath, `Parameter 'itemPath' must not be empty`);
            // Normalize slashes and trim unnecessary trailing slash
            itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
            // Not rooted
            if (!pathHelper.hasRoot(itemPath)) {
                this.segments = itemPath.split(path.sep);
            }
            // Rooted
            else {
                // Add all segments, while not at the root
                let remaining = itemPath;
                let dir = pathHelper.dirname(remaining);
                while (dir !== remaining) {
                    // Add the segment
                    const basename = path.basename(remaining);
                    this.segments.unshift(basename);
                    // Truncate the last segment
                    remaining = dir;
                    dir = pathHelper.dirname(remaining);
                }
                // Remainder is the root
                this.segments.unshift(remaining);
            }
        }
        // Array
        else {
            // Must not be empty
            assert_1.default(itemPath.length > 0, `Parameter 'itemPath' must not be an empty array`);
            // Each segment
            for (let i = 0; i < itemPath.length; i++) {
                let segment = itemPath[i];
                // Must not be empty
                assert_1.default(segment, `Parameter 'itemPath' must not contain any empty segments`);
                // Normalize slashes
                segment = pathHelper.normalizeSeparators(itemPath[i]);
                // Root segment
                if (i === 0 && pathHelper.hasRoot(segment)) {
                    segment = pathHelper.safeTrimTrailingSeparator(segment);
                    assert_1.default(segment === pathHelper.dirname(segment), `Parameter 'itemPath' root segment contains information for multiple segments`);
                    this.segments.push(segment);
                }
                // All other segments
                else {
                    // Must not contain slash
                    assert_1.default(!segment.includes(path.sep), `Parameter 'itemPath' contains unexpected path separators`);
                    this.segments.push(segment);
                }
            }
        }
    }
    /**
     * Converts the path to it's string representation
     */
    toString() {
        // First segment
        let result = this.segments[0];
        // All others
        let skipSlash = result.endsWith(path.sep) || (IS_WINDOWS && /^[A-Z]:$/i.test(result));
        for (let i = 1; i < this.segments.length; i++) {
            if (skipSlash) {
                skipSlash = false;
            }
            else {
                result += path.sep;
            }
            result += this.segments[i];
        }
        return result;
    }
}
exports.Path = Path;
//# sourceMappingURL=internal-path.js.map

/***/ }),

/***/ 9005:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pathHelper = __importStar(__webpack_require__(1849));
const internal_match_kind_1 = __webpack_require__(1063);
const IS_WINDOWS = process.platform === 'win32';
/**
 * Given an array of patterns, returns an array of paths to search.
 * Duplicates and paths under other included paths are filtered out.
 */
function getSearchPaths(patterns) {
    // Ignore negate patterns
    patterns = patterns.filter(x => !x.negate);
    // Create a map of all search paths
    const searchPathMap = {};
    for (const pattern of patterns) {
        const key = IS_WINDOWS
            ? pattern.searchPath.toUpperCase()
            : pattern.searchPath;
        searchPathMap[key] = 'candidate';
    }
    const result = [];
    for (const pattern of patterns) {
        // Check if already included
        const key = IS_WINDOWS
            ? pattern.searchPath.toUpperCase()
            : pattern.searchPath;
        if (searchPathMap[key] === 'included') {
            continue;
        }
        // Check for an ancestor search path
        let foundAncestor = false;
        let tempKey = key;
        let parent = pathHelper.dirname(tempKey);
        while (parent !== tempKey) {
            if (searchPathMap[parent]) {
                foundAncestor = true;
                break;
            }
            tempKey = parent;
            parent = pathHelper.dirname(tempKey);
        }
        // Include the search pattern in the result
        if (!foundAncestor) {
            result.push(pattern.searchPath);
            searchPathMap[key] = 'included';
        }
    }
    return result;
}
exports.getSearchPaths = getSearchPaths;
/**
 * Matches the patterns against the path
 */
function match(patterns, itemPath) {
    let result = internal_match_kind_1.MatchKind.None;
    for (const pattern of patterns) {
        if (pattern.negate) {
            result &= ~pattern.match(itemPath);
        }
        else {
            result |= pattern.match(itemPath);
        }
    }
    return result;
}
exports.match = match;
/**
 * Checks whether to descend further into the directory
 */
function partialMatch(patterns, itemPath) {
    return patterns.some(x => !x.negate && x.partialMatch(itemPath));
}
exports.partialMatch = partialMatch;
//# sourceMappingURL=internal-pattern-helper.js.map

/***/ }),

/***/ 4536:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const os = __importStar(__webpack_require__(2087));
const path = __importStar(__webpack_require__(5622));
const pathHelper = __importStar(__webpack_require__(1849));
const assert_1 = __importDefault(__webpack_require__(2357));
const minimatch_1 = __webpack_require__(3973);
const internal_match_kind_1 = __webpack_require__(1063);
const internal_path_1 = __webpack_require__(6836);
const IS_WINDOWS = process.platform === 'win32';
class Pattern {
    constructor(patternOrNegate, segments, homedir) {
        /**
         * Indicates whether matches should be excluded from the result set
         */
        this.negate = false;
        // Pattern overload
        let pattern;
        if (typeof patternOrNegate === 'string') {
            pattern = patternOrNegate.trim();
        }
        // Segments overload
        else {
            // Convert to pattern
            segments = segments || [];
            assert_1.default(segments.length, `Parameter 'segments' must not empty`);
            const root = Pattern.getLiteral(segments[0]);
            assert_1.default(root && pathHelper.hasAbsoluteRoot(root), `Parameter 'segments' first element must be a root path`);
            pattern = new internal_path_1.Path(segments).toString().trim();
            if (patternOrNegate) {
                pattern = `!${pattern}`;
            }
        }
        // Negate
        while (pattern.startsWith('!')) {
            this.negate = !this.negate;
            pattern = pattern.substr(1).trim();
        }
        // Normalize slashes and ensures absolute root
        pattern = Pattern.fixupPattern(pattern, homedir);
        // Segments
        this.segments = new internal_path_1.Path(pattern).segments;
        // Trailing slash indicates the pattern should only match directories, not regular files
        this.trailingSeparator = pathHelper
            .normalizeSeparators(pattern)
            .endsWith(path.sep);
        pattern = pathHelper.safeTrimTrailingSeparator(pattern);
        // Search path (literal path prior to the first glob segment)
        let foundGlob = false;
        const searchSegments = this.segments
            .map(x => Pattern.getLiteral(x))
            .filter(x => !foundGlob && !(foundGlob = x === ''));
        this.searchPath = new internal_path_1.Path(searchSegments).toString();
        // Root RegExp (required when determining partial match)
        this.rootRegExp = new RegExp(Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS ? 'i' : '');
        // Create minimatch
        const minimatchOptions = {
            dot: true,
            nobrace: true,
            nocase: IS_WINDOWS,
            nocomment: true,
            noext: true,
            nonegate: true
        };
        pattern = IS_WINDOWS ? pattern.replace(/\\/g, '/') : pattern;
        this.minimatch = new minimatch_1.Minimatch(pattern, minimatchOptions);
    }
    /**
     * Matches the pattern against the specified path
     */
    match(itemPath) {
        // Last segment is globstar?
        if (this.segments[this.segments.length - 1] === '**') {
            // Normalize slashes
            itemPath = pathHelper.normalizeSeparators(itemPath);
            // Append a trailing slash. Otherwise Minimatch will not match the directory immediately
            // preceding the globstar. For example, given the pattern `/foo/**`, Minimatch returns
            // false for `/foo` but returns true for `/foo/`. Append a trailing slash to handle that quirk.
            if (!itemPath.endsWith(path.sep)) {
                // Note, this is safe because the constructor ensures the pattern has an absolute root.
                // For example, formats like C: and C:foo on Windows are resolved to an absolute root.
                itemPath = `${itemPath}${path.sep}`;
            }
        }
        else {
            // Normalize slashes and trim unnecessary trailing slash
            itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        }
        // Match
        if (this.minimatch.match(itemPath)) {
            return this.trailingSeparator ? internal_match_kind_1.MatchKind.Directory : internal_match_kind_1.MatchKind.All;
        }
        return internal_match_kind_1.MatchKind.None;
    }
    /**
     * Indicates whether the pattern may match descendants of the specified path
     */
    partialMatch(itemPath) {
        // Normalize slashes and trim unnecessary trailing slash
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        // matchOne does not handle root path correctly
        if (pathHelper.dirname(itemPath) === itemPath) {
            return this.rootRegExp.test(itemPath);
        }
        return this.minimatch.matchOne(itemPath.split(IS_WINDOWS ? /\\+/ : /\/+/), this.minimatch.set[0], true);
    }
    /**
     * Escapes glob patterns within a path
     */
    static globEscape(s) {
        return (IS_WINDOWS ? s : s.replace(/\\/g, '\\\\')) // escape '\' on Linux/macOS
            .replace(/(\[)(?=[^/]+\])/g, '[[]') // escape '[' when ']' follows within the path segment
            .replace(/\?/g, '[?]') // escape '?'
            .replace(/\*/g, '[*]'); // escape '*'
    }
    /**
     * Normalizes slashes and ensures absolute root
     */
    static fixupPattern(pattern, homedir) {
        // Empty
        assert_1.default(pattern, 'pattern cannot be empty');
        // Must not contain `.` segment, unless first segment
        // Must not contain `..` segment
        const literalSegments = new internal_path_1.Path(pattern).segments.map(x => Pattern.getLiteral(x));
        assert_1.default(literalSegments.every((x, i) => (x !== '.' || i === 0) && x !== '..'), `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`);
        // Must not contain globs in root, e.g. Windows UNC path \\foo\b*r
        assert_1.default(!pathHelper.hasRoot(pattern) || literalSegments[0], `Invalid pattern '${pattern}'. Root segment must not contain globs.`);
        // Normalize slashes
        pattern = pathHelper.normalizeSeparators(pattern);
        // Replace leading `.` segment
        if (pattern === '.' || pattern.startsWith(`.${path.sep}`)) {
            pattern = Pattern.globEscape(process.cwd()) + pattern.substr(1);
        }
        // Replace leading `~` segment
        else if (pattern === '~' || pattern.startsWith(`~${path.sep}`)) {
            homedir = homedir || os.homedir();
            assert_1.default(homedir, 'Unable to determine HOME directory');
            assert_1.default(pathHelper.hasAbsoluteRoot(homedir), `Expected HOME directory to be a rooted path. Actual '${homedir}'`);
            pattern = Pattern.globEscape(homedir) + pattern.substr(1);
        }
        // Replace relative drive root, e.g. pattern is C: or C:foo
        else if (IS_WINDOWS &&
            (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
            let root = pathHelper.ensureAbsoluteRoot('C:\\dummy-root', pattern.substr(0, 2));
            if (pattern.length > 2 && !root.endsWith('\\')) {
                root += '\\';
            }
            pattern = Pattern.globEscape(root) + pattern.substr(2);
        }
        // Replace relative root, e.g. pattern is \ or \foo
        else if (IS_WINDOWS && (pattern === '\\' || pattern.match(/^\\[^\\]/))) {
            let root = pathHelper.ensureAbsoluteRoot('C:\\dummy-root', '\\');
            if (!root.endsWith('\\')) {
                root += '\\';
            }
            pattern = Pattern.globEscape(root) + pattern.substr(1);
        }
        // Otherwise ensure absolute root
        else {
            pattern = pathHelper.ensureAbsoluteRoot(Pattern.globEscape(process.cwd()), pattern);
        }
        return pathHelper.normalizeSeparators(pattern);
    }
    /**
     * Attempts to unescape a pattern segment to create a literal path segment.
     * Otherwise returns empty string.
     */
    static getLiteral(segment) {
        let literal = '';
        for (let i = 0; i < segment.length; i++) {
            const c = segment[i];
            // Escape
            if (c === '\\' && !IS_WINDOWS && i + 1 < segment.length) {
                literal += segment[++i];
                continue;
            }
            // Wildcard
            else if (c === '*' || c === '?') {
                return '';
            }
            // Character set
            else if (c === '[' && i + 1 < segment.length) {
                let set = '';
                let closed = -1;
                for (let i2 = i + 1; i2 < segment.length; i2++) {
                    const c2 = segment[i2];
                    // Escape
                    if (c2 === '\\' && !IS_WINDOWS && i2 + 1 < segment.length) {
                        set += segment[++i2];
                        continue;
                    }
                    // Closed
                    else if (c2 === ']') {
                        closed = i2;
                        break;
                    }
                    // Otherwise
                    else {
                        set += c2;
                    }
                }
                // Closed?
                if (closed >= 0) {
                    // Cannot convert
                    if (set.length > 1) {
                        return '';
                    }
                    // Convert to literal
                    if (set) {
                        literal += set;
                        i = closed;
                        continue;
                    }
                }
                // Otherwise fall thru
            }
            // Append
            literal += c;
        }
        return literal;
    }
    /**
     * Escapes regexp special characters
     * https://javascript.info/regexp-escaping
     */
    static regExpEscape(s) {
        return s.replace(/[[\\^$.|?*+()]/g, '\\$&');
    }
}
exports.Pattern = Pattern;
//# sourceMappingURL=internal-pattern.js.map

/***/ }),

/***/ 9117:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class SearchState {
    constructor(path, level) {
        this.path = path;
        this.level = level;
    }
}
exports.SearchState = SearchState;
//# sourceMappingURL=internal-search-state.js.map

/***/ }),

/***/ 9925:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const http = __webpack_require__(8605);
const https = __webpack_require__(7211);
const pm = __webpack_require__(6443);
let tunnel;
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return new Promise(async (resolve, reject) => {
            let output = Buffer.alloc(0);
            this.message.on('data', (chunk) => {
                output = Buffer.concat([output, chunk]);
            });
            this.message.on('end', () => {
                resolve(output.toString());
            });
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    let parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
    }
    get(requestUrl, additionalHeaders) {
        return this.request('GET', requestUrl, null, additionalHeaders || {});
    }
    del(requestUrl, additionalHeaders) {
        return this.request('DELETE', requestUrl, null, additionalHeaders || {});
    }
    post(requestUrl, data, additionalHeaders) {
        return this.request('POST', requestUrl, data, additionalHeaders || {});
    }
    patch(requestUrl, data, additionalHeaders) {
        return this.request('PATCH', requestUrl, data, additionalHeaders || {});
    }
    put(requestUrl, data, additionalHeaders) {
        return this.request('PUT', requestUrl, data, additionalHeaders || {});
    }
    head(requestUrl, additionalHeaders) {
        return this.request('HEAD', requestUrl, null, additionalHeaders || {});
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return this.request(verb, requestUrl, stream, additionalHeaders);
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    async getJson(requestUrl, additionalHeaders = {}) {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        let res = await this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    async postJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = await this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    async putJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = await this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    async patchJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = await this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    async request(verb, requestUrl, data, headers) {
        if (this._disposed) {
            throw new Error('Client has already been disposed.');
        }
        let parsedUrl = new URL(requestUrl);
        let info = this._prepareRequest(verb, parsedUrl, headers);
        // Only perform retries on reads since writes may not be idempotent.
        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1
            ? this._maxRetries + 1
            : 1;
        let numTries = 0;
        let response;
        while (numTries < maxTries) {
            response = await this.requestRaw(info, data);
            // Check if it's an authentication challenge
            if (response &&
                response.message &&
                response.message.statusCode === HttpCodes.Unauthorized) {
                let authenticationHandler;
                for (let i = 0; i < this.handlers.length; i++) {
                    if (this.handlers[i].canHandleAuthentication(response)) {
                        authenticationHandler = this.handlers[i];
                        break;
                    }
                }
                if (authenticationHandler) {
                    return authenticationHandler.handleAuthentication(this, info, data);
                }
                else {
                    // We have received an unauthorized response but have no handlers to handle it.
                    // Let the response return to the caller.
                    return response;
                }
            }
            let redirectsRemaining = this._maxRedirects;
            while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 &&
                this._allowRedirects &&
                redirectsRemaining > 0) {
                const redirectUrl = response.message.headers['location'];
                if (!redirectUrl) {
                    // if there's no location to redirect to, we won't
                    break;
                }
                let parsedRedirectUrl = new URL(redirectUrl);
                if (parsedUrl.protocol == 'https:' &&
                    parsedUrl.protocol != parsedRedirectUrl.protocol &&
                    !this._allowRedirectDowngrade) {
                    throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                }
                // we need to finish reading the response before reassigning response
                // which will leak the open socket.
                await response.readBody();
                // strip authorization header if redirected to a different hostname
                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                    for (let header in headers) {
                        // header names are case insensitive
                        if (header.toLowerCase() === 'authorization') {
                            delete headers[header];
                        }
                    }
                }
                // let's make the request with the new redirectUrl
                info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                response = await this.requestRaw(info, data);
                redirectsRemaining--;
            }
            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {
                // If not a retry code, return immediately instead of retrying
                return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
                await response.readBody();
                await this._performExponentialBackoff(numTries);
            }
        }
        return response;
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return new Promise((resolve, reject) => {
            let callbackForResult = function (err, res) {
                if (err) {
                    reject(err);
                }
                resolve(res);
            };
            this.requestRawWithCallback(info, data, callbackForResult);
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        let socket;
        if (typeof data === 'string') {
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        let handleResult = (err, res) => {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        };
        let req = info.httpModule.request(info.options, (msg) => {
            let res = new HttpClientResponse(msg);
            handleResult(null, res);
        });
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error('Request timeout: ' + info.options.path), null);
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err, null);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        let parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            this.handlers.forEach(handler => {
                handler.prepareRequest(info.options);
            });
        }
        return info;
    }
    _mergeHeaders(headers) {
        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        let proxyUrl = pm.getProxyUrl(parsedUrl);
        let useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (!!agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (!!this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (useProxy) {
            // If using proxy, need tunnel
            if (!tunnel) {
                tunnel = __webpack_require__(4294);
            }
            const agentOptions = {
                maxSockets: maxSockets,
                keepAlive: this._keepAlive,
                proxy: {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`,
                    host: proxyUrl.hostname,
                    port: proxyUrl.port
                }
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets: maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise(resolve => setTimeout(() => resolve(), ms));
    }
    static dateTimeDeserializer(key, value) {
        if (typeof value === 'string') {
            let a = new Date(value);
            if (!isNaN(a.valueOf())) {
                return a;
            }
        }
        return value;
    }
    async _processResponse(res, options) {
        return new Promise(async (resolve, reject) => {
            const statusCode = res.message.statusCode;
            const response = {
                statusCode: statusCode,
                result: null,
                headers: {}
            };
            // not found leads to null obj returned
            if (statusCode == HttpCodes.NotFound) {
                resolve(response);
            }
            let obj;
            let contents;
            // get the result from the body
            try {
                contents = await res.readBody();
                if (contents && contents.length > 0) {
                    if (options && options.deserializeDates) {
                        obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);
                    }
                    else {
                        obj = JSON.parse(contents);
                    }
                    response.result = obj;
                }
                response.headers = res.message.headers;
            }
            catch (err) {
                // Invalid resource (contents not json);  leaving result obj null
            }
            // note that 3xx redirects are handled by the http layer.
            if (statusCode > 299) {
                let msg;
                // if exception/error in body, attempt to get better error
                if (obj && obj.message) {
                    msg = obj.message;
                }
                else if (contents && contents.length > 0) {
                    // it may be the case that the exception is in the body message as string
                    msg = contents;
                }
                else {
                    msg = 'Failed request: (' + statusCode + ')';
                }
                let err = new HttpClientError(msg, statusCode);
                err.result = response.result;
                reject(err);
            }
            else {
                resolve(response);
            }
        });
    }
}
exports.HttpClient = HttpClient;


/***/ }),

/***/ 6443:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function getProxyUrl(reqUrl) {
    let usingSsl = reqUrl.protocol === 'https:';
    let proxyUrl;
    if (checkBypass(reqUrl)) {
        return proxyUrl;
    }
    let proxyVar;
    if (usingSsl) {
        proxyVar = process.env['https_proxy'] || process.env['HTTPS_PROXY'];
    }
    else {
        proxyVar = process.env['http_proxy'] || process.env['HTTP_PROXY'];
    }
    if (proxyVar) {
        proxyUrl = new URL(proxyVar);
    }
    return proxyUrl;
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    let noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    let upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (let upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperReqHosts.some(x => x === upperNoProxyItem)) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;


/***/ }),

/***/ 334:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

async function auth(token) {
  const tokenType = token.split(/\./).length === 3 ? "app" : /^v\d+\./.test(token) ? "installation" : "oauth";
  return {
    type: "token",
    token: token,
    tokenType
  };
}

/**
 * Prefix token for usage in the Authorization header
 *
 * @param token OAuth token or JSON Web Token
 */
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }

  return `token ${token}`;
}

async function hook(token, request, route, parameters) {
  const endpoint = request.endpoint.merge(route, parameters);
  endpoint.headers.authorization = withAuthorizationPrefix(token);
  return request(endpoint);
}

const createTokenAuth = function createTokenAuth(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }

  if (typeof token !== "string") {
    throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
  }

  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

exports.createTokenAuth = createTokenAuth;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 6762:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var universalUserAgent = __webpack_require__(5030);
var beforeAfterHook = __webpack_require__(3682);
var request = __webpack_require__(6234);
var graphql = __webpack_require__(8467);
var authToken = __webpack_require__(334);

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

const VERSION = "3.2.5";

class Octokit {
  constructor(options = {}) {
    const hook = new beforeAfterHook.Collection();
    const requestDefaults = {
      baseUrl: request.request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        hook: hook.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    }; // prepend default user agent with `options.userAgent` if set

    requestDefaults.headers["user-agent"] = [options.userAgent, `octokit-core.js/${VERSION} ${universalUserAgent.getUserAgent()}`].filter(Boolean).join(" ");

    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }

    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }

    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }

    this.request = request.request.defaults(requestDefaults);
    this.graphql = graphql.withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign({
      debug: () => {},
      info: () => {},
      warn: console.warn.bind(console),
      error: console.error.bind(console)
    }, options.log);
    this.hook = hook; // (1) If neither `options.authStrategy` nor `options.auth` are set, the `octokit` instance
    //     is unauthenticated. The `this.auth()` method is a no-op and no request hook is registered.
    // (2) If only `options.auth` is set, use the default token authentication strategy.
    // (3) If `options.authStrategy` is set then use it and pass in `options.auth`. Always pass own request as many strategies accept a custom request instance.
    // TODO: type `options.auth` based on `options.authStrategy`.

    if (!options.authStrategy) {
      if (!options.auth) {
        // (1)
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        // (2)
        const auth = authToken.createTokenAuth(options.auth); // @ts-ignore  ¯\_(ツ)_/¯

        hook.wrap("request", auth.hook);
        this.auth = auth;
      }
    } else {
      const {
        authStrategy
      } = options,
            otherOptions = _objectWithoutProperties(options, ["authStrategy"]);

      const auth = authStrategy(Object.assign({
        request: this.request,
        log: this.log,
        // we pass the current octokit instance as well as its constructor options
        // to allow for authentication strategies that return a new octokit instance
        // that shares the same internal state as the current one. The original
        // requirement for this was the "event-octokit" authentication strategy
        // of https://github.com/probot/octokit-auth-probot.
        octokit: this,
        octokitOptions: otherOptions
      }, options.auth)); // @ts-ignore  ¯\_(ツ)_/¯

      hook.wrap("request", auth.hook);
      this.auth = auth;
    } // apply plugins
    // https://stackoverflow.com/a/16345172


    const classConstructor = this.constructor;
    classConstructor.plugins.forEach(plugin => {
      Object.assign(this, plugin(this, options));
    });
  }

  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};

        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }

        super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
          userAgent: `${options.userAgent} ${defaults.userAgent}`
        } : null));
      }

    };
    return OctokitWithDefaults;
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */


  static plugin(...newPlugins) {
    var _a;

    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {}, _a.plugins = currentPlugins.concat(newPlugins.filter(plugin => !currentPlugins.includes(plugin))), _a);
    return NewOctokit;
  }

}
Octokit.VERSION = VERSION;
Octokit.plugins = [];

exports.Octokit = Octokit;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 9440:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var isPlainObject = __webpack_require__(558);
var universalUserAgent = __webpack_require__(5030);

function lowercaseKeys(object) {
  if (!object) {
    return {};
  }

  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}

function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach(key => {
    if (isPlainObject.isPlainObject(options[key])) {
      if (!(key in defaults)) Object.assign(result, {
        [key]: options[key]
      });else result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, {
        [key]: options[key]
      });
    }
  });
  return result;
}

function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === undefined) {
      delete obj[key];
    }
  }

  return obj;
}

function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? {
      method,
      url
    } : {
      url: method
    }, options);
  } else {
    options = Object.assign({}, route);
  } // lowercase header names before merging with defaults to avoid duplicates


  options.headers = lowercaseKeys(options.headers); // remove properties with undefined values before merging

  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options); // mediaType.previews arrays are merged, instead of overwritten

  if (defaults && defaults.mediaType.previews.length) {
    mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(preview => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
  }

  mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map(preview => preview.replace(/-preview/, ""));
  return mergedOptions;
}

function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);

  if (names.length === 0) {
    return url;
  }

  return url + separator + names.map(name => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }

    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}

const urlVariableRegex = /\{[^}]+\}/g;

function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}

function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);

  if (!matches) {
    return [];
  }

  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}

function omit(object, keysToOmit) {
  return Object.keys(object).filter(option => !keysToOmit.includes(option)).reduce((obj, key) => {
    obj[key] = object[key];
    return obj;
  }, {});
}

// Based on https://github.com/bramstein/url-template, licensed under BSD
// TODO: create separate package.
//
// Copyright (c) 2012-2014, Bram Stein
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
// EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* istanbul ignore file */
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }

    return part;
  }).join("");
}

function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);

  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}

function isDefined(value) {
  return value !== undefined && value !== null;
}

function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}

function getValues(context, operator, key, modifier) {
  var value = context[key],
      result = [];

  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();

      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }

      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function (value) {
            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function (k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];

        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function (value) {
            tmp.push(encodeValue(operator, value));
          });
        } else {
          Object.keys(value).forEach(function (k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }

        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }

  return result;
}

function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}

function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];

      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }

      expression.split(/,/g).forEach(function (variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
      });

      if (operator && operator !== "+") {
        var separator = ",";

        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }

        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved(literal);
    }
  });
}

function parse(options) {
  // https://fetch.spec.whatwg.org/#methods
  let method = options.method.toUpperCase(); // replace :varname with {varname} to make it RFC 6570 compatible

  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, ["method", "baseUrl", "url", "headers", "request", "mediaType"]); // extract variable names from URL to calculate remaining variables later

  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);

  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }

  const omittedParameters = Object.keys(options).filter(option => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);

  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      // e.g. application/vnd.github.v3+json => application/vnd.github.v3.raw
      headers.accept = headers.accept.split(/,/).map(preview => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }

    if (options.mediaType.previews.length) {
      const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
      headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map(preview => {
        const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
        return `application/vnd.github.${preview}-preview${format}`;
      }).join(",");
    }
  } // for GET/HEAD requests, set URL query parameters from remaining parameters
  // for PATCH/POST/PUT/DELETE requests, set request body from remaining parameters


  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      } else {
        headers["content-length"] = 0;
      }
    }
  } // default content-type for JSON if body is set


  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  } // GitHub expects 'content-length: 0' header for PUT/PATCH requests without body.
  // fetch does not allow to set `content-length` header, but we can set body to an empty string


  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  } // Only return body/request keys if present


  return Object.assign({
    method,
    url,
    headers
  }, typeof body !== "undefined" ? {
    body
  } : null, options.request ? {
    request: options.request
  } : null);
}

function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}

function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS = merge(oldDefaults, newDefaults);
  const endpoint = endpointWithDefaults.bind(null, DEFAULTS);
  return Object.assign(endpoint, {
    DEFAULTS,
    defaults: withDefaults.bind(null, DEFAULTS),
    merge: merge.bind(null, DEFAULTS),
    parse
  });
}

const VERSION = "6.0.11";

const userAgent = `octokit-endpoint.js/${VERSION} ${universalUserAgent.getUserAgent()}`; // DEFAULTS has all properties set that EndpointOptions has, except url.
// So we use RequestParameters and add method as additional required property.

const DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: "",
    previews: []
  }
};

const endpoint = withDefaults(null, DEFAULTS);

exports.endpoint = endpoint;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 558:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (ctor === undefined) return true;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
}

exports.isPlainObject = isPlainObject;


/***/ }),

/***/ 8467:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var request = __webpack_require__(6234);
var universalUserAgent = __webpack_require__(5030);

const VERSION = "4.6.0";

class GraphqlError extends Error {
  constructor(request, response) {
    const message = response.data.errors[0].message;
    super(message);
    Object.assign(this, response.data);
    Object.assign(this, {
      headers: response.headers
    });
    this.name = "GraphqlError";
    this.request = request; // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }

}

const NON_VARIABLE_OPTIONS = ["method", "baseUrl", "url", "headers", "request", "query", "mediaType"];
const GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request, query, options) {
  if (typeof query === "string" && options && "query" in options) {
    return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
  }

  const parsedOptions = typeof query === "string" ? Object.assign({
    query
  }, options) : query;
  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }

    if (!result.variables) {
      result.variables = {};
    }

    result.variables[key] = parsedOptions[key];
    return result;
  }, {}); // workaround for GitHub Enterprise baseUrl set with /api/v3 suffix
  // https://github.com/octokit/auth-app.js/issues/111#issuecomment-657610451

  const baseUrl = parsedOptions.baseUrl || request.endpoint.DEFAULTS.baseUrl;

  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }

  return request(requestOptions).then(response => {
    if (response.data.errors) {
      const headers = {};

      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }

      throw new GraphqlError(requestOptions, {
        headers,
        data: response.data
      });
    }

    return response.data.data;
  });
}

function withDefaults(request$1, newDefaults) {
  const newRequest = request$1.defaults(newDefaults);

  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };

  return Object.assign(newApi, {
    defaults: withDefaults.bind(null, newRequest),
    endpoint: request.request.endpoint
  });
}

const graphql$1 = withDefaults(request.request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION} ${universalUserAgent.getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

exports.graphql = graphql$1;
exports.withCustomRequest = withCustomRequest;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 4193:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const VERSION = "2.11.0";

/**
 * Some “list” response that can be paginated have a different response structure
 *
 * They have a `total_count` key in the response (search also has `incomplete_results`,
 * /installation/repositories also has `repository_selection`), as well as a key with
 * the list of the items which name varies from endpoint to endpoint.
 *
 * Octokit normalizes these responses so that paginated results are always returned following
 * the same structure. One challenge is that if the list response has only one page, no Link
 * header is provided, so this header alone is not sufficient to check wether a response is
 * paginated or not.
 *
 * We check if a "total_count" key is present in the response data, but also make sure that
 * a "url" property is not, as the "Get the combined status for a specific ref" endpoint would
 * otherwise match: https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
 */
function normalizePaginatedListResponse(response) {
  const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
  if (!responseNeedsNormalization) return response; // keep the additional properties intact as there is currently no other way
  // to retrieve the same information.

  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;

  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }

  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }

  response.data.total_count = totalCount;
  return response;
}

function iterator(octokit, route, parameters) {
  const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url) return {
          done: true
        };
        const response = await requestMethod({
          method,
          url,
          headers
        });
        const normalizedResponse = normalizePaginatedListResponse(response); // `response.headers.link` format:
        // '<https://api.github.com/users/aseemk/followers?page=2>; rel="next", <https://api.github.com/users/aseemk/followers?page=2>; rel="last"'
        // sets `url` to undefined if "next" URL is not present or `link` header is not set

        url = ((normalizedResponse.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
        return {
          value: normalizedResponse
        };
      }

    })
  };
}

function paginate(octokit, route, parameters, mapFn) {
  if (typeof parameters === "function") {
    mapFn = parameters;
    parameters = undefined;
  }

  return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
}

function gather(octokit, results, iterator, mapFn) {
  return iterator.next().then(result => {
    if (result.done) {
      return results;
    }

    let earlyExit = false;

    function done() {
      earlyExit = true;
    }

    results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);

    if (earlyExit) {
      return results;
    }

    return gather(octokit, results, iterator, mapFn);
  });
}

const composePaginateRest = Object.assign(paginate, {
  iterator
});

/**
 * @param octokit Octokit instance
 * @param options Options passed to Octokit constructor
 */

function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
paginateRest.VERSION = VERSION;

exports.composePaginateRest = composePaginateRest;
exports.paginateRest = paginateRest;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 3044:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const Endpoints = {
  actions: {
    addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
    cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
    createOrUpdateEnvironmentSecret: ["PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
    createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
    createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
    deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    deleteEnvironmentSecret: ["DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
    deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
    disableSelectedRepositoryGithubActionsOrganization: ["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],
    disableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],
    downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
    downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
    downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
    enableSelectedRepositoryGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],
    enableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],
    getAllowedActionsOrganization: ["GET /orgs/{org}/actions/permissions/selected-actions"],
    getAllowedActionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getEnvironmentPublicKey: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"],
    getEnvironmentSecret: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
    getGithubActionsPermissionsOrganization: ["GET /orgs/{org}/actions/permissions"],
    getGithubActionsPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions"],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getPendingDeploymentsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
    getRepoPermissions: ["GET /repos/{owner}/{repo}/actions/permissions", {}, {
      renamed: ["actions", "getGithubActionsPermissionsRepository"]
    }],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getReviewsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
    getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets"],
    listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
    listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
    listSelectedRepositoriesEnabledGithubActionsOrganization: ["GET /orgs/{org}/actions/permissions/repositories"],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
    listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
    reviewPendingDeploymentsForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
    setAllowedActionsOrganization: ["PUT /orgs/{org}/actions/permissions/selected-actions"],
    setAllowedActionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],
    setGithubActionsPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions"],
    setGithubActionsPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions"],
    setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],
    setSelectedRepositoriesEnabledGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories"]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
    checkToken: ["POST /applications/{client_id}/token"],
    createContentAttachment: ["POST /content_references/{content_reference_id}/attachments", {
      mediaType: {
        previews: ["corsair"]
      }
    }],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
    getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
    listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
    removeRepoFromInstallation: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
    getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
    getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],
    setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences"],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    deleteAnalysis: ["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],
    getAlert: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}", {}, {
      renamedParameters: {
        alert_id: "alert_number"
      }
    }],
    getAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct", {
      mediaType: {
        previews: ["scarlet-witch"]
      }
    }],
    getConductCode: ["GET /codes_of_conduct/{key}", {
      mediaType: {
        previews: ["scarlet-witch"]
      }
    }],
    getForRepo: ["GET /repos/{owner}/{repo}/community/code_of_conduct", {
      mediaType: {
        previews: ["scarlet-witch"]
      }
    }]
  },
  emojis: {
    get: ["GET /emojis"]
  },
  enterpriseAdmin: {
    disableSelectedOrganizationGithubActionsEnterprise: ["DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}"],
    enableSelectedOrganizationGithubActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}"],
    getAllowedActionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/selected-actions"],
    getGithubActionsPermissionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions"],
    listSelectedOrganizationsEnabledGithubActionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/organizations"],
    setAllowedActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/selected-actions"],
    setGithubActionsPermissionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions"],
    setSelectedOrganizationsEnabledGithubActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/organizations"]
  },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: ["GET /user/interaction-limits", {}, {
      renamed: ["interactions", "getRestrictionsForAuthenticatedUser"]
    }],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits"],
    removeRestrictionsForYourPublicRepos: ["DELETE /user/interaction-limits", {}, {
      renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"]
    }],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: ["PUT /user/interaction-limits", {}, {
      renamed: ["interactions", "setRestrictionsForAuthenticatedUser"]
    }]
  },
  issues: {
    addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline", {
      mediaType: {
        previews: ["mockingbird"]
      }
    }],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
    removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: ["POST /markdown/raw", {
      headers: {
        "content-type": "text/plain; charset=utf-8"
      }
    }]
  },
  meta: {
    get: ["GET /meta"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
    deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    getCommitAuthors: ["GET /repos/{owner}/{repo}/import/authors"],
    getImportStatus: ["GET /repos/{owner}/{repo}/import"],
    getLargeFiles: ["GET /repos/{owner}/{repo}/import/large_files"],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    listForAuthenticatedUser: ["GET /user/migrations", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    listForOrg: ["GET /orgs/{org}/migrations", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    listReposForUser: ["GET /user/migrations/{migration_id}/repositories", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    mapCommitAuthor: ["PATCH /repos/{owner}/{repo}/import/authors/{author_id}"],
    setLfsPreference: ["PATCH /repos/{owner}/{repo}/import/lfs"],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    startImport: ["PUT /repos/{owner}/{repo}/import"],
    unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    updateImport: ["PATCH /repos/{owner}/{repo}/import"]
  },
  orgs: {
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createWebhook: ["POST /orgs/{org}/hooks"],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    get: ["GET /orgs/{org}"],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
    removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}"],
    deletePackageForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],
    deletePackageVersionForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    deletePackageVersionForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    getAllPackageVersionsForAPackageOwnedByAnOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions"],
    getAllPackageVersionsForPackageOwnedByUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions"],
    getPackageForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}"],
    getPackageForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}"],
    getPackageForUser: ["GET /users/{username}/packages/{package_type}/{package_name}"],
    getPackageVersionForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    getPackageVersionForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    getPackageVersionForUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    restorePackageForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/restore"],
    restorePackageForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/restore"],
    restorePackageVersionForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
    restorePackageVersionForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"]
  },
  projects: {
    addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createCard: ["POST /projects/columns/{column_id}/cards", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createColumn: ["POST /projects/{project_id}/columns", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createForAuthenticatedUser: ["POST /user/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createForOrg: ["POST /orgs/{org}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createForRepo: ["POST /repos/{owner}/{repo}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    delete: ["DELETE /projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    deleteCard: ["DELETE /projects/columns/cards/{card_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    deleteColumn: ["DELETE /projects/columns/{column_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    get: ["GET /projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    getCard: ["GET /projects/columns/cards/{card_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    getColumn: ["GET /projects/columns/{column_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listCards: ["GET /projects/columns/{column_id}/cards", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listCollaborators: ["GET /projects/{project_id}/collaborators", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listColumns: ["GET /projects/{project_id}/columns", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listForOrg: ["GET /orgs/{org}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listForRepo: ["GET /repos/{owner}/{repo}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listForUser: ["GET /users/{username}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    moveCard: ["POST /projects/columns/cards/{card_id}/moves", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    moveColumn: ["POST /projects/columns/{column_id}/moves", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    update: ["PATCH /projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    updateCard: ["PATCH /projects/columns/cards/{card_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    updateColumn: ["PATCH /projects/columns/{column_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
    deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
    deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
    listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
    requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
    submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch", {
      mediaType: {
        previews: ["lydian"]
      }
    }],
    updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
    updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]
  },
  rateLimit: {
    get: ["GET /rate_limit"]
  },
  reactions: {
    createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForTeamDiscussionComment: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteLegacy: ["DELETE /reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }, {
      deprecated: "octokit.reactions.deleteLegacy() is deprecated, see https://docs.github.com/rest/reference/reactions/#delete-a-reaction-legacy"
    }],
    listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }]
  },
  repos: {
    acceptInvitation: ["PATCH /user/repository_invitations/{invitation_id}"],
    addAppAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
      mapToData: "apps"
    }],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
      mapToData: "contexts"
    }],
    addTeamAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
      mapToData: "teams"
    }],
    addUserAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
      mapToData: "users"
    }],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts", {
      mediaType: {
        previews: ["dorian"]
      }
    }],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
    createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
      mediaType: {
        previews: ["zzzax"]
      }
    }],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateEnvironment: ["PUT /repos/{owner}/{repo}/environments/{environment_name}"],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages", {
      mediaType: {
        previews: ["switcheroo"]
      }
    }],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate", {
      mediaType: {
        previews: ["baptiste"]
      }
    }],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: ["DELETE /user/repository_invitations/{invitation_id}"],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
    deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
    deleteAnEnvironment: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],
    deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
      mediaType: {
        previews: ["zzzax"]
      }
    }],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages", {
      mediaType: {
        previews: ["switcheroo"]
      }
    }],
    deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes", {
      mediaType: {
        previews: ["london"]
      }
    }],
    disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts", {
      mediaType: {
        previews: ["dorian"]
      }
    }],
    downloadArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}", {}, {
      renamed: ["repos", "downloadZipballArchive"]
    }],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes", {
      mediaType: {
        previews: ["london"]
      }
    }],
    enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts", {
      mediaType: {
        previews: ["dorian"]
      }
    }],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
    getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics", {
      mediaType: {
        previews: ["mercy"]
      }
    }],
    getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
      mediaType: {
        previews: ["zzzax"]
      }
    }],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
    getEnvironment: ["GET /repos/{owner}/{repo}/environments/{environment_name}"],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
    getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head", {
      mediaType: {
        previews: ["groot"]
      }
    }],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls", {
      mediaType: {
        previews: ["groot"]
      }
    }],
    listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    removeAppAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
      mapToData: "apps"
    }],
    removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
    removeStatusCheckContexts: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
      mapToData: "contexts"
    }],
    removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
    removeTeamAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
      mapToData: "teams"
    }],
    removeUserAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
      mapToData: "users"
    }],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics", {
      mediaType: {
        previews: ["mercy"]
      }
    }],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
    setAppAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
      mapToData: "apps"
    }],
    setStatusCheckContexts: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
      mapToData: "contexts"
    }],
    setTeamAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
      mapToData: "teams"
    }],
    setUserAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
      mapToData: "users"
    }],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
    updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    updateStatusCheckPotection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks", {}, {
      renamed: ["repos", "updateStatusCheckProtection"]
    }],
    updateStatusCheckProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],
    uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", {
      baseUrl: "https://uploads.github.com"
    }]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits", {
      mediaType: {
        previews: ["cloak"]
      }
    }],
    issuesAndPullRequests: ["GET /search/issues"],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics", {
      mediaType: {
        previews: ["mercy"]
      }
    }],
    users: ["GET /search/users"]
  },
  secretScanning: {
    getAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    updateAlert: ["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
    addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
    checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
    deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
    getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
    getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
    listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
    removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
    removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
    updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
    updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: ["POST /user/emails"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: ["POST /user/keys"],
    deleteEmailForAuthenticated: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: ["DELETE /user/keys/{key_id}"],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: ["GET /user/keys/{key_id}"],
    list: ["GET /users"],
    listBlockedByAuthenticated: ["GET /user/blocks"],
    listEmailsForAuthenticated: ["GET /user/emails"],
    listFollowedByAuthenticated: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: ["GET /user/keys"],
    setPrimaryEmailVisibilityForAuthenticated: ["PATCH /user/email/visibility"],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
};

const VERSION = "4.13.5";

function endpointsToMethods(octokit, endpointsMap) {
  const newMethods = {};

  for (const [scope, endpoints] of Object.entries(endpointsMap)) {
    for (const [methodName, endpoint] of Object.entries(endpoints)) {
      const [route, defaults, decorations] = endpoint;
      const [method, url] = route.split(/ /);
      const endpointDefaults = Object.assign({
        method,
        url
      }, defaults);

      if (!newMethods[scope]) {
        newMethods[scope] = {};
      }

      const scopeMethods = newMethods[scope];

      if (decorations) {
        scopeMethods[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
        continue;
      }

      scopeMethods[methodName] = octokit.request.defaults(endpointDefaults);
    }
  }

  return newMethods;
}

function decorate(octokit, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults);
  /* istanbul ignore next */

  function withDecorations(...args) {
    // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
    let options = requestWithDefaults.endpoint.merge(...args); // There are currently no other decorations than `.mapToData`

    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: undefined
      });
      return requestWithDefaults(options);
    }

    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
    }

    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }

    if (decorations.renamedParameters) {
      // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
      const options = requestWithDefaults.endpoint.merge(...args);

      for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
        if (name in options) {
          octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);

          if (!(alias in options)) {
            options[alias] = options[name];
          }

          delete options[name];
        }
      }

      return requestWithDefaults(options);
    } // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488


    return requestWithDefaults(...args);
  }

  return Object.assign(withDecorations, requestWithDefaults);
}

function restEndpointMethods(octokit) {
  return endpointsToMethods(octokit, Endpoints);
}
restEndpointMethods.VERSION = VERSION;

exports.restEndpointMethods = restEndpointMethods;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 537:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var deprecation = __webpack_require__(8932);
var once = _interopDefault(__webpack_require__(1223));

const logOnce = once(deprecation => console.warn(deprecation));
/**
 * Error with extra properties to help with debugging
 */

class RequestError extends Error {
  constructor(message, statusCode, options) {
    super(message); // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    this.name = "HttpError";
    this.status = statusCode;
    Object.defineProperty(this, "code", {
      get() {
        logOnce(new deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
        return statusCode;
      }

    });
    this.headers = options.headers || {}; // redact request credentials without mutating original request options

    const requestCopy = Object.assign({}, options.request);

    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
      });
    }

    requestCopy.url = requestCopy.url // client_id & client_secret can be passed as URL query parameters to increase rate limit
    // see https://developer.github.com/v3/#increasing-the-unauthenticated-rate-limit-for-oauth-applications
    .replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]") // OAuth tokens can be passed as URL query parameters, although it is not recommended
    // see https://developer.github.com/v3/#oauth2-token-sent-in-a-header
    .replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }

}

exports.RequestError = RequestError;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 6234:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var endpoint = __webpack_require__(9440);
var universalUserAgent = __webpack_require__(5030);
var isPlainObject = __webpack_require__(9062);
var nodeFetch = _interopDefault(__webpack_require__(467));
var requestError = __webpack_require__(537);

const VERSION = "5.4.14";

function getBufferResponse(response) {
  return response.arrayBuffer();
}

function fetchWrapper(requestOptions) {
  if (isPlainObject.isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }

  let headers = {};
  let status;
  let url;
  const fetch = requestOptions.request && requestOptions.request.fetch || nodeFetch;
  return fetch(requestOptions.url, Object.assign({
    method: requestOptions.method,
    body: requestOptions.body,
    headers: requestOptions.headers,
    redirect: requestOptions.redirect
  }, requestOptions.request)).then(response => {
    url = response.url;
    status = response.status;

    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }

    if (status === 204 || status === 205) {
      return;
    } // GitHub API returns 200 for HEAD requests


    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }

      throw new requestError.RequestError(response.statusText, status, {
        headers,
        request: requestOptions
      });
    }

    if (status === 304) {
      throw new requestError.RequestError("Not modified", status, {
        headers,
        request: requestOptions
      });
    }

    if (status >= 400) {
      return response.text().then(message => {
        const error = new requestError.RequestError(message, status, {
          headers,
          request: requestOptions
        });

        try {
          let responseBody = JSON.parse(error.message);
          Object.assign(error, responseBody);
          let errors = responseBody.errors; // Assumption `errors` would always be in Array format

          error.message = error.message + ": " + errors.map(JSON.stringify).join(", ");
        } catch (e) {// ignore, see octokit/rest.js#684
        }

        throw error;
      });
    }

    const contentType = response.headers.get("content-type");

    if (/application\/json/.test(contentType)) {
      return response.json();
    }

    if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
      return response.text();
    }

    return getBufferResponse(response);
  }).then(data => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch(error => {
    if (error instanceof requestError.RequestError) {
      throw error;
    }

    throw new requestError.RequestError(error.message, 500, {
      headers,
      request: requestOptions
    });
  });
}

function withDefaults(oldEndpoint, newDefaults) {
  const endpoint = oldEndpoint.defaults(newDefaults);

  const newApi = function (route, parameters) {
    const endpointOptions = endpoint.merge(route, parameters);

    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint.parse(endpointOptions));
    }

    const request = (route, parameters) => {
      return fetchWrapper(endpoint.parse(endpoint.merge(route, parameters)));
    };

    Object.assign(request, {
      endpoint,
      defaults: withDefaults.bind(null, endpoint)
    });
    return endpointOptions.request.hook(request, endpointOptions);
  };

  return Object.assign(newApi, {
    endpoint,
    defaults: withDefaults.bind(null, endpoint)
  });
}

const request = withDefaults(endpoint.endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION} ${universalUserAgent.getUserAgent()}`
  }
});

exports.request = request;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 9062:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (ctor === undefined) return true;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
}

exports.isPlainObject = isPlainObject;


/***/ }),

/***/ 252:
/***/ ((module) => {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ 6718:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ 8882:
/***/ ((module) => {

"use strict";

module.exports = codegen;

/**
 * Begins generating a function.
 * @memberof util
 * @param {string[]} functionParams Function parameter names
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 */
function codegen(functionParams, functionName) {

    /* istanbul ignore if */
    if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = undefined;
    }

    var body = [];

    /**
     * Appends code to the function's body or finishes generation.
     * @typedef Codegen
     * @type {function}
     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
     * @param {...*} [formatParams] Format parameters
     * @returns {Codegen|Function} Itself or the generated function if finished
     * @throws {Error} If format parameter counts do not match
     */

    function Codegen(formatStringOrScope) {
        // note that explicit array handling below makes this ~50% faster

        // finish the function
        if (typeof formatStringOrScope !== "string") {
            var source = toString();
            if (codegen.verbose)
                console.log("codegen: " + source); // eslint-disable-line no-console
            source = "return " + source;
            if (formatStringOrScope) {
                var scopeKeys   = Object.keys(formatStringOrScope),
                    scopeParams = new Array(scopeKeys.length + 1),
                    scopeValues = new Array(scopeKeys.length),
                    scopeOffset = 0;
                while (scopeOffset < scopeKeys.length) {
                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                }
                scopeParams[scopeOffset] = source;
                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
            }
            return Function(source)(); // eslint-disable-line no-new-func
        }

        // otherwise append to body
        var formatParams = new Array(arguments.length - 1),
            formatOffset = 0;
        while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
            var value = formatParams[formatOffset++];
            switch ($1) {
                case "d": case "f": return String(Number(value));
                case "i": return String(Math.floor(value));
                case "j": return JSON.stringify(value);
                case "s": return String(value);
            }
            return "%";
        });
        if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
    }

    function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }

    Codegen.toString = toString;
    return Codegen;
}

/**
 * Begins generating a function.
 * @memberof util
 * @function codegen
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 * @variation 2
 */

/**
 * When set to `true`, codegen will log generated code to console. Useful for debugging.
 * @name util.codegen.verbose
 * @type {boolean}
 */
codegen.verbose = false;


/***/ }),

/***/ 6850:
/***/ ((module) => {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ 663:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = fetch;

var asPromise = __webpack_require__(252),
    inquire   = __webpack_require__(94);

var fs = inquire("fs");

/**
 * Node-style callback as used by {@link util.fetch}.
 * @typedef FetchCallback
 * @type {function}
 * @param {?Error} error Error, if any, otherwise `null`
 * @param {string} [contents] File contents, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Options as used by {@link util.fetch}.
 * @typedef FetchOptions
 * @type {Object}
 * @property {boolean} [binary=false] Whether expecting a binary response
 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param {string} filename File path or url
 * @param {FetchOptions} options Fetch options
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchOptions} [options] Fetch options
 * @returns {Promise<string|Uint8Array>} Promise
 * @variation 3
 */

/**/
fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
    };

    if (options.binary) {
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    }

    xhr.open("GET", filename);
    xhr.send();
};


/***/ }),

/***/ 1843:
/***/ ((module) => {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ 94:
/***/ ((module) => {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ 4761:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * A minimal path module to resolve Unix, Windows and URL paths alike.
 * @memberof util
 * @namespace
 */
var path = exports;

var isAbsolute =
/**
 * Tests if the specified path is absolute.
 * @param {string} path Path to test
 * @returns {boolean} `true` if path is absolute
 */
path.isAbsolute = function isAbsolute(path) {
    return /^(?:\/|\w+:)/.test(path);
};

var normalize =
/**
 * Normalizes the specified path.
 * @param {string} path Path to normalize
 * @returns {string} Normalized path
 */
path.normalize = function normalize(path) {
    path = path.replace(/\\/g, "/")
               .replace(/\/{2,}/g, "/");
    var parts    = path.split("/"),
        absolute = isAbsolute(path),
        prefix   = "";
    if (absolute)
        prefix = parts.shift() + "/";
    for (var i = 0; i < parts.length;) {
        if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
                parts.splice(--i, 2);
            else if (absolute)
                parts.splice(i, 1);
            else
                ++i;
        } else if (parts[i] === ".")
            parts.splice(i, 1);
        else
            ++i;
    }
    return prefix + parts.join("/");
};

/**
 * Resolves the specified include path against the specified origin path.
 * @param {string} originPath Path to the origin file
 * @param {string} includePath Include path relative to origin path
 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
 * @returns {string} Path to the include file
 */
path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
};


/***/ }),

/***/ 969:
/***/ ((module) => {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ 9049:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ 7240:
/***/ ((module) => {

"use strict";


module.exports = bail

function bail(err) {
  if (err) {
    throw err
  }
}


/***/ }),

/***/ 9417:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 3682:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var register = __webpack_require__(4670)
var addHook = __webpack_require__(5549)
var removeHook = __webpack_require__(6819)

// bind with array of arguments: https://stackoverflow.com/a/21792913
var bind = Function.bind
var bindable = bind.bind(bind)

function bindApi (hook, state, name) {
  var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state])
  hook.api = { remove: removeHookRef }
  hook.remove = removeHookRef

  ;['before', 'error', 'after', 'wrap'].forEach(function (kind) {
    var args = name ? [state, kind, name] : [state, kind]
    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args)
  })
}

function HookSingular () {
  var singularHookName = 'h'
  var singularHookState = {
    registry: {}
  }
  var singularHook = register.bind(null, singularHookState, singularHookName)
  bindApi(singularHook, singularHookState, singularHookName)
  return singularHook
}

function HookCollection () {
  var state = {
    registry: {}
  }

  var hook = register.bind(null, state)
  bindApi(hook, state)

  return hook
}

var collectionHookDeprecationMessageDisplayed = false
function Hook () {
  if (!collectionHookDeprecationMessageDisplayed) {
    console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4')
    collectionHookDeprecationMessageDisplayed = true
  }
  return HookCollection()
}

Hook.Singular = HookSingular.bind()
Hook.Collection = HookCollection.bind()

module.exports = Hook
// expose constructors as a named property for TypeScript
module.exports.Hook = Hook
module.exports.Singular = Hook.Singular
module.exports.Collection = Hook.Collection


/***/ }),

/***/ 5549:
/***/ ((module) => {

module.exports = addHook;

function addHook(state, kind, name, hook) {
  var orig = hook;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }

  if (kind === "before") {
    hook = function (method, options) {
      return Promise.resolve()
        .then(orig.bind(null, options))
        .then(method.bind(null, options));
    };
  }

  if (kind === "after") {
    hook = function (method, options) {
      var result;
      return Promise.resolve()
        .then(method.bind(null, options))
        .then(function (result_) {
          result = result_;
          return orig(result, options);
        })
        .then(function () {
          return result;
        });
    };
  }

  if (kind === "error") {
    hook = function (method, options) {
      return Promise.resolve()
        .then(method.bind(null, options))
        .catch(function (error) {
          return orig(error, options);
        });
    };
  }

  state.registry[name].push({
    hook: hook,
    orig: orig,
  });
}


/***/ }),

/***/ 4670:
/***/ ((module) => {

module.exports = register;

function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }

  if (!options) {
    options = {};
  }

  if (Array.isArray(name)) {
    return name.reverse().reduce(function (callback, name) {
      return register.bind(null, state, name, callback, options);
    }, method)();
  }

  return Promise.resolve().then(function () {
    if (!state.registry[name]) {
      return method(options);
    }

    return state.registry[name].reduce(function (method, registered) {
      return registered.hook.bind(null, method, options);
    }, method)();
  });
}


/***/ }),

/***/ 6819:
/***/ ((module) => {

module.exports = removeHook;

function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }

  var index = state.registry[name]
    .map(function (registered) {
      return registered.orig;
    })
    .indexOf(method);

  if (index === -1) {
    return;
  }

  state.registry[name].splice(index, 1);
}


/***/ }),

/***/ 3717:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var concatMap = __webpack_require__(6891);
var balanced = __webpack_require__(9417);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ 5018:
/***/ ((module) => {

"use strict";


const callsites = () => {
	const _prepareStackTrace = Error.prepareStackTrace;
	Error.prepareStackTrace = (_, stack) => stack;
	const stack = new Error().stack.slice(1);
	Error.prepareStackTrace = _prepareStackTrace;
	return stack;
};

module.exports = callsites;
// TODO: Remove this for the next major release
module.exports.default = callsites;


/***/ }),

/***/ 1291:
/***/ ((module) => {

"use strict";


module.exports = ccount

function ccount(source, character) {
  var value = String(source)
  var count = 0
  var index

  if (typeof character !== 'string') {
    throw new Error('Expected character')
  }

  index = value.indexOf(character)

  while (index !== -1) {
    count++
    index = value.indexOf(character, index + character.length)
  }

  return count
}


/***/ }),

/***/ 6891:
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ 4615:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var stream_1 = __webpack_require__(2413);
var protobufjs_1 = __webpack_require__(5881);
/**
 * Transforms a binary stream to a stream of message objects
 */
var BinaryToMessageStream = /** @class */ (function (_super) {
    __extends(BinaryToMessageStream, _super);
    function BinaryToMessageStream(decodeDelimited) {
        var _this = _super.call(this, { objectMode: true }) || this;
        _this.decodeDelimited = decodeDelimited;
        _this.buffer = Buffer.alloc(0);
        return _this;
    }
    BinaryToMessageStream.prototype._transform = function (chunk, encoding, callback) {
        this.buffer = Buffer.concat([this.buffer, chunk]);
        while (true) {
            try {
                var reader = protobufjs_1.Reader.create(this.buffer);
                var message = this.decodeDelimited(reader);
                this.push(message);
                this.buffer = this.buffer.slice(reader.pos);
            }
            catch (err) {
                if (err instanceof RangeError) {
                    // The buffer doesn't have all the data yet. Keep reading.
                    break;
                }
                else {
                    throw err;
                }
            }
        }
        callback();
    };
    return BinaryToMessageStream;
}(stream_1.Transform));
exports.default = BinaryToMessageStream;
//# sourceMappingURL=BinaryToMessageStream.js.map

/***/ }),

/***/ 9145:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var v4_1 = __importDefault(__webpack_require__(824));
function uuid() {
    return function () { return v4_1.default(); };
}
exports.uuid = uuid;
function incrementing() {
    var next = 0;
    return function () { return (next++).toString(); };
}
exports.incrementing = incrementing;
//# sourceMappingURL=IdGenerator.js.map

/***/ }),

/***/ 1592:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var stream_1 = __webpack_require__(2413);
/**
 * Transforms a stream of message objects to binary
 */
var MessageToBinaryStream = /** @class */ (function (_super) {
    __extends(MessageToBinaryStream, _super);
    function MessageToBinaryStream() {
        return _super.call(this, { objectMode: true }) || this;
    }
    MessageToBinaryStream.prototype._transform = function (message, encoding, callback) {
        // @ts-ignore
        var chunk = message.constructor.encodeDelimited(message).finish();
        this.push(chunk);
        callback();
    };
    return MessageToBinaryStream;
}(stream_1.Transform));
exports.default = MessageToBinaryStream;
//# sourceMappingURL=MessageToBinaryStream.js.map

/***/ }),

/***/ 4620:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var stream_1 = __webpack_require__(2413);
/**
 * Transforms a stream of message objects to NDJSON
 */
var MessageToNdjsonStream = /** @class */ (function (_super) {
    __extends(MessageToNdjsonStream, _super);
    function MessageToNdjsonStream() {
        return _super.call(this, {
            writableObjectMode: true,
            readableObjectMode: true,
        }) || this;
    }
    MessageToNdjsonStream.prototype._transform = function (message, encoding, callback) {
        // @ts-ignore
        if (!message.constructor.toObject) {
            return callback(new Error("Not a protobuf object: " + JSON.stringify(message)));
        }
        // @ts-ignore
        var object = message.constructor.toObject(message, {
            defaults: false,
            enums: String,
            arrays: false,
            objects: false,
        });
        // This reviver omits printing fields with empty values
        // This is to make it behave the same as Golang's protobuf->JSON converter
        var json = JSON.stringify(object, function (key, value) {
            return value === '' ? undefined : value;
        });
        this.push(json + '\n');
        callback();
    };
    return MessageToNdjsonStream;
}(stream_1.Transform));
exports.default = MessageToNdjsonStream;
//# sourceMappingURL=MessageToNdjsonStream.js.map

/***/ }),

/***/ 5734:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var stream_1 = __webpack_require__(2413);
/**
 * Transforms an NDJSON stream to a stream of message objects
 */
var NdjsonToMessageStream = /** @class */ (function (_super) {
    __extends(NdjsonToMessageStream, _super);
    function NdjsonToMessageStream(fromObject) {
        var _this = _super.call(this, { objectMode: true }) || this;
        _this.fromObject = fromObject;
        return _this;
    }
    NdjsonToMessageStream.prototype._transform = function (chunk, encoding, callback) {
        var e_1, _a;
        if (this.buffer === undefined) {
            this.buffer = '';
        }
        this.buffer += chunk;
        var lines = this.buffer.split('\n');
        this.buffer = lines.pop();
        try {
            for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
                var line = lines_1_1.value;
                this.push(this.fromObject(JSON.parse(line)));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        callback();
    };
    NdjsonToMessageStream.prototype._flush = function (callback) {
        if (this.buffer) {
            this.push(this.fromObject(JSON.parse(this.buffer)));
        }
        callback();
    };
    return NdjsonToMessageStream;
}(stream_1.Transform));
exports.default = NdjsonToMessageStream;
//# sourceMappingURL=NdjsonToMessageStream.js.map

/***/ }),

/***/ 4321:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var index_1 = __webpack_require__(6106);
var MILLISECONDS_PER_SECOND = 1000;
var NANOSECONDS_PER_MILLISECOND = 1000000;
function millisecondsSinceEpochToTimestamp(millisecondsSinceEpoch) {
    return new index_1.messages.Timestamp(toSecondsAndNanos(millisecondsSinceEpoch));
}
exports.millisecondsSinceEpochToTimestamp = millisecondsSinceEpochToTimestamp;
function millisecondsToDuration(durationInMilliseconds) {
    return new index_1.messages.Duration(toSecondsAndNanos(durationInMilliseconds));
}
exports.millisecondsToDuration = millisecondsToDuration;
function timestampToMillisecondsSinceEpoch(timestamp) {
    var nanos = timestamp.nanos, seconds = timestamp.seconds;
    return toMillis(seconds, nanos);
}
exports.timestampToMillisecondsSinceEpoch = timestampToMillisecondsSinceEpoch;
function durationToMilliseconds(duration) {
    var nanos = duration.nanos, seconds = duration.seconds;
    return toMillis(seconds, nanos);
}
exports.durationToMilliseconds = durationToMilliseconds;
function toSecondsAndNanos(milliseconds) {
    var seconds = Math.floor(milliseconds / MILLISECONDS_PER_SECOND);
    var nanos = Math.floor(Math.floor(milliseconds % MILLISECONDS_PER_SECOND) *
        NANOSECONDS_PER_MILLISECOND);
    return { seconds: seconds, nanos: nanos };
}
function toMillis(seconds, nanos) {
    var secondMillis;
    if (typeof seconds === 'number') {
        secondMillis = seconds * MILLISECONDS_PER_SECOND;
    }
    else {
        secondMillis = seconds
            .multiply(MILLISECONDS_PER_SECOND)
            .toNumber();
    }
    var nanoMillis = nanos / NANOSECONDS_PER_MILLISECOND;
    return Math.floor(secondMillis + nanoMillis);
}
//# sourceMappingURL=TimeConversion.js.map

/***/ }),

/***/ 2364:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


var $protobuf = __webpack_require__(6916);

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.io = (function() {

    /**
     * Namespace io.
     * @exports io
     * @namespace
     */
    var io = {};

    io.cucumber = (function() {

        /**
         * Namespace cucumber.
         * @memberof io
         * @namespace
         */
        var cucumber = {};

        cucumber.messages = (function() {

            /**
             * Namespace messages.
             * @memberof io.cucumber
             * @namespace
             */
            var messages = {};

            messages.Timestamp = (function() {

                /**
                 * Properties of a Timestamp.
                 * @memberof io.cucumber.messages
                 * @interface ITimestamp
                 * @property {number|Long|null} [seconds] Timestamp seconds
                 * @property {number|null} [nanos] Timestamp nanos
                 */

                /**
                 * Constructs a new Timestamp.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a Timestamp.
                 * @implements ITimestamp
                 * @constructor
                 * @param {io.cucumber.messages.ITimestamp=} [properties] Properties to set
                 */
                function Timestamp(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Timestamp seconds.
                 * @member {number|Long} seconds
                 * @memberof io.cucumber.messages.Timestamp
                 * @instance
                 */
                Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Timestamp nanos.
                 * @member {number} nanos
                 * @memberof io.cucumber.messages.Timestamp
                 * @instance
                 */
                Timestamp.prototype.nanos = 0;

                /**
                 * Creates a new Timestamp instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {io.cucumber.messages.ITimestamp=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Timestamp} Timestamp instance
                 */
                Timestamp.create = function create(properties) {
                    return new Timestamp(properties);
                };

                /**
                 * Encodes the specified Timestamp message. Does not implicitly {@link io.cucumber.messages.Timestamp.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {io.cucumber.messages.ITimestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                    return writer;
                };

                /**
                 * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link io.cucumber.messages.Timestamp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {io.cucumber.messages.ITimestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Timestamp message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Timestamp();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.seconds = reader.int64();
                            break;
                        case 2:
                            message.nanos = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Timestamp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Timestamp message.
                 * @function verify
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Timestamp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                            return "seconds: integer|Long expected";
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        if (!$util.isInteger(message.nanos))
                            return "nanos: integer expected";
                    return null;
                };

                /**
                 * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Timestamp} Timestamp
                 */
                Timestamp.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Timestamp)
                        return object;
                    var message = new $root.io.cucumber.messages.Timestamp();
                    if (object.seconds != null)
                        if ($util.Long)
                            (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                        else if (typeof object.seconds === "string")
                            message.seconds = parseInt(object.seconds, 10);
                        else if (typeof object.seconds === "number")
                            message.seconds = object.seconds;
                        else if (typeof object.seconds === "object")
                            message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                    if (object.nanos != null)
                        message.nanos = object.nanos | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {io.cucumber.messages.Timestamp} message Timestamp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Timestamp.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seconds = options.longs === String ? "0" : 0;
                        object.nanos = 0;
                    }
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (typeof message.seconds === "number")
                            object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                        else
                            object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        object.nanos = message.nanos;
                    return object;
                };

                /**
                 * Converts this Timestamp to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Timestamp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Timestamp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Timestamp;
            })();

            messages.Duration = (function() {

                /**
                 * Properties of a Duration.
                 * @memberof io.cucumber.messages
                 * @interface IDuration
                 * @property {number|Long|null} [seconds] Duration seconds
                 * @property {number|null} [nanos] Duration nanos
                 */

                /**
                 * Constructs a new Duration.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a Duration.
                 * @implements IDuration
                 * @constructor
                 * @param {io.cucumber.messages.IDuration=} [properties] Properties to set
                 */
                function Duration(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Duration seconds.
                 * @member {number|Long} seconds
                 * @memberof io.cucumber.messages.Duration
                 * @instance
                 */
                Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Duration nanos.
                 * @member {number} nanos
                 * @memberof io.cucumber.messages.Duration
                 * @instance
                 */
                Duration.prototype.nanos = 0;

                /**
                 * Creates a new Duration instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {io.cucumber.messages.IDuration=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Duration} Duration instance
                 */
                Duration.create = function create(properties) {
                    return new Duration(properties);
                };

                /**
                 * Encodes the specified Duration message. Does not implicitly {@link io.cucumber.messages.Duration.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {io.cucumber.messages.IDuration} message Duration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Duration.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                    return writer;
                };

                /**
                 * Encodes the specified Duration message, length delimited. Does not implicitly {@link io.cucumber.messages.Duration.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {io.cucumber.messages.IDuration} message Duration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Duration.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Duration message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Duration} Duration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Duration.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Duration();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.seconds = reader.int64();
                            break;
                        case 2:
                            message.nanos = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Duration message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Duration} Duration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Duration.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Duration message.
                 * @function verify
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Duration.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                            return "seconds: integer|Long expected";
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        if (!$util.isInteger(message.nanos))
                            return "nanos: integer expected";
                    return null;
                };

                /**
                 * Creates a Duration message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Duration} Duration
                 */
                Duration.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Duration)
                        return object;
                    var message = new $root.io.cucumber.messages.Duration();
                    if (object.seconds != null)
                        if ($util.Long)
                            (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                        else if (typeof object.seconds === "string")
                            message.seconds = parseInt(object.seconds, 10);
                        else if (typeof object.seconds === "number")
                            message.seconds = object.seconds;
                        else if (typeof object.seconds === "object")
                            message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                    if (object.nanos != null)
                        message.nanos = object.nanos | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Duration message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {io.cucumber.messages.Duration} message Duration
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Duration.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seconds = options.longs === String ? "0" : 0;
                        object.nanos = 0;
                    }
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (typeof message.seconds === "number")
                            object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                        else
                            object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        object.nanos = message.nanos;
                    return object;
                };

                /**
                 * Converts this Duration to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Duration
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Duration.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Duration;
            })();

            messages.Envelope = (function() {

                /**
                 * Properties of an Envelope.
                 * @memberof io.cucumber.messages
                 * @interface IEnvelope
                 * @property {io.cucumber.messages.ISource|null} [source] Envelope source
                 * @property {io.cucumber.messages.IGherkinDocument|null} [gherkinDocument] Envelope gherkinDocument
                 * @property {io.cucumber.messages.IPickle|null} [pickle] Envelope pickle
                 * @property {io.cucumber.messages.IAttachment|null} [attachment] Envelope attachment
                 * @property {io.cucumber.messages.ITestCaseStarted|null} [testCaseStarted] Envelope testCaseStarted
                 * @property {io.cucumber.messages.ITestStepStarted|null} [testStepStarted] Envelope testStepStarted
                 * @property {io.cucumber.messages.ITestStepFinished|null} [testStepFinished] Envelope testStepFinished
                 * @property {io.cucumber.messages.ITestCaseFinished|null} [testCaseFinished] Envelope testCaseFinished
                 * @property {io.cucumber.messages.IPickleAccepted|null} [pickleAccepted] Envelope pickleAccepted
                 * @property {io.cucumber.messages.IPickleRejected|null} [pickleRejected] Envelope pickleRejected
                 * @property {io.cucumber.messages.ITestCasePrepared|null} [testCasePrepared] Envelope testCasePrepared
                 * @property {io.cucumber.messages.ITestRunStarted|null} [testRunStarted] Envelope testRunStarted
                 * @property {io.cucumber.messages.ITestRunFinished|null} [testRunFinished] Envelope testRunFinished
                 * @property {io.cucumber.messages.ICommandStart|null} [commandStart] Envelope commandStart
                 * @property {io.cucumber.messages.ICommandActionComplete|null} [commandActionComplete] Envelope commandActionComplete
                 * @property {io.cucumber.messages.ICommandRunBeforeTestRunHooks|null} [commandRunBeforeTestRunHooks] Envelope commandRunBeforeTestRunHooks
                 * @property {io.cucumber.messages.ICommandInitializeTestCase|null} [commandInitializeTestCase] Envelope commandInitializeTestCase
                 * @property {io.cucumber.messages.ICommandRunBeforeTestCaseHook|null} [commandRunBeforeTestCaseHook] Envelope commandRunBeforeTestCaseHook
                 * @property {io.cucumber.messages.ICommandRunTestStep|null} [commandRunTestStep] Envelope commandRunTestStep
                 * @property {io.cucumber.messages.ICommandRunAfterTestCaseHook|null} [commandRunAfterTestCaseHook] Envelope commandRunAfterTestCaseHook
                 * @property {io.cucumber.messages.ICommandRunAfterTestRunHooks|null} [commandRunAfterTestRunHooks] Envelope commandRunAfterTestRunHooks
                 * @property {io.cucumber.messages.ICommandGenerateSnippet|null} [commandGenerateSnippet] Envelope commandGenerateSnippet
                 * @property {string|null} [commandError] Envelope commandError
                 * @property {io.cucumber.messages.ITestCase|null} [testCase] Envelope testCase
                 * @property {io.cucumber.messages.IStepDefinition|null} [stepDefinition] Envelope stepDefinition
                 * @property {io.cucumber.messages.IHook|null} [hook] Envelope hook
                 */

                /**
                 * Constructs a new Envelope.
                 * @memberof io.cucumber.messages
                 * @classdesc All the messages that are passed between different components/processes are Envelope
                 * messages.
                 * @implements IEnvelope
                 * @constructor
                 * @param {io.cucumber.messages.IEnvelope=} [properties] Properties to set
                 */
                function Envelope(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Envelope source.
                 * @member {io.cucumber.messages.ISource|null|undefined} source
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.source = null;

                /**
                 * Envelope gherkinDocument.
                 * @member {io.cucumber.messages.IGherkinDocument|null|undefined} gherkinDocument
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.gherkinDocument = null;

                /**
                 * Envelope pickle.
                 * @member {io.cucumber.messages.IPickle|null|undefined} pickle
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.pickle = null;

                /**
                 * Envelope attachment.
                 * @member {io.cucumber.messages.IAttachment|null|undefined} attachment
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.attachment = null;

                /**
                 * Envelope testCaseStarted.
                 * @member {io.cucumber.messages.ITestCaseStarted|null|undefined} testCaseStarted
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testCaseStarted = null;

                /**
                 * Envelope testStepStarted.
                 * @member {io.cucumber.messages.ITestStepStarted|null|undefined} testStepStarted
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testStepStarted = null;

                /**
                 * Envelope testStepFinished.
                 * @member {io.cucumber.messages.ITestStepFinished|null|undefined} testStepFinished
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testStepFinished = null;

                /**
                 * Envelope testCaseFinished.
                 * @member {io.cucumber.messages.ITestCaseFinished|null|undefined} testCaseFinished
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testCaseFinished = null;

                /**
                 * Envelope pickleAccepted.
                 * @member {io.cucumber.messages.IPickleAccepted|null|undefined} pickleAccepted
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.pickleAccepted = null;

                /**
                 * Envelope pickleRejected.
                 * @member {io.cucumber.messages.IPickleRejected|null|undefined} pickleRejected
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.pickleRejected = null;

                /**
                 * Envelope testCasePrepared.
                 * @member {io.cucumber.messages.ITestCasePrepared|null|undefined} testCasePrepared
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testCasePrepared = null;

                /**
                 * Envelope testRunStarted.
                 * @member {io.cucumber.messages.ITestRunStarted|null|undefined} testRunStarted
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testRunStarted = null;

                /**
                 * Envelope testRunFinished.
                 * @member {io.cucumber.messages.ITestRunFinished|null|undefined} testRunFinished
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testRunFinished = null;

                /**
                 * Envelope commandStart.
                 * @member {io.cucumber.messages.ICommandStart|null|undefined} commandStart
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.commandStart = null;

                /**
                 * Envelope commandActionComplete.
                 * @member {io.cucumber.messages.ICommandActionComplete|null|undefined} commandActionComplete
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.commandActionComplete = null;

                /**
                 * Envelope commandRunBeforeTestRunHooks.
                 * @member {io.cucumber.messages.ICommandRunBeforeTestRunHooks|null|undefined} commandRunBeforeTestRunHooks
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.commandRunBeforeTestRunHooks = null;

                /**
                 * Envelope commandInitializeTestCase.
                 * @member {io.cucumber.messages.ICommandInitializeTestCase|null|undefined} commandInitializeTestCase
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.commandInitializeTestCase = null;

                /**
                 * Envelope commandRunBeforeTestCaseHook.
                 * @member {io.cucumber.messages.ICommandRunBeforeTestCaseHook|null|undefined} commandRunBeforeTestCaseHook
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.commandRunBeforeTestCaseHook = null;

                /**
                 * Envelope commandRunTestStep.
                 * @member {io.cucumber.messages.ICommandRunTestStep|null|undefined} commandRunTestStep
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.commandRunTestStep = null;

                /**
                 * Envelope commandRunAfterTestCaseHook.
                 * @member {io.cucumber.messages.ICommandRunAfterTestCaseHook|null|undefined} commandRunAfterTestCaseHook
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.commandRunAfterTestCaseHook = null;

                /**
                 * Envelope commandRunAfterTestRunHooks.
                 * @member {io.cucumber.messages.ICommandRunAfterTestRunHooks|null|undefined} commandRunAfterTestRunHooks
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.commandRunAfterTestRunHooks = null;

                /**
                 * Envelope commandGenerateSnippet.
                 * @member {io.cucumber.messages.ICommandGenerateSnippet|null|undefined} commandGenerateSnippet
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.commandGenerateSnippet = null;

                /**
                 * Envelope commandError.
                 * @member {string} commandError
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.commandError = "";

                /**
                 * Envelope testCase.
                 * @member {io.cucumber.messages.ITestCase|null|undefined} testCase
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testCase = null;

                /**
                 * Envelope stepDefinition.
                 * @member {io.cucumber.messages.IStepDefinition|null|undefined} stepDefinition
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.stepDefinition = null;

                /**
                 * Envelope hook.
                 * @member {io.cucumber.messages.IHook|null|undefined} hook
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.hook = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * Envelope message.
                 * @member {"source"|"gherkinDocument"|"pickle"|"attachment"|"testCaseStarted"|"testStepStarted"|"testStepFinished"|"testCaseFinished"|"pickleAccepted"|"pickleRejected"|"testCasePrepared"|"testRunStarted"|"testRunFinished"|"commandStart"|"commandActionComplete"|"commandRunBeforeTestRunHooks"|"commandInitializeTestCase"|"commandRunBeforeTestCaseHook"|"commandRunTestStep"|"commandRunAfterTestCaseHook"|"commandRunAfterTestRunHooks"|"commandGenerateSnippet"|"commandError"|"testCase"|"stepDefinition"|"hook"|undefined} message
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Object.defineProperty(Envelope.prototype, "message", {
                    get: $util.oneOfGetter($oneOfFields = ["source", "gherkinDocument", "pickle", "attachment", "testCaseStarted", "testStepStarted", "testStepFinished", "testCaseFinished", "pickleAccepted", "pickleRejected", "testCasePrepared", "testRunStarted", "testRunFinished", "commandStart", "commandActionComplete", "commandRunBeforeTestRunHooks", "commandInitializeTestCase", "commandRunBeforeTestCaseHook", "commandRunTestStep", "commandRunAfterTestCaseHook", "commandRunAfterTestRunHooks", "commandGenerateSnippet", "commandError", "testCase", "stepDefinition", "hook"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Envelope instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {io.cucumber.messages.IEnvelope=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Envelope} Envelope instance
                 */
                Envelope.create = function create(properties) {
                    return new Envelope(properties);
                };

                /**
                 * Encodes the specified Envelope message. Does not implicitly {@link io.cucumber.messages.Envelope.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {io.cucumber.messages.IEnvelope} message Envelope message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Envelope.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.source != null && message.hasOwnProperty("source"))
                        $root.io.cucumber.messages.Source.encode(message.source, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.gherkinDocument != null && message.hasOwnProperty("gherkinDocument"))
                        $root.io.cucumber.messages.GherkinDocument.encode(message.gherkinDocument, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.pickle != null && message.hasOwnProperty("pickle"))
                        $root.io.cucumber.messages.Pickle.encode(message.pickle, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.attachment != null && message.hasOwnProperty("attachment"))
                        $root.io.cucumber.messages.Attachment.encode(message.attachment, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.testCaseStarted != null && message.hasOwnProperty("testCaseStarted"))
                        $root.io.cucumber.messages.TestCaseStarted.encode(message.testCaseStarted, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.testStepStarted != null && message.hasOwnProperty("testStepStarted"))
                        $root.io.cucumber.messages.TestStepStarted.encode(message.testStepStarted, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.testStepFinished != null && message.hasOwnProperty("testStepFinished"))
                        $root.io.cucumber.messages.TestStepFinished.encode(message.testStepFinished, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.testCaseFinished != null && message.hasOwnProperty("testCaseFinished"))
                        $root.io.cucumber.messages.TestCaseFinished.encode(message.testCaseFinished, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.pickleAccepted != null && message.hasOwnProperty("pickleAccepted"))
                        $root.io.cucumber.messages.PickleAccepted.encode(message.pickleAccepted, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.pickleRejected != null && message.hasOwnProperty("pickleRejected"))
                        $root.io.cucumber.messages.PickleRejected.encode(message.pickleRejected, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.testCasePrepared != null && message.hasOwnProperty("testCasePrepared"))
                        $root.io.cucumber.messages.TestCasePrepared.encode(message.testCasePrepared, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.testRunStarted != null && message.hasOwnProperty("testRunStarted"))
                        $root.io.cucumber.messages.TestRunStarted.encode(message.testRunStarted, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.testRunFinished != null && message.hasOwnProperty("testRunFinished"))
                        $root.io.cucumber.messages.TestRunFinished.encode(message.testRunFinished, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if (message.commandStart != null && message.hasOwnProperty("commandStart"))
                        $root.io.cucumber.messages.CommandStart.encode(message.commandStart, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.commandActionComplete != null && message.hasOwnProperty("commandActionComplete"))
                        $root.io.cucumber.messages.CommandActionComplete.encode(message.commandActionComplete, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.commandRunBeforeTestRunHooks != null && message.hasOwnProperty("commandRunBeforeTestRunHooks"))
                        $root.io.cucumber.messages.CommandRunBeforeTestRunHooks.encode(message.commandRunBeforeTestRunHooks, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.commandInitializeTestCase != null && message.hasOwnProperty("commandInitializeTestCase"))
                        $root.io.cucumber.messages.CommandInitializeTestCase.encode(message.commandInitializeTestCase, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    if (message.commandRunBeforeTestCaseHook != null && message.hasOwnProperty("commandRunBeforeTestCaseHook"))
                        $root.io.cucumber.messages.CommandRunBeforeTestCaseHook.encode(message.commandRunBeforeTestCaseHook, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                    if (message.commandRunTestStep != null && message.hasOwnProperty("commandRunTestStep"))
                        $root.io.cucumber.messages.CommandRunTestStep.encode(message.commandRunTestStep, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                    if (message.commandRunAfterTestCaseHook != null && message.hasOwnProperty("commandRunAfterTestCaseHook"))
                        $root.io.cucumber.messages.CommandRunAfterTestCaseHook.encode(message.commandRunAfterTestCaseHook, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    if (message.commandRunAfterTestRunHooks != null && message.hasOwnProperty("commandRunAfterTestRunHooks"))
                        $root.io.cucumber.messages.CommandRunAfterTestRunHooks.encode(message.commandRunAfterTestRunHooks, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                    if (message.commandGenerateSnippet != null && message.hasOwnProperty("commandGenerateSnippet"))
                        $root.io.cucumber.messages.CommandGenerateSnippet.encode(message.commandGenerateSnippet, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                    if (message.commandError != null && message.hasOwnProperty("commandError"))
                        writer.uint32(/* id 23, wireType 2 =*/186).string(message.commandError);
                    if (message.testCase != null && message.hasOwnProperty("testCase"))
                        $root.io.cucumber.messages.TestCase.encode(message.testCase, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                    if (message.stepDefinition != null && message.hasOwnProperty("stepDefinition"))
                        $root.io.cucumber.messages.StepDefinition.encode(message.stepDefinition, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                    if (message.hook != null && message.hasOwnProperty("hook"))
                        $root.io.cucumber.messages.Hook.encode(message.hook, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Envelope message, length delimited. Does not implicitly {@link io.cucumber.messages.Envelope.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {io.cucumber.messages.IEnvelope} message Envelope message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Envelope.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Envelope message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Envelope} Envelope
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Envelope.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Envelope();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.source = $root.io.cucumber.messages.Source.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.gherkinDocument = $root.io.cucumber.messages.GherkinDocument.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.pickle = $root.io.cucumber.messages.Pickle.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.attachment = $root.io.cucumber.messages.Attachment.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.testCaseStarted = $root.io.cucumber.messages.TestCaseStarted.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.testStepStarted = $root.io.cucumber.messages.TestStepStarted.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.testStepFinished = $root.io.cucumber.messages.TestStepFinished.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.testCaseFinished = $root.io.cucumber.messages.TestCaseFinished.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.pickleAccepted = $root.io.cucumber.messages.PickleAccepted.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.pickleRejected = $root.io.cucumber.messages.PickleRejected.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.testCasePrepared = $root.io.cucumber.messages.TestCasePrepared.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.testRunStarted = $root.io.cucumber.messages.TestRunStarted.decode(reader, reader.uint32());
                            break;
                        case 13:
                            message.testRunFinished = $root.io.cucumber.messages.TestRunFinished.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.commandStart = $root.io.cucumber.messages.CommandStart.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.commandActionComplete = $root.io.cucumber.messages.CommandActionComplete.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.commandRunBeforeTestRunHooks = $root.io.cucumber.messages.CommandRunBeforeTestRunHooks.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.commandInitializeTestCase = $root.io.cucumber.messages.CommandInitializeTestCase.decode(reader, reader.uint32());
                            break;
                        case 18:
                            message.commandRunBeforeTestCaseHook = $root.io.cucumber.messages.CommandRunBeforeTestCaseHook.decode(reader, reader.uint32());
                            break;
                        case 19:
                            message.commandRunTestStep = $root.io.cucumber.messages.CommandRunTestStep.decode(reader, reader.uint32());
                            break;
                        case 20:
                            message.commandRunAfterTestCaseHook = $root.io.cucumber.messages.CommandRunAfterTestCaseHook.decode(reader, reader.uint32());
                            break;
                        case 21:
                            message.commandRunAfterTestRunHooks = $root.io.cucumber.messages.CommandRunAfterTestRunHooks.decode(reader, reader.uint32());
                            break;
                        case 22:
                            message.commandGenerateSnippet = $root.io.cucumber.messages.CommandGenerateSnippet.decode(reader, reader.uint32());
                            break;
                        case 23:
                            message.commandError = reader.string();
                            break;
                        case 24:
                            message.testCase = $root.io.cucumber.messages.TestCase.decode(reader, reader.uint32());
                            break;
                        case 25:
                            message.stepDefinition = $root.io.cucumber.messages.StepDefinition.decode(reader, reader.uint32());
                            break;
                        case 26:
                            message.hook = $root.io.cucumber.messages.Hook.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Envelope message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Envelope} Envelope
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Envelope.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Envelope message.
                 * @function verify
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Envelope.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.source != null && message.hasOwnProperty("source")) {
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.Source.verify(message.source);
                            if (error)
                                return "source." + error;
                        }
                    }
                    if (message.gherkinDocument != null && message.hasOwnProperty("gherkinDocument")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.GherkinDocument.verify(message.gherkinDocument);
                            if (error)
                                return "gherkinDocument." + error;
                        }
                    }
                    if (message.pickle != null && message.hasOwnProperty("pickle")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.Pickle.verify(message.pickle);
                            if (error)
                                return "pickle." + error;
                        }
                    }
                    if (message.attachment != null && message.hasOwnProperty("attachment")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.Attachment.verify(message.attachment);
                            if (error)
                                return "attachment." + error;
                        }
                    }
                    if (message.testCaseStarted != null && message.hasOwnProperty("testCaseStarted")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestCaseStarted.verify(message.testCaseStarted);
                            if (error)
                                return "testCaseStarted." + error;
                        }
                    }
                    if (message.testStepStarted != null && message.hasOwnProperty("testStepStarted")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestStepStarted.verify(message.testStepStarted);
                            if (error)
                                return "testStepStarted." + error;
                        }
                    }
                    if (message.testStepFinished != null && message.hasOwnProperty("testStepFinished")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestStepFinished.verify(message.testStepFinished);
                            if (error)
                                return "testStepFinished." + error;
                        }
                    }
                    if (message.testCaseFinished != null && message.hasOwnProperty("testCaseFinished")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestCaseFinished.verify(message.testCaseFinished);
                            if (error)
                                return "testCaseFinished." + error;
                        }
                    }
                    if (message.pickleAccepted != null && message.hasOwnProperty("pickleAccepted")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.PickleAccepted.verify(message.pickleAccepted);
                            if (error)
                                return "pickleAccepted." + error;
                        }
                    }
                    if (message.pickleRejected != null && message.hasOwnProperty("pickleRejected")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.PickleRejected.verify(message.pickleRejected);
                            if (error)
                                return "pickleRejected." + error;
                        }
                    }
                    if (message.testCasePrepared != null && message.hasOwnProperty("testCasePrepared")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestCasePrepared.verify(message.testCasePrepared);
                            if (error)
                                return "testCasePrepared." + error;
                        }
                    }
                    if (message.testRunStarted != null && message.hasOwnProperty("testRunStarted")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestRunStarted.verify(message.testRunStarted);
                            if (error)
                                return "testRunStarted." + error;
                        }
                    }
                    if (message.testRunFinished != null && message.hasOwnProperty("testRunFinished")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestRunFinished.verify(message.testRunFinished);
                            if (error)
                                return "testRunFinished." + error;
                        }
                    }
                    if (message.commandStart != null && message.hasOwnProperty("commandStart")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.CommandStart.verify(message.commandStart);
                            if (error)
                                return "commandStart." + error;
                        }
                    }
                    if (message.commandActionComplete != null && message.hasOwnProperty("commandActionComplete")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.CommandActionComplete.verify(message.commandActionComplete);
                            if (error)
                                return "commandActionComplete." + error;
                        }
                    }
                    if (message.commandRunBeforeTestRunHooks != null && message.hasOwnProperty("commandRunBeforeTestRunHooks")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.CommandRunBeforeTestRunHooks.verify(message.commandRunBeforeTestRunHooks);
                            if (error)
                                return "commandRunBeforeTestRunHooks." + error;
                        }
                    }
                    if (message.commandInitializeTestCase != null && message.hasOwnProperty("commandInitializeTestCase")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.CommandInitializeTestCase.verify(message.commandInitializeTestCase);
                            if (error)
                                return "commandInitializeTestCase." + error;
                        }
                    }
                    if (message.commandRunBeforeTestCaseHook != null && message.hasOwnProperty("commandRunBeforeTestCaseHook")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.CommandRunBeforeTestCaseHook.verify(message.commandRunBeforeTestCaseHook);
                            if (error)
                                return "commandRunBeforeTestCaseHook." + error;
                        }
                    }
                    if (message.commandRunTestStep != null && message.hasOwnProperty("commandRunTestStep")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.CommandRunTestStep.verify(message.commandRunTestStep);
                            if (error)
                                return "commandRunTestStep." + error;
                        }
                    }
                    if (message.commandRunAfterTestCaseHook != null && message.hasOwnProperty("commandRunAfterTestCaseHook")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.CommandRunAfterTestCaseHook.verify(message.commandRunAfterTestCaseHook);
                            if (error)
                                return "commandRunAfterTestCaseHook." + error;
                        }
                    }
                    if (message.commandRunAfterTestRunHooks != null && message.hasOwnProperty("commandRunAfterTestRunHooks")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.CommandRunAfterTestRunHooks.verify(message.commandRunAfterTestRunHooks);
                            if (error)
                                return "commandRunAfterTestRunHooks." + error;
                        }
                    }
                    if (message.commandGenerateSnippet != null && message.hasOwnProperty("commandGenerateSnippet")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.CommandGenerateSnippet.verify(message.commandGenerateSnippet);
                            if (error)
                                return "commandGenerateSnippet." + error;
                        }
                    }
                    if (message.commandError != null && message.hasOwnProperty("commandError")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        if (!$util.isString(message.commandError))
                            return "commandError: string expected";
                    }
                    if (message.testCase != null && message.hasOwnProperty("testCase")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestCase.verify(message.testCase);
                            if (error)
                                return "testCase." + error;
                        }
                    }
                    if (message.stepDefinition != null && message.hasOwnProperty("stepDefinition")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.StepDefinition.verify(message.stepDefinition);
                            if (error)
                                return "stepDefinition." + error;
                        }
                    }
                    if (message.hook != null && message.hasOwnProperty("hook")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.Hook.verify(message.hook);
                            if (error)
                                return "hook." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Envelope message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Envelope} Envelope
                 */
                Envelope.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Envelope)
                        return object;
                    var message = new $root.io.cucumber.messages.Envelope();
                    if (object.source != null) {
                        if (typeof object.source !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.source: object expected");
                        message.source = $root.io.cucumber.messages.Source.fromObject(object.source);
                    }
                    if (object.gherkinDocument != null) {
                        if (typeof object.gherkinDocument !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.gherkinDocument: object expected");
                        message.gherkinDocument = $root.io.cucumber.messages.GherkinDocument.fromObject(object.gherkinDocument);
                    }
                    if (object.pickle != null) {
                        if (typeof object.pickle !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.pickle: object expected");
                        message.pickle = $root.io.cucumber.messages.Pickle.fromObject(object.pickle);
                    }
                    if (object.attachment != null) {
                        if (typeof object.attachment !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.attachment: object expected");
                        message.attachment = $root.io.cucumber.messages.Attachment.fromObject(object.attachment);
                    }
                    if (object.testCaseStarted != null) {
                        if (typeof object.testCaseStarted !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testCaseStarted: object expected");
                        message.testCaseStarted = $root.io.cucumber.messages.TestCaseStarted.fromObject(object.testCaseStarted);
                    }
                    if (object.testStepStarted != null) {
                        if (typeof object.testStepStarted !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testStepStarted: object expected");
                        message.testStepStarted = $root.io.cucumber.messages.TestStepStarted.fromObject(object.testStepStarted);
                    }
                    if (object.testStepFinished != null) {
                        if (typeof object.testStepFinished !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testStepFinished: object expected");
                        message.testStepFinished = $root.io.cucumber.messages.TestStepFinished.fromObject(object.testStepFinished);
                    }
                    if (object.testCaseFinished != null) {
                        if (typeof object.testCaseFinished !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testCaseFinished: object expected");
                        message.testCaseFinished = $root.io.cucumber.messages.TestCaseFinished.fromObject(object.testCaseFinished);
                    }
                    if (object.pickleAccepted != null) {
                        if (typeof object.pickleAccepted !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.pickleAccepted: object expected");
                        message.pickleAccepted = $root.io.cucumber.messages.PickleAccepted.fromObject(object.pickleAccepted);
                    }
                    if (object.pickleRejected != null) {
                        if (typeof object.pickleRejected !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.pickleRejected: object expected");
                        message.pickleRejected = $root.io.cucumber.messages.PickleRejected.fromObject(object.pickleRejected);
                    }
                    if (object.testCasePrepared != null) {
                        if (typeof object.testCasePrepared !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testCasePrepared: object expected");
                        message.testCasePrepared = $root.io.cucumber.messages.TestCasePrepared.fromObject(object.testCasePrepared);
                    }
                    if (object.testRunStarted != null) {
                        if (typeof object.testRunStarted !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testRunStarted: object expected");
                        message.testRunStarted = $root.io.cucumber.messages.TestRunStarted.fromObject(object.testRunStarted);
                    }
                    if (object.testRunFinished != null) {
                        if (typeof object.testRunFinished !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testRunFinished: object expected");
                        message.testRunFinished = $root.io.cucumber.messages.TestRunFinished.fromObject(object.testRunFinished);
                    }
                    if (object.commandStart != null) {
                        if (typeof object.commandStart !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.commandStart: object expected");
                        message.commandStart = $root.io.cucumber.messages.CommandStart.fromObject(object.commandStart);
                    }
                    if (object.commandActionComplete != null) {
                        if (typeof object.commandActionComplete !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.commandActionComplete: object expected");
                        message.commandActionComplete = $root.io.cucumber.messages.CommandActionComplete.fromObject(object.commandActionComplete);
                    }
                    if (object.commandRunBeforeTestRunHooks != null) {
                        if (typeof object.commandRunBeforeTestRunHooks !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.commandRunBeforeTestRunHooks: object expected");
                        message.commandRunBeforeTestRunHooks = $root.io.cucumber.messages.CommandRunBeforeTestRunHooks.fromObject(object.commandRunBeforeTestRunHooks);
                    }
                    if (object.commandInitializeTestCase != null) {
                        if (typeof object.commandInitializeTestCase !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.commandInitializeTestCase: object expected");
                        message.commandInitializeTestCase = $root.io.cucumber.messages.CommandInitializeTestCase.fromObject(object.commandInitializeTestCase);
                    }
                    if (object.commandRunBeforeTestCaseHook != null) {
                        if (typeof object.commandRunBeforeTestCaseHook !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.commandRunBeforeTestCaseHook: object expected");
                        message.commandRunBeforeTestCaseHook = $root.io.cucumber.messages.CommandRunBeforeTestCaseHook.fromObject(object.commandRunBeforeTestCaseHook);
                    }
                    if (object.commandRunTestStep != null) {
                        if (typeof object.commandRunTestStep !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.commandRunTestStep: object expected");
                        message.commandRunTestStep = $root.io.cucumber.messages.CommandRunTestStep.fromObject(object.commandRunTestStep);
                    }
                    if (object.commandRunAfterTestCaseHook != null) {
                        if (typeof object.commandRunAfterTestCaseHook !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.commandRunAfterTestCaseHook: object expected");
                        message.commandRunAfterTestCaseHook = $root.io.cucumber.messages.CommandRunAfterTestCaseHook.fromObject(object.commandRunAfterTestCaseHook);
                    }
                    if (object.commandRunAfterTestRunHooks != null) {
                        if (typeof object.commandRunAfterTestRunHooks !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.commandRunAfterTestRunHooks: object expected");
                        message.commandRunAfterTestRunHooks = $root.io.cucumber.messages.CommandRunAfterTestRunHooks.fromObject(object.commandRunAfterTestRunHooks);
                    }
                    if (object.commandGenerateSnippet != null) {
                        if (typeof object.commandGenerateSnippet !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.commandGenerateSnippet: object expected");
                        message.commandGenerateSnippet = $root.io.cucumber.messages.CommandGenerateSnippet.fromObject(object.commandGenerateSnippet);
                    }
                    if (object.commandError != null)
                        message.commandError = String(object.commandError);
                    if (object.testCase != null) {
                        if (typeof object.testCase !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testCase: object expected");
                        message.testCase = $root.io.cucumber.messages.TestCase.fromObject(object.testCase);
                    }
                    if (object.stepDefinition != null) {
                        if (typeof object.stepDefinition !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.stepDefinition: object expected");
                        message.stepDefinition = $root.io.cucumber.messages.StepDefinition.fromObject(object.stepDefinition);
                    }
                    if (object.hook != null) {
                        if (typeof object.hook !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.hook: object expected");
                        message.hook = $root.io.cucumber.messages.Hook.fromObject(object.hook);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Envelope message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {io.cucumber.messages.Envelope} message Envelope
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Envelope.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.source != null && message.hasOwnProperty("source")) {
                        object.source = $root.io.cucumber.messages.Source.toObject(message.source, options);
                        if (options.oneofs)
                            object.message = "source";
                    }
                    if (message.gherkinDocument != null && message.hasOwnProperty("gherkinDocument")) {
                        object.gherkinDocument = $root.io.cucumber.messages.GherkinDocument.toObject(message.gherkinDocument, options);
                        if (options.oneofs)
                            object.message = "gherkinDocument";
                    }
                    if (message.pickle != null && message.hasOwnProperty("pickle")) {
                        object.pickle = $root.io.cucumber.messages.Pickle.toObject(message.pickle, options);
                        if (options.oneofs)
                            object.message = "pickle";
                    }
                    if (message.attachment != null && message.hasOwnProperty("attachment")) {
                        object.attachment = $root.io.cucumber.messages.Attachment.toObject(message.attachment, options);
                        if (options.oneofs)
                            object.message = "attachment";
                    }
                    if (message.testCaseStarted != null && message.hasOwnProperty("testCaseStarted")) {
                        object.testCaseStarted = $root.io.cucumber.messages.TestCaseStarted.toObject(message.testCaseStarted, options);
                        if (options.oneofs)
                            object.message = "testCaseStarted";
                    }
                    if (message.testStepStarted != null && message.hasOwnProperty("testStepStarted")) {
                        object.testStepStarted = $root.io.cucumber.messages.TestStepStarted.toObject(message.testStepStarted, options);
                        if (options.oneofs)
                            object.message = "testStepStarted";
                    }
                    if (message.testStepFinished != null && message.hasOwnProperty("testStepFinished")) {
                        object.testStepFinished = $root.io.cucumber.messages.TestStepFinished.toObject(message.testStepFinished, options);
                        if (options.oneofs)
                            object.message = "testStepFinished";
                    }
                    if (message.testCaseFinished != null && message.hasOwnProperty("testCaseFinished")) {
                        object.testCaseFinished = $root.io.cucumber.messages.TestCaseFinished.toObject(message.testCaseFinished, options);
                        if (options.oneofs)
                            object.message = "testCaseFinished";
                    }
                    if (message.pickleAccepted != null && message.hasOwnProperty("pickleAccepted")) {
                        object.pickleAccepted = $root.io.cucumber.messages.PickleAccepted.toObject(message.pickleAccepted, options);
                        if (options.oneofs)
                            object.message = "pickleAccepted";
                    }
                    if (message.pickleRejected != null && message.hasOwnProperty("pickleRejected")) {
                        object.pickleRejected = $root.io.cucumber.messages.PickleRejected.toObject(message.pickleRejected, options);
                        if (options.oneofs)
                            object.message = "pickleRejected";
                    }
                    if (message.testCasePrepared != null && message.hasOwnProperty("testCasePrepared")) {
                        object.testCasePrepared = $root.io.cucumber.messages.TestCasePrepared.toObject(message.testCasePrepared, options);
                        if (options.oneofs)
                            object.message = "testCasePrepared";
                    }
                    if (message.testRunStarted != null && message.hasOwnProperty("testRunStarted")) {
                        object.testRunStarted = $root.io.cucumber.messages.TestRunStarted.toObject(message.testRunStarted, options);
                        if (options.oneofs)
                            object.message = "testRunStarted";
                    }
                    if (message.testRunFinished != null && message.hasOwnProperty("testRunFinished")) {
                        object.testRunFinished = $root.io.cucumber.messages.TestRunFinished.toObject(message.testRunFinished, options);
                        if (options.oneofs)
                            object.message = "testRunFinished";
                    }
                    if (message.commandStart != null && message.hasOwnProperty("commandStart")) {
                        object.commandStart = $root.io.cucumber.messages.CommandStart.toObject(message.commandStart, options);
                        if (options.oneofs)
                            object.message = "commandStart";
                    }
                    if (message.commandActionComplete != null && message.hasOwnProperty("commandActionComplete")) {
                        object.commandActionComplete = $root.io.cucumber.messages.CommandActionComplete.toObject(message.commandActionComplete, options);
                        if (options.oneofs)
                            object.message = "commandActionComplete";
                    }
                    if (message.commandRunBeforeTestRunHooks != null && message.hasOwnProperty("commandRunBeforeTestRunHooks")) {
                        object.commandRunBeforeTestRunHooks = $root.io.cucumber.messages.CommandRunBeforeTestRunHooks.toObject(message.commandRunBeforeTestRunHooks, options);
                        if (options.oneofs)
                            object.message = "commandRunBeforeTestRunHooks";
                    }
                    if (message.commandInitializeTestCase != null && message.hasOwnProperty("commandInitializeTestCase")) {
                        object.commandInitializeTestCase = $root.io.cucumber.messages.CommandInitializeTestCase.toObject(message.commandInitializeTestCase, options);
                        if (options.oneofs)
                            object.message = "commandInitializeTestCase";
                    }
                    if (message.commandRunBeforeTestCaseHook != null && message.hasOwnProperty("commandRunBeforeTestCaseHook")) {
                        object.commandRunBeforeTestCaseHook = $root.io.cucumber.messages.CommandRunBeforeTestCaseHook.toObject(message.commandRunBeforeTestCaseHook, options);
                        if (options.oneofs)
                            object.message = "commandRunBeforeTestCaseHook";
                    }
                    if (message.commandRunTestStep != null && message.hasOwnProperty("commandRunTestStep")) {
                        object.commandRunTestStep = $root.io.cucumber.messages.CommandRunTestStep.toObject(message.commandRunTestStep, options);
                        if (options.oneofs)
                            object.message = "commandRunTestStep";
                    }
                    if (message.commandRunAfterTestCaseHook != null && message.hasOwnProperty("commandRunAfterTestCaseHook")) {
                        object.commandRunAfterTestCaseHook = $root.io.cucumber.messages.CommandRunAfterTestCaseHook.toObject(message.commandRunAfterTestCaseHook, options);
                        if (options.oneofs)
                            object.message = "commandRunAfterTestCaseHook";
                    }
                    if (message.commandRunAfterTestRunHooks != null && message.hasOwnProperty("commandRunAfterTestRunHooks")) {
                        object.commandRunAfterTestRunHooks = $root.io.cucumber.messages.CommandRunAfterTestRunHooks.toObject(message.commandRunAfterTestRunHooks, options);
                        if (options.oneofs)
                            object.message = "commandRunAfterTestRunHooks";
                    }
                    if (message.commandGenerateSnippet != null && message.hasOwnProperty("commandGenerateSnippet")) {
                        object.commandGenerateSnippet = $root.io.cucumber.messages.CommandGenerateSnippet.toObject(message.commandGenerateSnippet, options);
                        if (options.oneofs)
                            object.message = "commandGenerateSnippet";
                    }
                    if (message.commandError != null && message.hasOwnProperty("commandError")) {
                        object.commandError = message.commandError;
                        if (options.oneofs)
                            object.message = "commandError";
                    }
                    if (message.testCase != null && message.hasOwnProperty("testCase")) {
                        object.testCase = $root.io.cucumber.messages.TestCase.toObject(message.testCase, options);
                        if (options.oneofs)
                            object.message = "testCase";
                    }
                    if (message.stepDefinition != null && message.hasOwnProperty("stepDefinition")) {
                        object.stepDefinition = $root.io.cucumber.messages.StepDefinition.toObject(message.stepDefinition, options);
                        if (options.oneofs)
                            object.message = "stepDefinition";
                    }
                    if (message.hook != null && message.hasOwnProperty("hook")) {
                        object.hook = $root.io.cucumber.messages.Hook.toObject(message.hook, options);
                        if (options.oneofs)
                            object.message = "hook";
                    }
                    return object;
                };

                /**
                 * Converts this Envelope to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Envelope.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Envelope;
            })();

            messages.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof io.cucumber.messages
                 * @interface ILocation
                 * @property {number|null} [line] Location line
                 * @property {number|null} [column] Location column
                 */

                /**
                 * Constructs a new Location.
                 * @memberof io.cucumber.messages
                 * @classdesc Points to a line and a column in a text file
                 * @implements ILocation
                 * @constructor
                 * @param {io.cucumber.messages.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location line.
                 * @member {number} line
                 * @memberof io.cucumber.messages.Location
                 * @instance
                 */
                Location.prototype.line = 0;

                /**
                 * Location column.
                 * @member {number} column
                 * @memberof io.cucumber.messages.Location
                 * @instance
                 */
                Location.prototype.column = 0;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {io.cucumber.messages.ILocation=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link io.cucumber.messages.Location.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {io.cucumber.messages.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.line != null && message.hasOwnProperty("line"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.line);
                    if (message.column != null && message.hasOwnProperty("column"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.column);
                    return writer;
                };

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link io.cucumber.messages.Location.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {io.cucumber.messages.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Location();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.line = reader.uint32();
                            break;
                        case 2:
                            message.column = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.line != null && message.hasOwnProperty("line"))
                        if (!$util.isInteger(message.line))
                            return "line: integer expected";
                    if (message.column != null && message.hasOwnProperty("column"))
                        if (!$util.isInteger(message.column))
                            return "column: integer expected";
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Location)
                        return object;
                    var message = new $root.io.cucumber.messages.Location();
                    if (object.line != null)
                        message.line = object.line >>> 0;
                    if (object.column != null)
                        message.column = object.column >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {io.cucumber.messages.Location} message Location
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.line = 0;
                        object.column = 0;
                    }
                    if (message.line != null && message.hasOwnProperty("line"))
                        object.line = message.line;
                    if (message.column != null && message.hasOwnProperty("column"))
                        object.column = message.column;
                    return object;
                };

                /**
                 * Converts this Location to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Location
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Location;
            })();

            messages.SourceReference = (function() {

                /**
                 * Properties of a SourceReference.
                 * @memberof io.cucumber.messages
                 * @interface ISourceReference
                 * @property {string|null} [uri] SourceReference uri
                 * @property {io.cucumber.messages.ILocation|null} [location] SourceReference location
                 */

                /**
                 * Constructs a new SourceReference.
                 * @memberof io.cucumber.messages
                 * @classdesc Points to a [Source](#io.cucumber.messages.Source) identified by `uri` and a
                 * [Location](#io.cucumber.messages.Location) within that file.
                 * @implements ISourceReference
                 * @constructor
                 * @param {io.cucumber.messages.ISourceReference=} [properties] Properties to set
                 */
                function SourceReference(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SourceReference uri.
                 * @member {string} uri
                 * @memberof io.cucumber.messages.SourceReference
                 * @instance
                 */
                SourceReference.prototype.uri = "";

                /**
                 * SourceReference location.
                 * @member {io.cucumber.messages.ILocation|null|undefined} location
                 * @memberof io.cucumber.messages.SourceReference
                 * @instance
                 */
                SourceReference.prototype.location = null;

                /**
                 * Creates a new SourceReference instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {io.cucumber.messages.ISourceReference=} [properties] Properties to set
                 * @returns {io.cucumber.messages.SourceReference} SourceReference instance
                 */
                SourceReference.create = function create(properties) {
                    return new SourceReference(properties);
                };

                /**
                 * Encodes the specified SourceReference message. Does not implicitly {@link io.cucumber.messages.SourceReference.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {io.cucumber.messages.ISourceReference} message SourceReference message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceReference.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                    if (message.location != null && message.hasOwnProperty("location"))
                        $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SourceReference message, length delimited. Does not implicitly {@link io.cucumber.messages.SourceReference.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {io.cucumber.messages.ISourceReference} message SourceReference message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceReference.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SourceReference message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.SourceReference} SourceReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceReference.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.SourceReference();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.uri = reader.string();
                            break;
                        case 2:
                            message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SourceReference message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.SourceReference} SourceReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceReference.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SourceReference message.
                 * @function verify
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourceReference.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        var error = $root.io.cucumber.messages.Location.verify(message.location);
                        if (error)
                            return "location." + error;
                    }
                    return null;
                };

                /**
                 * Creates a SourceReference message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.SourceReference} SourceReference
                 */
                SourceReference.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.SourceReference)
                        return object;
                    var message = new $root.io.cucumber.messages.SourceReference();
                    if (object.uri != null)
                        message.uri = String(object.uri);
                    if (object.location != null) {
                        if (typeof object.location !== "object")
                            throw TypeError(".io.cucumber.messages.SourceReference.location: object expected");
                        message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SourceReference message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {io.cucumber.messages.SourceReference} message SourceReference
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourceReference.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.uri = "";
                        object.location = null;
                    }
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        object.uri = message.uri;
                    if (message.location != null && message.hasOwnProperty("location"))
                        object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                    return object;
                };

                /**
                 * Converts this SourceReference to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.SourceReference
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourceReference.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SourceReference;
            })();

            messages.Media = (function() {

                /**
                 * Properties of a Media.
                 * @memberof io.cucumber.messages
                 * @interface IMedia
                 * @property {io.cucumber.messages.Media.Encoding|null} [encoding] Media encoding
                 * @property {string|null} [contentType] The content type of the data. This can be any valid
                 * [IANA Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml)
                 * as well as Cucumber-specific media types such as `text/x.cucumber.gherkin+plain`
                 * and `text/x.cucumber.stacktrace+plain`
                 */

                /**
                 * Constructs a new Media.
                 * @memberof io.cucumber.messages
                 * @classdesc Meta information about encoded contents
                 * @implements IMedia
                 * @constructor
                 * @param {io.cucumber.messages.IMedia=} [properties] Properties to set
                 */
                function Media(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Media encoding.
                 * @member {io.cucumber.messages.Media.Encoding} encoding
                 * @memberof io.cucumber.messages.Media
                 * @instance
                 */
                Media.prototype.encoding = 0;

                /**
                 * The content type of the data. This can be any valid
                 * [IANA Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml)
                 * as well as Cucumber-specific media types such as `text/x.cucumber.gherkin+plain`
                 * and `text/x.cucumber.stacktrace+plain`
                 * @member {string} contentType
                 * @memberof io.cucumber.messages.Media
                 * @instance
                 */
                Media.prototype.contentType = "";

                /**
                 * Creates a new Media instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Media
                 * @static
                 * @param {io.cucumber.messages.IMedia=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Media} Media instance
                 */
                Media.create = function create(properties) {
                    return new Media(properties);
                };

                /**
                 * Encodes the specified Media message. Does not implicitly {@link io.cucumber.messages.Media.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Media
                 * @static
                 * @param {io.cucumber.messages.IMedia} message Media message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Media.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.encoding != null && message.hasOwnProperty("encoding"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.encoding);
                    if (message.contentType != null && message.hasOwnProperty("contentType"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.contentType);
                    return writer;
                };

                /**
                 * Encodes the specified Media message, length delimited. Does not implicitly {@link io.cucumber.messages.Media.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Media
                 * @static
                 * @param {io.cucumber.messages.IMedia} message Media message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Media.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Media message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Media
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Media} Media
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Media.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Media();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.encoding = reader.int32();
                            break;
                        case 2:
                            message.contentType = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Media message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Media
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Media} Media
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Media.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Media message.
                 * @function verify
                 * @memberof io.cucumber.messages.Media
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Media.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.encoding != null && message.hasOwnProperty("encoding"))
                        switch (message.encoding) {
                        default:
                            return "encoding: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.contentType != null && message.hasOwnProperty("contentType"))
                        if (!$util.isString(message.contentType))
                            return "contentType: string expected";
                    return null;
                };

                /**
                 * Creates a Media message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Media
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Media} Media
                 */
                Media.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Media)
                        return object;
                    var message = new $root.io.cucumber.messages.Media();
                    switch (object.encoding) {
                    case "BASE64":
                    case 0:
                        message.encoding = 0;
                        break;
                    case "UTF8":
                    case 1:
                        message.encoding = 1;
                        break;
                    }
                    if (object.contentType != null)
                        message.contentType = String(object.contentType);
                    return message;
                };

                /**
                 * Creates a plain object from a Media message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Media
                 * @static
                 * @param {io.cucumber.messages.Media} message Media
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Media.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.encoding = options.enums === String ? "BASE64" : 0;
                        object.contentType = "";
                    }
                    if (message.encoding != null && message.hasOwnProperty("encoding"))
                        object.encoding = options.enums === String ? $root.io.cucumber.messages.Media.Encoding[message.encoding] : message.encoding;
                    if (message.contentType != null && message.hasOwnProperty("contentType"))
                        object.contentType = message.contentType;
                    return object;
                };

                /**
                 * Converts this Media to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Media
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Media.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Encoding enum.
                 * @name io.cucumber.messages.Media.Encoding
                 * @enum {string}
                 * @property {number} BASE64=0 BASE64 value
                 * @property {number} UTF8=1 UTF8 value
                 */
                Media.Encoding = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "BASE64"] = 0;
                    values[valuesById[1] = "UTF8"] = 1;
                    return values;
                })();

                return Media;
            })();

            messages.Source = (function() {

                /**
                 * Properties of a Source.
                 * @memberof io.cucumber.messages
                 * @interface ISource
                 * @property {string|null} [uri] The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
                 * of the source, typically a file path relative to the root directory
                 * @property {string|null} [data] Source data
                 * @property {io.cucumber.messages.IMedia|null} [media] Source media
                 */

                /**
                 * Constructs a new Source.
                 * @memberof io.cucumber.messages
                 * @classdesc A source file, typically a Gherkin document
                 * @implements ISource
                 * @constructor
                 * @param {io.cucumber.messages.ISource=} [properties] Properties to set
                 */
                function Source(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
                 * of the source, typically a file path relative to the root directory
                 * @member {string} uri
                 * @memberof io.cucumber.messages.Source
                 * @instance
                 */
                Source.prototype.uri = "";

                /**
                 * Source data.
                 * @member {string} data
                 * @memberof io.cucumber.messages.Source
                 * @instance
                 */
                Source.prototype.data = "";

                /**
                 * Source media.
                 * @member {io.cucumber.messages.IMedia|null|undefined} media
                 * @memberof io.cucumber.messages.Source
                 * @instance
                 */
                Source.prototype.media = null;

                /**
                 * Creates a new Source instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {io.cucumber.messages.ISource=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Source} Source instance
                 */
                Source.create = function create(properties) {
                    return new Source(properties);
                };

                /**
                 * Encodes the specified Source message. Does not implicitly {@link io.cucumber.messages.Source.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {io.cucumber.messages.ISource} message Source message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Source.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                    if (message.data != null && message.hasOwnProperty("data"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
                    if (message.media != null && message.hasOwnProperty("media"))
                        $root.io.cucumber.messages.Media.encode(message.media, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Source message, length delimited. Does not implicitly {@link io.cucumber.messages.Source.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {io.cucumber.messages.ISource} message Source message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Source.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Source message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Source} Source
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Source.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Source();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.uri = reader.string();
                            break;
                        case 2:
                            message.data = reader.string();
                            break;
                        case 3:
                            message.media = $root.io.cucumber.messages.Media.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Source message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Source} Source
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Source.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Source message.
                 * @function verify
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Source.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!$util.isString(message.data))
                            return "data: string expected";
                    if (message.media != null && message.hasOwnProperty("media")) {
                        var error = $root.io.cucumber.messages.Media.verify(message.media);
                        if (error)
                            return "media." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Source message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Source} Source
                 */
                Source.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Source)
                        return object;
                    var message = new $root.io.cucumber.messages.Source();
                    if (object.uri != null)
                        message.uri = String(object.uri);
                    if (object.data != null)
                        message.data = String(object.data);
                    if (object.media != null) {
                        if (typeof object.media !== "object")
                            throw TypeError(".io.cucumber.messages.Source.media: object expected");
                        message.media = $root.io.cucumber.messages.Media.fromObject(object.media);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Source message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {io.cucumber.messages.Source} message Source
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Source.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.uri = "";
                        object.data = "";
                        object.media = null;
                    }
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        object.uri = message.uri;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = message.data;
                    if (message.media != null && message.hasOwnProperty("media"))
                        object.media = $root.io.cucumber.messages.Media.toObject(message.media, options);
                    return object;
                };

                /**
                 * Converts this Source to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Source
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Source.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Source;
            })();

            messages.GherkinDocument = (function() {

                /**
                 * Properties of a GherkinDocument.
                 * @memberof io.cucumber.messages
                 * @interface IGherkinDocument
                 * @property {string|null} [uri] The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
                 * of the source, typically a file path relative to the root directory
                 * @property {io.cucumber.messages.GherkinDocument.IFeature|null} [feature] GherkinDocument feature
                 * @property {Array.<io.cucumber.messages.GherkinDocument.IComment>|null} [comments] GherkinDocument comments
                 */

                /**
                 * Constructs a new GherkinDocument.
                 * @memberof io.cucumber.messages
                 * @classdesc The [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) of a Gherkin document.
                 * Cucumber implementations should *not* depend on `GherkinDocument` or any of its
                 * children for execution - use [Pickle](#io.cucumber.messages.Pickle) instead.
                 * 
                 * The only consumers of `GherkinDocument` should only be formatters that produce
                 * "rich" output, resembling the original Gherkin document.
                 * @implements IGherkinDocument
                 * @constructor
                 * @param {io.cucumber.messages.IGherkinDocument=} [properties] Properties to set
                 */
                function GherkinDocument(properties) {
                    this.comments = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
                 * of the source, typically a file path relative to the root directory
                 * @member {string} uri
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @instance
                 */
                GherkinDocument.prototype.uri = "";

                /**
                 * GherkinDocument feature.
                 * @member {io.cucumber.messages.GherkinDocument.IFeature|null|undefined} feature
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @instance
                 */
                GherkinDocument.prototype.feature = null;

                /**
                 * GherkinDocument comments.
                 * @member {Array.<io.cucumber.messages.GherkinDocument.IComment>} comments
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @instance
                 */
                GherkinDocument.prototype.comments = $util.emptyArray;

                /**
                 * Creates a new GherkinDocument instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {io.cucumber.messages.IGherkinDocument=} [properties] Properties to set
                 * @returns {io.cucumber.messages.GherkinDocument} GherkinDocument instance
                 */
                GherkinDocument.create = function create(properties) {
                    return new GherkinDocument(properties);
                };

                /**
                 * Encodes the specified GherkinDocument message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {io.cucumber.messages.IGherkinDocument} message GherkinDocument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GherkinDocument.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                    if (message.feature != null && message.hasOwnProperty("feature"))
                        $root.io.cucumber.messages.GherkinDocument.Feature.encode(message.feature, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.comments != null && message.comments.length)
                        for (var i = 0; i < message.comments.length; ++i)
                            $root.io.cucumber.messages.GherkinDocument.Comment.encode(message.comments[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified GherkinDocument message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {io.cucumber.messages.IGherkinDocument} message GherkinDocument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GherkinDocument.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GherkinDocument message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.GherkinDocument} GherkinDocument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GherkinDocument.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.uri = reader.string();
                            break;
                        case 2:
                            message.feature = $root.io.cucumber.messages.GherkinDocument.Feature.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.comments && message.comments.length))
                                message.comments = [];
                            message.comments.push($root.io.cucumber.messages.GherkinDocument.Comment.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GherkinDocument message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.GherkinDocument} GherkinDocument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GherkinDocument.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GherkinDocument message.
                 * @function verify
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GherkinDocument.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.feature != null && message.hasOwnProperty("feature")) {
                        var error = $root.io.cucumber.messages.GherkinDocument.Feature.verify(message.feature);
                        if (error)
                            return "feature." + error;
                    }
                    if (message.comments != null && message.hasOwnProperty("comments")) {
                        if (!Array.isArray(message.comments))
                            return "comments: array expected";
                        for (var i = 0; i < message.comments.length; ++i) {
                            var error = $root.io.cucumber.messages.GherkinDocument.Comment.verify(message.comments[i]);
                            if (error)
                                return "comments." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GherkinDocument message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.GherkinDocument} GherkinDocument
                 */
                GherkinDocument.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.GherkinDocument)
                        return object;
                    var message = new $root.io.cucumber.messages.GherkinDocument();
                    if (object.uri != null)
                        message.uri = String(object.uri);
                    if (object.feature != null) {
                        if (typeof object.feature !== "object")
                            throw TypeError(".io.cucumber.messages.GherkinDocument.feature: object expected");
                        message.feature = $root.io.cucumber.messages.GherkinDocument.Feature.fromObject(object.feature);
                    }
                    if (object.comments) {
                        if (!Array.isArray(object.comments))
                            throw TypeError(".io.cucumber.messages.GherkinDocument.comments: array expected");
                        message.comments = [];
                        for (var i = 0; i < object.comments.length; ++i) {
                            if (typeof object.comments[i] !== "object")
                                throw TypeError(".io.cucumber.messages.GherkinDocument.comments: object expected");
                            message.comments[i] = $root.io.cucumber.messages.GherkinDocument.Comment.fromObject(object.comments[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GherkinDocument message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {io.cucumber.messages.GherkinDocument} message GherkinDocument
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GherkinDocument.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.comments = [];
                    if (options.defaults) {
                        object.uri = "";
                        object.feature = null;
                    }
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        object.uri = message.uri;
                    if (message.feature != null && message.hasOwnProperty("feature"))
                        object.feature = $root.io.cucumber.messages.GherkinDocument.Feature.toObject(message.feature, options);
                    if (message.comments && message.comments.length) {
                        object.comments = [];
                        for (var j = 0; j < message.comments.length; ++j)
                            object.comments[j] = $root.io.cucumber.messages.GherkinDocument.Comment.toObject(message.comments[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GherkinDocument to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GherkinDocument.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                GherkinDocument.Comment = (function() {

                    /**
                     * Properties of a Comment.
                     * @memberof io.cucumber.messages.GherkinDocument
                     * @interface IComment
                     * @property {io.cucumber.messages.ILocation|null} [location] Comment location
                     * @property {string|null} [text] Comment text
                     */

                    /**
                     * Constructs a new Comment.
                     * @memberof io.cucumber.messages.GherkinDocument
                     * @classdesc A comment in a Gherkin document
                     * @implements IComment
                     * @constructor
                     * @param {io.cucumber.messages.GherkinDocument.IComment=} [properties] Properties to set
                     */
                    function Comment(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Comment location.
                     * @member {io.cucumber.messages.ILocation|null|undefined} location
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @instance
                     */
                    Comment.prototype.location = null;

                    /**
                     * Comment text.
                     * @member {string} text
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @instance
                     */
                    Comment.prototype.text = "";

                    /**
                     * Creates a new Comment instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.IComment=} [properties] Properties to set
                     * @returns {io.cucumber.messages.GherkinDocument.Comment} Comment instance
                     */
                    Comment.create = function create(properties) {
                        return new Comment(properties);
                    };

                    /**
                     * Encodes the specified Comment message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Comment.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.IComment} message Comment message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Comment.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.location != null && message.hasOwnProperty("location"))
                            $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.text != null && message.hasOwnProperty("text"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
                        return writer;
                    };

                    /**
                     * Encodes the specified Comment message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Comment.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.IComment} message Comment message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Comment.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Comment message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.GherkinDocument.Comment} Comment
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Comment.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Comment();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.text = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Comment message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.GherkinDocument.Comment} Comment
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Comment.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Comment message.
                     * @function verify
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Comment.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.location != null && message.hasOwnProperty("location")) {
                            var error = $root.io.cucumber.messages.Location.verify(message.location);
                            if (error)
                                return "location." + error;
                        }
                        if (message.text != null && message.hasOwnProperty("text"))
                            if (!$util.isString(message.text))
                                return "text: string expected";
                        return null;
                    };

                    /**
                     * Creates a Comment message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.GherkinDocument.Comment} Comment
                     */
                    Comment.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.GherkinDocument.Comment)
                            return object;
                        var message = new $root.io.cucumber.messages.GherkinDocument.Comment();
                        if (object.location != null) {
                            if (typeof object.location !== "object")
                                throw TypeError(".io.cucumber.messages.GherkinDocument.Comment.location: object expected");
                            message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                        }
                        if (object.text != null)
                            message.text = String(object.text);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Comment message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.Comment} message Comment
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Comment.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.location = null;
                            object.text = "";
                        }
                        if (message.location != null && message.hasOwnProperty("location"))
                            object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                        if (message.text != null && message.hasOwnProperty("text"))
                            object.text = message.text;
                        return object;
                    };

                    /**
                     * Converts this Comment to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Comment.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Comment;
                })();

                GherkinDocument.Feature = (function() {

                    /**
                     * Properties of a Feature.
                     * @memberof io.cucumber.messages.GherkinDocument
                     * @interface IFeature
                     * @property {io.cucumber.messages.ILocation|null} [location] Feature location
                     * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.ITag>|null} [tags] Feature tags
                     * @property {string|null} [language] Feature language
                     * @property {string|null} [keyword] Feature keyword
                     * @property {string|null} [name] Feature name
                     * @property {string|null} [description] Feature description
                     * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.IFeatureChild>|null} [children] Feature children
                     */

                    /**
                     * Constructs a new Feature.
                     * @memberof io.cucumber.messages.GherkinDocument
                     * @classdesc The top level node in the AST
                     * @implements IFeature
                     * @constructor
                     * @param {io.cucumber.messages.GherkinDocument.IFeature=} [properties] Properties to set
                     */
                    function Feature(properties) {
                        this.tags = [];
                        this.children = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Feature location.
                     * @member {io.cucumber.messages.ILocation|null|undefined} location
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     */
                    Feature.prototype.location = null;

                    /**
                     * Feature tags.
                     * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.ITag>} tags
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     */
                    Feature.prototype.tags = $util.emptyArray;

                    /**
                     * Feature language.
                     * @member {string} language
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     */
                    Feature.prototype.language = "";

                    /**
                     * Feature keyword.
                     * @member {string} keyword
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     */
                    Feature.prototype.keyword = "";

                    /**
                     * Feature name.
                     * @member {string} name
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     */
                    Feature.prototype.name = "";

                    /**
                     * Feature description.
                     * @member {string} description
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     */
                    Feature.prototype.description = "";

                    /**
                     * Feature children.
                     * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.IFeatureChild>} children
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     */
                    Feature.prototype.children = $util.emptyArray;

                    /**
                     * Creates a new Feature instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.IFeature=} [properties] Properties to set
                     * @returns {io.cucumber.messages.GherkinDocument.Feature} Feature instance
                     */
                    Feature.create = function create(properties) {
                        return new Feature(properties);
                    };

                    /**
                     * Encodes the specified Feature message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.IFeature} message Feature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Feature.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.location != null && message.hasOwnProperty("location"))
                            $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.tags != null && message.tags.length)
                            for (var i = 0; i < message.tags.length; ++i)
                                $root.io.cucumber.messages.GherkinDocument.Feature.Tag.encode(message.tags[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.language != null && message.hasOwnProperty("language"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.language);
                        if (message.keyword != null && message.hasOwnProperty("keyword"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.keyword);
                        if (message.name != null && message.hasOwnProperty("name"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
                        if (message.description != null && message.hasOwnProperty("description"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.description);
                        if (message.children != null && message.children.length)
                            for (var i = 0; i < message.children.length; ++i)
                                $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.encode(message.children[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Feature message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.IFeature} message Feature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Feature.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Feature message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.GherkinDocument.Feature} Feature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Feature.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                break;
                            case 2:
                                if (!(message.tags && message.tags.length))
                                    message.tags = [];
                                message.tags.push($root.io.cucumber.messages.GherkinDocument.Feature.Tag.decode(reader, reader.uint32()));
                                break;
                            case 3:
                                message.language = reader.string();
                                break;
                            case 4:
                                message.keyword = reader.string();
                                break;
                            case 5:
                                message.name = reader.string();
                                break;
                            case 6:
                                message.description = reader.string();
                                break;
                            case 7:
                                if (!(message.children && message.children.length))
                                    message.children = [];
                                message.children.push($root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Feature message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.GherkinDocument.Feature} Feature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Feature.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Feature message.
                     * @function verify
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Feature.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.location != null && message.hasOwnProperty("location")) {
                            var error = $root.io.cucumber.messages.Location.verify(message.location);
                            if (error)
                                return "location." + error;
                        }
                        if (message.tags != null && message.hasOwnProperty("tags")) {
                            if (!Array.isArray(message.tags))
                                return "tags: array expected";
                            for (var i = 0; i < message.tags.length; ++i) {
                                var error = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.verify(message.tags[i]);
                                if (error)
                                    return "tags." + error;
                            }
                        }
                        if (message.language != null && message.hasOwnProperty("language"))
                            if (!$util.isString(message.language))
                                return "language: string expected";
                        if (message.keyword != null && message.hasOwnProperty("keyword"))
                            if (!$util.isString(message.keyword))
                                return "keyword: string expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.description != null && message.hasOwnProperty("description"))
                            if (!$util.isString(message.description))
                                return "description: string expected";
                        if (message.children != null && message.hasOwnProperty("children")) {
                            if (!Array.isArray(message.children))
                                return "children: array expected";
                            for (var i = 0; i < message.children.length; ++i) {
                                var error = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.verify(message.children[i]);
                                if (error)
                                    return "children." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Feature message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.GherkinDocument.Feature} Feature
                     */
                    Feature.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature)
                            return object;
                        var message = new $root.io.cucumber.messages.GherkinDocument.Feature();
                        if (object.location != null) {
                            if (typeof object.location !== "object")
                                throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.location: object expected");
                            message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                        }
                        if (object.tags) {
                            if (!Array.isArray(object.tags))
                                throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.tags: array expected");
                            message.tags = [];
                            for (var i = 0; i < object.tags.length; ++i) {
                                if (typeof object.tags[i] !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.tags: object expected");
                                message.tags[i] = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.fromObject(object.tags[i]);
                            }
                        }
                        if (object.language != null)
                            message.language = String(object.language);
                        if (object.keyword != null)
                            message.keyword = String(object.keyword);
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.description != null)
                            message.description = String(object.description);
                        if (object.children) {
                            if (!Array.isArray(object.children))
                                throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.children: array expected");
                            message.children = [];
                            for (var i = 0; i < object.children.length; ++i) {
                                if (typeof object.children[i] !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.children: object expected");
                                message.children[i] = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.fromObject(object.children[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Feature message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.Feature} message Feature
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Feature.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.tags = [];
                            object.children = [];
                        }
                        if (options.defaults) {
                            object.location = null;
                            object.language = "";
                            object.keyword = "";
                            object.name = "";
                            object.description = "";
                        }
                        if (message.location != null && message.hasOwnProperty("location"))
                            object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                        if (message.tags && message.tags.length) {
                            object.tags = [];
                            for (var j = 0; j < message.tags.length; ++j)
                                object.tags[j] = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.toObject(message.tags[j], options);
                        }
                        if (message.language != null && message.hasOwnProperty("language"))
                            object.language = message.language;
                        if (message.keyword != null && message.hasOwnProperty("keyword"))
                            object.keyword = message.keyword;
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.description != null && message.hasOwnProperty("description"))
                            object.description = message.description;
                        if (message.children && message.children.length) {
                            object.children = [];
                            for (var j = 0; j < message.children.length; ++j)
                                object.children[j] = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.toObject(message.children[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Feature to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Feature.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Feature.Tag = (function() {

                        /**
                         * Properties of a Tag.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @interface ITag
                         * @property {io.cucumber.messages.ILocation|null} [location] Tag location
                         * @property {string|null} [name] Tag name
                         * @property {string|null} [id] Tag id
                         */

                        /**
                         * Constructs a new Tag.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @classdesc A tag
                         * @implements ITag
                         * @constructor
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITag=} [properties] Properties to set
                         */
                        function Tag(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Tag location.
                         * @member {io.cucumber.messages.ILocation|null|undefined} location
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @instance
                         */
                        Tag.prototype.location = null;

                        /**
                         * Tag name.
                         * @member {string} name
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @instance
                         */
                        Tag.prototype.name = "";

                        /**
                         * Tag id.
                         * @member {string} id
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @instance
                         */
                        Tag.prototype.id = "";

                        /**
                         * Creates a new Tag instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITag=} [properties] Properties to set
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Tag} Tag instance
                         */
                        Tag.create = function create(properties) {
                            return new Tag(properties);
                        };

                        /**
                         * Encodes the specified Tag message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Tag.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITag} message Tag message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Tag.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.location != null && message.hasOwnProperty("location"))
                                $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.name != null && message.hasOwnProperty("name"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                            if (message.id != null && message.hasOwnProperty("id"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.id);
                            return writer;
                        };

                        /**
                         * Encodes the specified Tag message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Tag.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITag} message Tag message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Tag.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Tag message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Tag} Tag
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Tag.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.Tag();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.name = reader.string();
                                    break;
                                case 3:
                                    message.id = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Tag message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Tag} Tag
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Tag.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Tag message.
                         * @function verify
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Tag.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.location != null && message.hasOwnProperty("location")) {
                                var error = $root.io.cucumber.messages.Location.verify(message.location);
                                if (error)
                                    return "location." + error;
                            }
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            if (message.id != null && message.hasOwnProperty("id"))
                                if (!$util.isString(message.id))
                                    return "id: string expected";
                            return null;
                        };

                        /**
                         * Creates a Tag message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Tag} Tag
                         */
                        Tag.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.Tag)
                                return object;
                            var message = new $root.io.cucumber.messages.GherkinDocument.Feature.Tag();
                            if (object.location != null) {
                                if (typeof object.location !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Tag.location: object expected");
                                message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                            }
                            if (object.name != null)
                                message.name = String(object.name);
                            if (object.id != null)
                                message.id = String(object.id);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Tag message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.Tag} message Tag
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Tag.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.location = null;
                                object.name = "";
                                object.id = "";
                            }
                            if (message.location != null && message.hasOwnProperty("location"))
                                object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            if (message.id != null && message.hasOwnProperty("id"))
                                object.id = message.id;
                            return object;
                        };

                        /**
                         * Converts this Tag to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Tag.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Tag;
                    })();

                    Feature.FeatureChild = (function() {

                        /**
                         * Properties of a FeatureChild.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @interface IFeatureChild
                         * @property {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRule|null} [rule] FeatureChild rule
                         * @property {io.cucumber.messages.GherkinDocument.Feature.IBackground|null} [background] FeatureChild background
                         * @property {io.cucumber.messages.GherkinDocument.Feature.IScenario|null} [scenario] FeatureChild scenario
                         */

                        /**
                         * Constructs a new FeatureChild.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @classdesc A child node of a `Feature` node
                         * @implements IFeatureChild
                         * @constructor
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IFeatureChild=} [properties] Properties to set
                         */
                        function FeatureChild(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * FeatureChild rule.
                         * @member {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRule|null|undefined} rule
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @instance
                         */
                        FeatureChild.prototype.rule = null;

                        /**
                         * FeatureChild background.
                         * @member {io.cucumber.messages.GherkinDocument.Feature.IBackground|null|undefined} background
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @instance
                         */
                        FeatureChild.prototype.background = null;

                        /**
                         * FeatureChild scenario.
                         * @member {io.cucumber.messages.GherkinDocument.Feature.IScenario|null|undefined} scenario
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @instance
                         */
                        FeatureChild.prototype.scenario = null;

                        // OneOf field names bound to virtual getters and setters
                        var $oneOfFields;

                        /**
                         * FeatureChild value.
                         * @member {"rule"|"background"|"scenario"|undefined} value
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @instance
                         */
                        Object.defineProperty(FeatureChild.prototype, "value", {
                            get: $util.oneOfGetter($oneOfFields = ["rule", "background", "scenario"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Creates a new FeatureChild instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IFeatureChild=} [properties] Properties to set
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild} FeatureChild instance
                         */
                        FeatureChild.create = function create(properties) {
                            return new FeatureChild(properties);
                        };

                        /**
                         * Encodes the specified FeatureChild message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.FeatureChild.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IFeatureChild} message FeatureChild message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FeatureChild.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.rule != null && message.hasOwnProperty("rule"))
                                $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.encode(message.rule, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.background != null && message.hasOwnProperty("background"))
                                $root.io.cucumber.messages.GherkinDocument.Feature.Background.encode(message.background, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.scenario != null && message.hasOwnProperty("scenario"))
                                $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.encode(message.scenario, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified FeatureChild message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.FeatureChild.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IFeatureChild} message FeatureChild message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FeatureChild.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a FeatureChild message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild} FeatureChild
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FeatureChild.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.rule = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.background = $root.io.cucumber.messages.GherkinDocument.Feature.Background.decode(reader, reader.uint32());
                                    break;
                                case 3:
                                    message.scenario = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a FeatureChild message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild} FeatureChild
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FeatureChild.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a FeatureChild message.
                         * @function verify
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        FeatureChild.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            var properties = {};
                            if (message.rule != null && message.hasOwnProperty("rule")) {
                                properties.value = 1;
                                {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.verify(message.rule);
                                    if (error)
                                        return "rule." + error;
                                }
                            }
                            if (message.background != null && message.hasOwnProperty("background")) {
                                if (properties.value === 1)
                                    return "value: multiple values";
                                properties.value = 1;
                                {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Background.verify(message.background);
                                    if (error)
                                        return "background." + error;
                                }
                            }
                            if (message.scenario != null && message.hasOwnProperty("scenario")) {
                                if (properties.value === 1)
                                    return "value: multiple values";
                                properties.value = 1;
                                {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.verify(message.scenario);
                                    if (error)
                                        return "scenario." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a FeatureChild message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild} FeatureChild
                         */
                        FeatureChild.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild)
                                return object;
                            var message = new $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild();
                            if (object.rule != null) {
                                if (typeof object.rule !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.rule: object expected");
                                message.rule = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.fromObject(object.rule);
                            }
                            if (object.background != null) {
                                if (typeof object.background !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.background: object expected");
                                message.background = $root.io.cucumber.messages.GherkinDocument.Feature.Background.fromObject(object.background);
                            }
                            if (object.scenario != null) {
                                if (typeof object.scenario !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.scenario: object expected");
                                message.scenario = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.fromObject(object.scenario);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a FeatureChild message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild} message FeatureChild
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        FeatureChild.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (message.rule != null && message.hasOwnProperty("rule")) {
                                object.rule = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.toObject(message.rule, options);
                                if (options.oneofs)
                                    object.value = "rule";
                            }
                            if (message.background != null && message.hasOwnProperty("background")) {
                                object.background = $root.io.cucumber.messages.GherkinDocument.Feature.Background.toObject(message.background, options);
                                if (options.oneofs)
                                    object.value = "background";
                            }
                            if (message.scenario != null && message.hasOwnProperty("scenario")) {
                                object.scenario = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.toObject(message.scenario, options);
                                if (options.oneofs)
                                    object.value = "scenario";
                            }
                            return object;
                        };

                        /**
                         * Converts this FeatureChild to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        FeatureChild.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        FeatureChild.Rule = (function() {

                            /**
                             * Properties of a Rule.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                             * @interface IRule
                             * @property {io.cucumber.messages.ILocation|null} [location] Rule location
                             * @property {string|null} [keyword] Rule keyword
                             * @property {string|null} [name] Rule name
                             * @property {string|null} [description] Rule description
                             * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRuleChild>|null} [children] Rule children
                             */

                            /**
                             * Constructs a new Rule.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                             * @classdesc A `Rule` node
                             * @implements IRule
                             * @constructor
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRule=} [properties] Properties to set
                             */
                            function Rule(properties) {
                                this.children = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Rule location.
                             * @member {io.cucumber.messages.ILocation|null|undefined} location
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @instance
                             */
                            Rule.prototype.location = null;

                            /**
                             * Rule keyword.
                             * @member {string} keyword
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @instance
                             */
                            Rule.prototype.keyword = "";

                            /**
                             * Rule name.
                             * @member {string} name
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @instance
                             */
                            Rule.prototype.name = "";

                            /**
                             * Rule description.
                             * @member {string} description
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @instance
                             */
                            Rule.prototype.description = "";

                            /**
                             * Rule children.
                             * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRuleChild>} children
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @instance
                             */
                            Rule.prototype.children = $util.emptyArray;

                            /**
                             * Creates a new Rule instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRule=} [properties] Properties to set
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule} Rule instance
                             */
                            Rule.create = function create(properties) {
                                return new Rule(properties);
                            };

                            /**
                             * Encodes the specified Rule message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRule} message Rule message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Rule.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.location != null && message.hasOwnProperty("location"))
                                    $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.keyword != null && message.hasOwnProperty("keyword"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyword);
                                if (message.name != null && message.hasOwnProperty("name"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                                if (message.description != null && message.hasOwnProperty("description"))
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                                if (message.children != null && message.children.length)
                                    for (var i = 0; i < message.children.length; ++i)
                                        $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.encode(message.children[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Rule message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRule} message Rule message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Rule.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Rule message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule} Rule
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Rule.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        message.keyword = reader.string();
                                        break;
                                    case 3:
                                        message.name = reader.string();
                                        break;
                                    case 4:
                                        message.description = reader.string();
                                        break;
                                    case 5:
                                        if (!(message.children && message.children.length))
                                            message.children = [];
                                        message.children.push($root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.decode(reader, reader.uint32()));
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Rule message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule} Rule
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Rule.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Rule message.
                             * @function verify
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Rule.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.location != null && message.hasOwnProperty("location")) {
                                    var error = $root.io.cucumber.messages.Location.verify(message.location);
                                    if (error)
                                        return "location." + error;
                                }
                                if (message.keyword != null && message.hasOwnProperty("keyword"))
                                    if (!$util.isString(message.keyword))
                                        return "keyword: string expected";
                                if (message.name != null && message.hasOwnProperty("name"))
                                    if (!$util.isString(message.name))
                                        return "name: string expected";
                                if (message.description != null && message.hasOwnProperty("description"))
                                    if (!$util.isString(message.description))
                                        return "description: string expected";
                                if (message.children != null && message.hasOwnProperty("children")) {
                                    if (!Array.isArray(message.children))
                                        return "children: array expected";
                                    for (var i = 0; i < message.children.length; ++i) {
                                        var error = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.verify(message.children[i]);
                                        if (error)
                                            return "children." + error;
                                    }
                                }
                                return null;
                            };

                            /**
                             * Creates a Rule message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule} Rule
                             */
                            Rule.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule)
                                    return object;
                                var message = new $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule();
                                if (object.location != null) {
                                    if (typeof object.location !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.location: object expected");
                                    message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                                }
                                if (object.keyword != null)
                                    message.keyword = String(object.keyword);
                                if (object.name != null)
                                    message.name = String(object.name);
                                if (object.description != null)
                                    message.description = String(object.description);
                                if (object.children) {
                                    if (!Array.isArray(object.children))
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.children: array expected");
                                    message.children = [];
                                    for (var i = 0; i < object.children.length; ++i) {
                                        if (typeof object.children[i] !== "object")
                                            throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.children: object expected");
                                        message.children[i] = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.fromObject(object.children[i]);
                                    }
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Rule message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule} message Rule
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Rule.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.arrays || options.defaults)
                                    object.children = [];
                                if (options.defaults) {
                                    object.location = null;
                                    object.keyword = "";
                                    object.name = "";
                                    object.description = "";
                                }
                                if (message.location != null && message.hasOwnProperty("location"))
                                    object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                                if (message.keyword != null && message.hasOwnProperty("keyword"))
                                    object.keyword = message.keyword;
                                if (message.name != null && message.hasOwnProperty("name"))
                                    object.name = message.name;
                                if (message.description != null && message.hasOwnProperty("description"))
                                    object.description = message.description;
                                if (message.children && message.children.length) {
                                    object.children = [];
                                    for (var j = 0; j < message.children.length; ++j)
                                        object.children[j] = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.toObject(message.children[j], options);
                                }
                                return object;
                            };

                            /**
                             * Converts this Rule to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Rule.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Rule;
                        })();

                        FeatureChild.RuleChild = (function() {

                            /**
                             * Properties of a RuleChild.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                             * @interface IRuleChild
                             * @property {io.cucumber.messages.GherkinDocument.Feature.IBackground|null} [background] RuleChild background
                             * @property {io.cucumber.messages.GherkinDocument.Feature.IScenario|null} [scenario] RuleChild scenario
                             */

                            /**
                             * Constructs a new RuleChild.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                             * @classdesc Represents a RuleChild.
                             * @implements IRuleChild
                             * @constructor
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRuleChild=} [properties] Properties to set
                             */
                            function RuleChild(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * RuleChild background.
                             * @member {io.cucumber.messages.GherkinDocument.Feature.IBackground|null|undefined} background
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @instance
                             */
                            RuleChild.prototype.background = null;

                            /**
                             * RuleChild scenario.
                             * @member {io.cucumber.messages.GherkinDocument.Feature.IScenario|null|undefined} scenario
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @instance
                             */
                            RuleChild.prototype.scenario = null;

                            // OneOf field names bound to virtual getters and setters
                            var $oneOfFields;

                            /**
                             * RuleChild value.
                             * @member {"background"|"scenario"|undefined} value
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @instance
                             */
                            Object.defineProperty(RuleChild.prototype, "value", {
                                get: $util.oneOfGetter($oneOfFields = ["background", "scenario"]),
                                set: $util.oneOfSetter($oneOfFields)
                            });

                            /**
                             * Creates a new RuleChild instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRuleChild=} [properties] Properties to set
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild} RuleChild instance
                             */
                            RuleChild.create = function create(properties) {
                                return new RuleChild(properties);
                            };

                            /**
                             * Encodes the specified RuleChild message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRuleChild} message RuleChild message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            RuleChild.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.background != null && message.hasOwnProperty("background"))
                                    $root.io.cucumber.messages.GherkinDocument.Feature.Background.encode(message.background, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.scenario != null && message.hasOwnProperty("scenario"))
                                    $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.encode(message.scenario, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified RuleChild message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRuleChild} message RuleChild message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            RuleChild.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a RuleChild message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild} RuleChild
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            RuleChild.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.background = $root.io.cucumber.messages.GherkinDocument.Feature.Background.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        message.scenario = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a RuleChild message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild} RuleChild
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            RuleChild.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a RuleChild message.
                             * @function verify
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            RuleChild.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                var properties = {};
                                if (message.background != null && message.hasOwnProperty("background")) {
                                    properties.value = 1;
                                    {
                                        var error = $root.io.cucumber.messages.GherkinDocument.Feature.Background.verify(message.background);
                                        if (error)
                                            return "background." + error;
                                    }
                                }
                                if (message.scenario != null && message.hasOwnProperty("scenario")) {
                                    if (properties.value === 1)
                                        return "value: multiple values";
                                    properties.value = 1;
                                    {
                                        var error = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.verify(message.scenario);
                                        if (error)
                                            return "scenario." + error;
                                    }
                                }
                                return null;
                            };

                            /**
                             * Creates a RuleChild message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild} RuleChild
                             */
                            RuleChild.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild)
                                    return object;
                                var message = new $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild();
                                if (object.background != null) {
                                    if (typeof object.background !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.background: object expected");
                                    message.background = $root.io.cucumber.messages.GherkinDocument.Feature.Background.fromObject(object.background);
                                }
                                if (object.scenario != null) {
                                    if (typeof object.scenario !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.scenario: object expected");
                                    message.scenario = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.fromObject(object.scenario);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a RuleChild message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild} message RuleChild
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            RuleChild.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (message.background != null && message.hasOwnProperty("background")) {
                                    object.background = $root.io.cucumber.messages.GherkinDocument.Feature.Background.toObject(message.background, options);
                                    if (options.oneofs)
                                        object.value = "background";
                                }
                                if (message.scenario != null && message.hasOwnProperty("scenario")) {
                                    object.scenario = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.toObject(message.scenario, options);
                                    if (options.oneofs)
                                        object.value = "scenario";
                                }
                                return object;
                            };

                            /**
                             * Converts this RuleChild to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            RuleChild.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return RuleChild;
                        })();

                        return FeatureChild;
                    })();

                    Feature.Background = (function() {

                        /**
                         * Properties of a Background.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @interface IBackground
                         * @property {io.cucumber.messages.ILocation|null} [location] Background location
                         * @property {string|null} [keyword] Background keyword
                         * @property {string|null} [name] Background name
                         * @property {string|null} [description] Background description
                         * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.IStep>|null} [steps] Background steps
                         */

                        /**
                         * Constructs a new Background.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @classdesc Represents a Background.
                         * @implements IBackground
                         * @constructor
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IBackground=} [properties] Properties to set
                         */
                        function Background(properties) {
                            this.steps = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Background location.
                         * @member {io.cucumber.messages.ILocation|null|undefined} location
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @instance
                         */
                        Background.prototype.location = null;

                        /**
                         * Background keyword.
                         * @member {string} keyword
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @instance
                         */
                        Background.prototype.keyword = "";

                        /**
                         * Background name.
                         * @member {string} name
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @instance
                         */
                        Background.prototype.name = "";

                        /**
                         * Background description.
                         * @member {string} description
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @instance
                         */
                        Background.prototype.description = "";

                        /**
                         * Background steps.
                         * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.IStep>} steps
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @instance
                         */
                        Background.prototype.steps = $util.emptyArray;

                        /**
                         * Creates a new Background instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IBackground=} [properties] Properties to set
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Background} Background instance
                         */
                        Background.create = function create(properties) {
                            return new Background(properties);
                        };

                        /**
                         * Encodes the specified Background message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Background.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IBackground} message Background message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Background.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.location != null && message.hasOwnProperty("location"))
                                $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyword);
                            if (message.name != null && message.hasOwnProperty("name"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                            if (message.steps != null && message.steps.length)
                                for (var i = 0; i < message.steps.length; ++i)
                                    $root.io.cucumber.messages.GherkinDocument.Feature.Step.encode(message.steps[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Background message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Background.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IBackground} message Background message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Background.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Background message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Background} Background
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Background.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.Background();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.keyword = reader.string();
                                    break;
                                case 3:
                                    message.name = reader.string();
                                    break;
                                case 4:
                                    message.description = reader.string();
                                    break;
                                case 5:
                                    if (!(message.steps && message.steps.length))
                                        message.steps = [];
                                    message.steps.push($root.io.cucumber.messages.GherkinDocument.Feature.Step.decode(reader, reader.uint32()));
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Background message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Background} Background
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Background.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Background message.
                         * @function verify
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Background.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.location != null && message.hasOwnProperty("location")) {
                                var error = $root.io.cucumber.messages.Location.verify(message.location);
                                if (error)
                                    return "location." + error;
                            }
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                if (!$util.isString(message.keyword))
                                    return "keyword: string expected";
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            if (message.steps != null && message.hasOwnProperty("steps")) {
                                if (!Array.isArray(message.steps))
                                    return "steps: array expected";
                                for (var i = 0; i < message.steps.length; ++i) {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Step.verify(message.steps[i]);
                                    if (error)
                                        return "steps." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Background message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Background} Background
                         */
                        Background.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.Background)
                                return object;
                            var message = new $root.io.cucumber.messages.GherkinDocument.Feature.Background();
                            if (object.location != null) {
                                if (typeof object.location !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Background.location: object expected");
                                message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                            }
                            if (object.keyword != null)
                                message.keyword = String(object.keyword);
                            if (object.name != null)
                                message.name = String(object.name);
                            if (object.description != null)
                                message.description = String(object.description);
                            if (object.steps) {
                                if (!Array.isArray(object.steps))
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Background.steps: array expected");
                                message.steps = [];
                                for (var i = 0; i < object.steps.length; ++i) {
                                    if (typeof object.steps[i] !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Background.steps: object expected");
                                    message.steps[i] = $root.io.cucumber.messages.GherkinDocument.Feature.Step.fromObject(object.steps[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Background message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.Background} message Background
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Background.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.steps = [];
                            if (options.defaults) {
                                object.location = null;
                                object.keyword = "";
                                object.name = "";
                                object.description = "";
                            }
                            if (message.location != null && message.hasOwnProperty("location"))
                                object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                object.keyword = message.keyword;
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            if (message.steps && message.steps.length) {
                                object.steps = [];
                                for (var j = 0; j < message.steps.length; ++j)
                                    object.steps[j] = $root.io.cucumber.messages.GherkinDocument.Feature.Step.toObject(message.steps[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Background to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Background.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Background;
                    })();

                    Feature.Scenario = (function() {

                        /**
                         * Properties of a Scenario.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @interface IScenario
                         * @property {io.cucumber.messages.ILocation|null} [location] Scenario location
                         * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.ITag>|null} [tags] Scenario tags
                         * @property {string|null} [keyword] Scenario keyword
                         * @property {string|null} [name] Scenario name
                         * @property {string|null} [description] Scenario description
                         * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.IStep>|null} [steps] Scenario steps
                         * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.Scenario.IExamples>|null} [examples] Scenario examples
                         * @property {string|null} [id] Scenario id
                         */

                        /**
                         * Constructs a new Scenario.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @classdesc Represents a Scenario.
                         * @implements IScenario
                         * @constructor
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IScenario=} [properties] Properties to set
                         */
                        function Scenario(properties) {
                            this.tags = [];
                            this.steps = [];
                            this.examples = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Scenario location.
                         * @member {io.cucumber.messages.ILocation|null|undefined} location
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.location = null;

                        /**
                         * Scenario tags.
                         * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.ITag>} tags
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.tags = $util.emptyArray;

                        /**
                         * Scenario keyword.
                         * @member {string} keyword
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.keyword = "";

                        /**
                         * Scenario name.
                         * @member {string} name
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.name = "";

                        /**
                         * Scenario description.
                         * @member {string} description
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.description = "";

                        /**
                         * Scenario steps.
                         * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.IStep>} steps
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.steps = $util.emptyArray;

                        /**
                         * Scenario examples.
                         * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.Scenario.IExamples>} examples
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.examples = $util.emptyArray;

                        /**
                         * Scenario id.
                         * @member {string} id
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.id = "";

                        /**
                         * Creates a new Scenario instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IScenario=} [properties] Properties to set
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario} Scenario instance
                         */
                        Scenario.create = function create(properties) {
                            return new Scenario(properties);
                        };

                        /**
                         * Encodes the specified Scenario message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Scenario.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IScenario} message Scenario message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Scenario.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.location != null && message.hasOwnProperty("location"))
                                $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.tags != null && message.tags.length)
                                for (var i = 0; i < message.tags.length; ++i)
                                    $root.io.cucumber.messages.GherkinDocument.Feature.Tag.encode(message.tags[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.keyword);
                            if (message.name != null && message.hasOwnProperty("name"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                            if (message.steps != null && message.steps.length)
                                for (var i = 0; i < message.steps.length; ++i)
                                    $root.io.cucumber.messages.GherkinDocument.Feature.Step.encode(message.steps[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                            if (message.examples != null && message.examples.length)
                                for (var i = 0; i < message.examples.length; ++i)
                                    $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.encode(message.examples[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                            if (message.id != null && message.hasOwnProperty("id"))
                                writer.uint32(/* id 8, wireType 2 =*/66).string(message.id);
                            return writer;
                        };

                        /**
                         * Encodes the specified Scenario message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Scenario.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IScenario} message Scenario message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Scenario.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Scenario message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario} Scenario
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Scenario.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.Scenario();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    if (!(message.tags && message.tags.length))
                                        message.tags = [];
                                    message.tags.push($root.io.cucumber.messages.GherkinDocument.Feature.Tag.decode(reader, reader.uint32()));
                                    break;
                                case 3:
                                    message.keyword = reader.string();
                                    break;
                                case 4:
                                    message.name = reader.string();
                                    break;
                                case 5:
                                    message.description = reader.string();
                                    break;
                                case 6:
                                    if (!(message.steps && message.steps.length))
                                        message.steps = [];
                                    message.steps.push($root.io.cucumber.messages.GherkinDocument.Feature.Step.decode(reader, reader.uint32()));
                                    break;
                                case 7:
                                    if (!(message.examples && message.examples.length))
                                        message.examples = [];
                                    message.examples.push($root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.decode(reader, reader.uint32()));
                                    break;
                                case 8:
                                    message.id = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Scenario message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario} Scenario
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Scenario.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Scenario message.
                         * @function verify
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Scenario.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.location != null && message.hasOwnProperty("location")) {
                                var error = $root.io.cucumber.messages.Location.verify(message.location);
                                if (error)
                                    return "location." + error;
                            }
                            if (message.tags != null && message.hasOwnProperty("tags")) {
                                if (!Array.isArray(message.tags))
                                    return "tags: array expected";
                                for (var i = 0; i < message.tags.length; ++i) {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.verify(message.tags[i]);
                                    if (error)
                                        return "tags." + error;
                                }
                            }
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                if (!$util.isString(message.keyword))
                                    return "keyword: string expected";
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            if (message.steps != null && message.hasOwnProperty("steps")) {
                                if (!Array.isArray(message.steps))
                                    return "steps: array expected";
                                for (var i = 0; i < message.steps.length; ++i) {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Step.verify(message.steps[i]);
                                    if (error)
                                        return "steps." + error;
                                }
                            }
                            if (message.examples != null && message.hasOwnProperty("examples")) {
                                if (!Array.isArray(message.examples))
                                    return "examples: array expected";
                                for (var i = 0; i < message.examples.length; ++i) {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.verify(message.examples[i]);
                                    if (error)
                                        return "examples." + error;
                                }
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                if (!$util.isString(message.id))
                                    return "id: string expected";
                            return null;
                        };

                        /**
                         * Creates a Scenario message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario} Scenario
                         */
                        Scenario.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.Scenario)
                                return object;
                            var message = new $root.io.cucumber.messages.GherkinDocument.Feature.Scenario();
                            if (object.location != null) {
                                if (typeof object.location !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.location: object expected");
                                message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                            }
                            if (object.tags) {
                                if (!Array.isArray(object.tags))
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.tags: array expected");
                                message.tags = [];
                                for (var i = 0; i < object.tags.length; ++i) {
                                    if (typeof object.tags[i] !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.tags: object expected");
                                    message.tags[i] = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.fromObject(object.tags[i]);
                                }
                            }
                            if (object.keyword != null)
                                message.keyword = String(object.keyword);
                            if (object.name != null)
                                message.name = String(object.name);
                            if (object.description != null)
                                message.description = String(object.description);
                            if (object.steps) {
                                if (!Array.isArray(object.steps))
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.steps: array expected");
                                message.steps = [];
                                for (var i = 0; i < object.steps.length; ++i) {
                                    if (typeof object.steps[i] !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.steps: object expected");
                                    message.steps[i] = $root.io.cucumber.messages.GherkinDocument.Feature.Step.fromObject(object.steps[i]);
                                }
                            }
                            if (object.examples) {
                                if (!Array.isArray(object.examples))
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.examples: array expected");
                                message.examples = [];
                                for (var i = 0; i < object.examples.length; ++i) {
                                    if (typeof object.examples[i] !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.examples: object expected");
                                    message.examples[i] = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.fromObject(object.examples[i]);
                                }
                            }
                            if (object.id != null)
                                message.id = String(object.id);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Scenario message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.Scenario} message Scenario
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Scenario.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults) {
                                object.tags = [];
                                object.steps = [];
                                object.examples = [];
                            }
                            if (options.defaults) {
                                object.location = null;
                                object.keyword = "";
                                object.name = "";
                                object.description = "";
                                object.id = "";
                            }
                            if (message.location != null && message.hasOwnProperty("location"))
                                object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                            if (message.tags && message.tags.length) {
                                object.tags = [];
                                for (var j = 0; j < message.tags.length; ++j)
                                    object.tags[j] = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.toObject(message.tags[j], options);
                            }
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                object.keyword = message.keyword;
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            if (message.steps && message.steps.length) {
                                object.steps = [];
                                for (var j = 0; j < message.steps.length; ++j)
                                    object.steps[j] = $root.io.cucumber.messages.GherkinDocument.Feature.Step.toObject(message.steps[j], options);
                            }
                            if (message.examples && message.examples.length) {
                                object.examples = [];
                                for (var j = 0; j < message.examples.length; ++j)
                                    object.examples[j] = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.toObject(message.examples[j], options);
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                object.id = message.id;
                            return object;
                        };

                        /**
                         * Converts this Scenario to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Scenario.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Scenario.Examples = (function() {

                            /**
                             * Properties of an Examples.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                             * @interface IExamples
                             * @property {io.cucumber.messages.ILocation|null} [location] Examples location
                             * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.ITag>|null} [tags] Examples tags
                             * @property {string|null} [keyword] Examples keyword
                             * @property {string|null} [name] Examples name
                             * @property {string|null} [description] Examples description
                             * @property {io.cucumber.messages.GherkinDocument.Feature.ITableRow|null} [tableHeader] Examples tableHeader
                             * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.ITableRow>|null} [tableBody] Examples tableBody
                             */

                            /**
                             * Constructs a new Examples.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                             * @classdesc Represents an Examples.
                             * @implements IExamples
                             * @constructor
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Scenario.IExamples=} [properties] Properties to set
                             */
                            function Examples(properties) {
                                this.tags = [];
                                this.tableBody = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Examples location.
                             * @member {io.cucumber.messages.ILocation|null|undefined} location
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.location = null;

                            /**
                             * Examples tags.
                             * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.ITag>} tags
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.tags = $util.emptyArray;

                            /**
                             * Examples keyword.
                             * @member {string} keyword
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.keyword = "";

                            /**
                             * Examples name.
                             * @member {string} name
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.name = "";

                            /**
                             * Examples description.
                             * @member {string} description
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.description = "";

                            /**
                             * Examples tableHeader.
                             * @member {io.cucumber.messages.GherkinDocument.Feature.ITableRow|null|undefined} tableHeader
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.tableHeader = null;

                            /**
                             * Examples tableBody.
                             * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.ITableRow>} tableBody
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.tableBody = $util.emptyArray;

                            /**
                             * Creates a new Examples instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Scenario.IExamples=} [properties] Properties to set
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples} Examples instance
                             */
                            Examples.create = function create(properties) {
                                return new Examples(properties);
                            };

                            /**
                             * Encodes the specified Examples message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Scenario.IExamples} message Examples message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Examples.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.location != null && message.hasOwnProperty("location"))
                                    $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.tags != null && message.tags.length)
                                    for (var i = 0; i < message.tags.length; ++i)
                                        $root.io.cucumber.messages.GherkinDocument.Feature.Tag.encode(message.tags[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                                if (message.keyword != null && message.hasOwnProperty("keyword"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.keyword);
                                if (message.name != null && message.hasOwnProperty("name"))
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                                if (message.description != null && message.hasOwnProperty("description"))
                                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                                if (message.tableHeader != null && message.hasOwnProperty("tableHeader"))
                                    $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.encode(message.tableHeader, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                                if (message.tableBody != null && message.tableBody.length)
                                    for (var i = 0; i < message.tableBody.length; ++i)
                                        $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.encode(message.tableBody[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Examples message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Scenario.IExamples} message Examples message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Examples.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes an Examples message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples} Examples
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Examples.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        if (!(message.tags && message.tags.length))
                                            message.tags = [];
                                        message.tags.push($root.io.cucumber.messages.GherkinDocument.Feature.Tag.decode(reader, reader.uint32()));
                                        break;
                                    case 3:
                                        message.keyword = reader.string();
                                        break;
                                    case 4:
                                        message.name = reader.string();
                                        break;
                                    case 5:
                                        message.description = reader.string();
                                        break;
                                    case 6:
                                        message.tableHeader = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.decode(reader, reader.uint32());
                                        break;
                                    case 7:
                                        if (!(message.tableBody && message.tableBody.length))
                                            message.tableBody = [];
                                        message.tableBody.push($root.io.cucumber.messages.GherkinDocument.Feature.TableRow.decode(reader, reader.uint32()));
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes an Examples message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples} Examples
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Examples.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies an Examples message.
                             * @function verify
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Examples.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.location != null && message.hasOwnProperty("location")) {
                                    var error = $root.io.cucumber.messages.Location.verify(message.location);
                                    if (error)
                                        return "location." + error;
                                }
                                if (message.tags != null && message.hasOwnProperty("tags")) {
                                    if (!Array.isArray(message.tags))
                                        return "tags: array expected";
                                    for (var i = 0; i < message.tags.length; ++i) {
                                        var error = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.verify(message.tags[i]);
                                        if (error)
                                            return "tags." + error;
                                    }
                                }
                                if (message.keyword != null && message.hasOwnProperty("keyword"))
                                    if (!$util.isString(message.keyword))
                                        return "keyword: string expected";
                                if (message.name != null && message.hasOwnProperty("name"))
                                    if (!$util.isString(message.name))
                                        return "name: string expected";
                                if (message.description != null && message.hasOwnProperty("description"))
                                    if (!$util.isString(message.description))
                                        return "description: string expected";
                                if (message.tableHeader != null && message.hasOwnProperty("tableHeader")) {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.verify(message.tableHeader);
                                    if (error)
                                        return "tableHeader." + error;
                                }
                                if (message.tableBody != null && message.hasOwnProperty("tableBody")) {
                                    if (!Array.isArray(message.tableBody))
                                        return "tableBody: array expected";
                                    for (var i = 0; i < message.tableBody.length; ++i) {
                                        var error = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.verify(message.tableBody[i]);
                                        if (error)
                                            return "tableBody." + error;
                                    }
                                }
                                return null;
                            };

                            /**
                             * Creates an Examples message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples} Examples
                             */
                            Examples.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples)
                                    return object;
                                var message = new $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples();
                                if (object.location != null) {
                                    if (typeof object.location !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.location: object expected");
                                    message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                                }
                                if (object.tags) {
                                    if (!Array.isArray(object.tags))
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.tags: array expected");
                                    message.tags = [];
                                    for (var i = 0; i < object.tags.length; ++i) {
                                        if (typeof object.tags[i] !== "object")
                                            throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.tags: object expected");
                                        message.tags[i] = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.fromObject(object.tags[i]);
                                    }
                                }
                                if (object.keyword != null)
                                    message.keyword = String(object.keyword);
                                if (object.name != null)
                                    message.name = String(object.name);
                                if (object.description != null)
                                    message.description = String(object.description);
                                if (object.tableHeader != null) {
                                    if (typeof object.tableHeader !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.tableHeader: object expected");
                                    message.tableHeader = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.fromObject(object.tableHeader);
                                }
                                if (object.tableBody) {
                                    if (!Array.isArray(object.tableBody))
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.tableBody: array expected");
                                    message.tableBody = [];
                                    for (var i = 0; i < object.tableBody.length; ++i) {
                                        if (typeof object.tableBody[i] !== "object")
                                            throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.tableBody: object expected");
                                        message.tableBody[i] = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.fromObject(object.tableBody[i]);
                                    }
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from an Examples message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples} message Examples
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Examples.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.arrays || options.defaults) {
                                    object.tags = [];
                                    object.tableBody = [];
                                }
                                if (options.defaults) {
                                    object.location = null;
                                    object.keyword = "";
                                    object.name = "";
                                    object.description = "";
                                    object.tableHeader = null;
                                }
                                if (message.location != null && message.hasOwnProperty("location"))
                                    object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                                if (message.tags && message.tags.length) {
                                    object.tags = [];
                                    for (var j = 0; j < message.tags.length; ++j)
                                        object.tags[j] = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.toObject(message.tags[j], options);
                                }
                                if (message.keyword != null && message.hasOwnProperty("keyword"))
                                    object.keyword = message.keyword;
                                if (message.name != null && message.hasOwnProperty("name"))
                                    object.name = message.name;
                                if (message.description != null && message.hasOwnProperty("description"))
                                    object.description = message.description;
                                if (message.tableHeader != null && message.hasOwnProperty("tableHeader"))
                                    object.tableHeader = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.toObject(message.tableHeader, options);
                                if (message.tableBody && message.tableBody.length) {
                                    object.tableBody = [];
                                    for (var j = 0; j < message.tableBody.length; ++j)
                                        object.tableBody[j] = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.toObject(message.tableBody[j], options);
                                }
                                return object;
                            };

                            /**
                             * Converts this Examples to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Examples.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Examples;
                        })();

                        return Scenario;
                    })();

                    Feature.TableRow = (function() {

                        /**
                         * Properties of a TableRow.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @interface ITableRow
                         * @property {io.cucumber.messages.ILocation|null} [location] TableRow location
                         * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.TableRow.ITableCell>|null} [cells] TableRow cells
                         * @property {string|null} [id] TableRow id
                         */

                        /**
                         * Constructs a new TableRow.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @classdesc Represents a TableRow.
                         * @implements ITableRow
                         * @constructor
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITableRow=} [properties] Properties to set
                         */
                        function TableRow(properties) {
                            this.cells = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * TableRow location.
                         * @member {io.cucumber.messages.ILocation|null|undefined} location
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @instance
                         */
                        TableRow.prototype.location = null;

                        /**
                         * TableRow cells.
                         * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.TableRow.ITableCell>} cells
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @instance
                         */
                        TableRow.prototype.cells = $util.emptyArray;

                        /**
                         * TableRow id.
                         * @member {string} id
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @instance
                         */
                        TableRow.prototype.id = "";

                        /**
                         * Creates a new TableRow instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITableRow=} [properties] Properties to set
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow} TableRow instance
                         */
                        TableRow.create = function create(properties) {
                            return new TableRow(properties);
                        };

                        /**
                         * Encodes the specified TableRow message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.TableRow.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITableRow} message TableRow message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        TableRow.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.location != null && message.hasOwnProperty("location"))
                                $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.cells != null && message.cells.length)
                                for (var i = 0; i < message.cells.length; ++i)
                                    $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.encode(message.cells[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.id != null && message.hasOwnProperty("id"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.id);
                            return writer;
                        };

                        /**
                         * Encodes the specified TableRow message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.TableRow.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITableRow} message TableRow message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        TableRow.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a TableRow message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow} TableRow
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        TableRow.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.TableRow();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    if (!(message.cells && message.cells.length))
                                        message.cells = [];
                                    message.cells.push($root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.decode(reader, reader.uint32()));
                                    break;
                                case 3:
                                    message.id = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a TableRow message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow} TableRow
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        TableRow.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a TableRow message.
                         * @function verify
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        TableRow.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.location != null && message.hasOwnProperty("location")) {
                                var error = $root.io.cucumber.messages.Location.verify(message.location);
                                if (error)
                                    return "location." + error;
                            }
                            if (message.cells != null && message.hasOwnProperty("cells")) {
                                if (!Array.isArray(message.cells))
                                    return "cells: array expected";
                                for (var i = 0; i < message.cells.length; ++i) {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.verify(message.cells[i]);
                                    if (error)
                                        return "cells." + error;
                                }
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                if (!$util.isString(message.id))
                                    return "id: string expected";
                            return null;
                        };

                        /**
                         * Creates a TableRow message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow} TableRow
                         */
                        TableRow.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.TableRow)
                                return object;
                            var message = new $root.io.cucumber.messages.GherkinDocument.Feature.TableRow();
                            if (object.location != null) {
                                if (typeof object.location !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.TableRow.location: object expected");
                                message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                            }
                            if (object.cells) {
                                if (!Array.isArray(object.cells))
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.TableRow.cells: array expected");
                                message.cells = [];
                                for (var i = 0; i < object.cells.length; ++i) {
                                    if (typeof object.cells[i] !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.TableRow.cells: object expected");
                                    message.cells[i] = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.fromObject(object.cells[i]);
                                }
                            }
                            if (object.id != null)
                                message.id = String(object.id);
                            return message;
                        };

                        /**
                         * Creates a plain object from a TableRow message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.TableRow} message TableRow
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        TableRow.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.cells = [];
                            if (options.defaults) {
                                object.location = null;
                                object.id = "";
                            }
                            if (message.location != null && message.hasOwnProperty("location"))
                                object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                            if (message.cells && message.cells.length) {
                                object.cells = [];
                                for (var j = 0; j < message.cells.length; ++j)
                                    object.cells[j] = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.toObject(message.cells[j], options);
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                object.id = message.id;
                            return object;
                        };

                        /**
                         * Converts this TableRow to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        TableRow.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        TableRow.TableCell = (function() {

                            /**
                             * Properties of a TableCell.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                             * @interface ITableCell
                             * @property {io.cucumber.messages.ILocation|null} [location] TableCell location
                             * @property {string|null} [value] TableCell value
                             */

                            /**
                             * Constructs a new TableCell.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                             * @classdesc Represents a TableCell.
                             * @implements ITableCell
                             * @constructor
                             * @param {io.cucumber.messages.GherkinDocument.Feature.TableRow.ITableCell=} [properties] Properties to set
                             */
                            function TableCell(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * TableCell location.
                             * @member {io.cucumber.messages.ILocation|null|undefined} location
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @instance
                             */
                            TableCell.prototype.location = null;

                            /**
                             * TableCell value.
                             * @member {string} value
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @instance
                             */
                            TableCell.prototype.value = "";

                            /**
                             * Creates a new TableCell instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.TableRow.ITableCell=} [properties] Properties to set
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell} TableCell instance
                             */
                            TableCell.create = function create(properties) {
                                return new TableCell(properties);
                            };

                            /**
                             * Encodes the specified TableCell message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.TableRow.ITableCell} message TableCell message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TableCell.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.location != null && message.hasOwnProperty("location"))
                                    $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.value != null && message.hasOwnProperty("value"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                                return writer;
                            };

                            /**
                             * Encodes the specified TableCell message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.TableRow.ITableCell} message TableCell message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TableCell.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a TableCell message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell} TableCell
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TableCell.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        message.value = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a TableCell message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell} TableCell
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TableCell.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a TableCell message.
                             * @function verify
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            TableCell.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.location != null && message.hasOwnProperty("location")) {
                                    var error = $root.io.cucumber.messages.Location.verify(message.location);
                                    if (error)
                                        return "location." + error;
                                }
                                if (message.value != null && message.hasOwnProperty("value"))
                                    if (!$util.isString(message.value))
                                        return "value: string expected";
                                return null;
                            };

                            /**
                             * Creates a TableCell message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell} TableCell
                             */
                            TableCell.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell)
                                    return object;
                                var message = new $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell();
                                if (object.location != null) {
                                    if (typeof object.location !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.location: object expected");
                                    message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                                }
                                if (object.value != null)
                                    message.value = String(object.value);
                                return message;
                            };

                            /**
                             * Creates a plain object from a TableCell message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell} message TableCell
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            TableCell.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.location = null;
                                    object.value = "";
                                }
                                if (message.location != null && message.hasOwnProperty("location"))
                                    object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                                if (message.value != null && message.hasOwnProperty("value"))
                                    object.value = message.value;
                                return object;
                            };

                            /**
                             * Converts this TableCell to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            TableCell.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return TableCell;
                        })();

                        return TableRow;
                    })();

                    Feature.Step = (function() {

                        /**
                         * Properties of a Step.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @interface IStep
                         * @property {io.cucumber.messages.ILocation|null} [location] Step location
                         * @property {string|null} [keyword] Step keyword
                         * @property {string|null} [text] Step text
                         * @property {io.cucumber.messages.GherkinDocument.Feature.Step.IDocString|null} [docString] Step docString
                         * @property {io.cucumber.messages.GherkinDocument.Feature.Step.IDataTable|null} [dataTable] Step dataTable
                         * @property {string|null} [id] Step id
                         */

                        /**
                         * Constructs a new Step.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @classdesc Represents a Step.
                         * @implements IStep
                         * @constructor
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IStep=} [properties] Properties to set
                         */
                        function Step(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Step location.
                         * @member {io.cucumber.messages.ILocation|null|undefined} location
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         */
                        Step.prototype.location = null;

                        /**
                         * Step keyword.
                         * @member {string} keyword
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         */
                        Step.prototype.keyword = "";

                        /**
                         * Step text.
                         * @member {string} text
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         */
                        Step.prototype.text = "";

                        /**
                         * Step docString.
                         * @member {io.cucumber.messages.GherkinDocument.Feature.Step.IDocString|null|undefined} docString
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         */
                        Step.prototype.docString = null;

                        /**
                         * Step dataTable.
                         * @member {io.cucumber.messages.GherkinDocument.Feature.Step.IDataTable|null|undefined} dataTable
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         */
                        Step.prototype.dataTable = null;

                        /**
                         * Step id.
                         * @member {string} id
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         */
                        Step.prototype.id = "";

                        // OneOf field names bound to virtual getters and setters
                        var $oneOfFields;

                        /**
                         * Step argument.
                         * @member {"docString"|"dataTable"|undefined} argument
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         */
                        Object.defineProperty(Step.prototype, "argument", {
                            get: $util.oneOfGetter($oneOfFields = ["docString", "dataTable"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Creates a new Step instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IStep=} [properties] Properties to set
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Step} Step instance
                         */
                        Step.create = function create(properties) {
                            return new Step(properties);
                        };

                        /**
                         * Encodes the specified Step message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Step.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IStep} message Step message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Step.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.location != null && message.hasOwnProperty("location"))
                                $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyword);
                            if (message.text != null && message.hasOwnProperty("text"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.text);
                            if (message.docString != null && message.hasOwnProperty("docString"))
                                $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString.encode(message.docString, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            if (message.dataTable != null && message.hasOwnProperty("dataTable"))
                                $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.encode(message.dataTable, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                            if (message.id != null && message.hasOwnProperty("id"))
                                writer.uint32(/* id 7, wireType 2 =*/58).string(message.id);
                            return writer;
                        };

                        /**
                         * Encodes the specified Step message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Step.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IStep} message Step message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Step.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Step message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Step} Step
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Step.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.Step();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.keyword = reader.string();
                                    break;
                                case 3:
                                    message.text = reader.string();
                                    break;
                                case 5:
                                    message.docString = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString.decode(reader, reader.uint32());
                                    break;
                                case 6:
                                    message.dataTable = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.decode(reader, reader.uint32());
                                    break;
                                case 7:
                                    message.id = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Step message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Step} Step
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Step.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Step message.
                         * @function verify
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Step.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            var properties = {};
                            if (message.location != null && message.hasOwnProperty("location")) {
                                var error = $root.io.cucumber.messages.Location.verify(message.location);
                                if (error)
                                    return "location." + error;
                            }
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                if (!$util.isString(message.keyword))
                                    return "keyword: string expected";
                            if (message.text != null && message.hasOwnProperty("text"))
                                if (!$util.isString(message.text))
                                    return "text: string expected";
                            if (message.docString != null && message.hasOwnProperty("docString")) {
                                properties.argument = 1;
                                {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString.verify(message.docString);
                                    if (error)
                                        return "docString." + error;
                                }
                            }
                            if (message.dataTable != null && message.hasOwnProperty("dataTable")) {
                                if (properties.argument === 1)
                                    return "argument: multiple values";
                                properties.argument = 1;
                                {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.verify(message.dataTable);
                                    if (error)
                                        return "dataTable." + error;
                                }
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                if (!$util.isString(message.id))
                                    return "id: string expected";
                            return null;
                        };

                        /**
                         * Creates a Step message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Step} Step
                         */
                        Step.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.Step)
                                return object;
                            var message = new $root.io.cucumber.messages.GherkinDocument.Feature.Step();
                            if (object.location != null) {
                                if (typeof object.location !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Step.location: object expected");
                                message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                            }
                            if (object.keyword != null)
                                message.keyword = String(object.keyword);
                            if (object.text != null)
                                message.text = String(object.text);
                            if (object.docString != null) {
                                if (typeof object.docString !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Step.docString: object expected");
                                message.docString = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString.fromObject(object.docString);
                            }
                            if (object.dataTable != null) {
                                if (typeof object.dataTable !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Step.dataTable: object expected");
                                message.dataTable = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.fromObject(object.dataTable);
                            }
                            if (object.id != null)
                                message.id = String(object.id);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Step message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.Step} message Step
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Step.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.location = null;
                                object.keyword = "";
                                object.text = "";
                                object.id = "";
                            }
                            if (message.location != null && message.hasOwnProperty("location"))
                                object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                object.keyword = message.keyword;
                            if (message.text != null && message.hasOwnProperty("text"))
                                object.text = message.text;
                            if (message.docString != null && message.hasOwnProperty("docString")) {
                                object.docString = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString.toObject(message.docString, options);
                                if (options.oneofs)
                                    object.argument = "docString";
                            }
                            if (message.dataTable != null && message.hasOwnProperty("dataTable")) {
                                object.dataTable = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.toObject(message.dataTable, options);
                                if (options.oneofs)
                                    object.argument = "dataTable";
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                object.id = message.id;
                            return object;
                        };

                        /**
                         * Converts this Step to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Step.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Step.DataTable = (function() {

                            /**
                             * Properties of a DataTable.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                             * @interface IDataTable
                             * @property {io.cucumber.messages.ILocation|null} [location] DataTable location
                             * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.ITableRow>|null} [rows] DataTable rows
                             */

                            /**
                             * Constructs a new DataTable.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                             * @classdesc Represents a DataTable.
                             * @implements IDataTable
                             * @constructor
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDataTable=} [properties] Properties to set
                             */
                            function DataTable(properties) {
                                this.rows = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * DataTable location.
                             * @member {io.cucumber.messages.ILocation|null|undefined} location
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @instance
                             */
                            DataTable.prototype.location = null;

                            /**
                             * DataTable rows.
                             * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.ITableRow>} rows
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @instance
                             */
                            DataTable.prototype.rows = $util.emptyArray;

                            /**
                             * Creates a new DataTable instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDataTable=} [properties] Properties to set
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DataTable} DataTable instance
                             */
                            DataTable.create = function create(properties) {
                                return new DataTable(properties);
                            };

                            /**
                             * Encodes the specified DataTable message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDataTable} message DataTable message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            DataTable.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.location != null && message.hasOwnProperty("location"))
                                    $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.rows != null && message.rows.length)
                                    for (var i = 0; i < message.rows.length; ++i)
                                        $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.encode(message.rows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified DataTable message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDataTable} message DataTable message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            DataTable.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a DataTable message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DataTable} DataTable
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            DataTable.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        if (!(message.rows && message.rows.length))
                                            message.rows = [];
                                        message.rows.push($root.io.cucumber.messages.GherkinDocument.Feature.TableRow.decode(reader, reader.uint32()));
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a DataTable message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DataTable} DataTable
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            DataTable.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a DataTable message.
                             * @function verify
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            DataTable.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.location != null && message.hasOwnProperty("location")) {
                                    var error = $root.io.cucumber.messages.Location.verify(message.location);
                                    if (error)
                                        return "location." + error;
                                }
                                if (message.rows != null && message.hasOwnProperty("rows")) {
                                    if (!Array.isArray(message.rows))
                                        return "rows: array expected";
                                    for (var i = 0; i < message.rows.length; ++i) {
                                        var error = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.verify(message.rows[i]);
                                        if (error)
                                            return "rows." + error;
                                    }
                                }
                                return null;
                            };

                            /**
                             * Creates a DataTable message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DataTable} DataTable
                             */
                            DataTable.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable)
                                    return object;
                                var message = new $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable();
                                if (object.location != null) {
                                    if (typeof object.location !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.location: object expected");
                                    message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                                }
                                if (object.rows) {
                                    if (!Array.isArray(object.rows))
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.rows: array expected");
                                    message.rows = [];
                                    for (var i = 0; i < object.rows.length; ++i) {
                                        if (typeof object.rows[i] !== "object")
                                            throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.rows: object expected");
                                        message.rows[i] = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.fromObject(object.rows[i]);
                                    }
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a DataTable message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.DataTable} message DataTable
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            DataTable.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.arrays || options.defaults)
                                    object.rows = [];
                                if (options.defaults)
                                    object.location = null;
                                if (message.location != null && message.hasOwnProperty("location"))
                                    object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                                if (message.rows && message.rows.length) {
                                    object.rows = [];
                                    for (var j = 0; j < message.rows.length; ++j)
                                        object.rows[j] = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.toObject(message.rows[j], options);
                                }
                                return object;
                            };

                            /**
                             * Converts this DataTable to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            DataTable.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return DataTable;
                        })();

                        Step.DocString = (function() {

                            /**
                             * Properties of a DocString.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                             * @interface IDocString
                             * @property {io.cucumber.messages.ILocation|null} [location] DocString location
                             * @property {string|null} [contentType] DocString contentType
                             * @property {string|null} [content] DocString content
                             * @property {string|null} [delimiter] DocString delimiter
                             */

                            /**
                             * Constructs a new DocString.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                             * @classdesc Represents a DocString.
                             * @implements IDocString
                             * @constructor
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDocString=} [properties] Properties to set
                             */
                            function DocString(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * DocString location.
                             * @member {io.cucumber.messages.ILocation|null|undefined} location
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @instance
                             */
                            DocString.prototype.location = null;

                            /**
                             * DocString contentType.
                             * @member {string} contentType
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @instance
                             */
                            DocString.prototype.contentType = "";

                            /**
                             * DocString content.
                             * @member {string} content
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @instance
                             */
                            DocString.prototype.content = "";

                            /**
                             * DocString delimiter.
                             * @member {string} delimiter
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @instance
                             */
                            DocString.prototype.delimiter = "";

                            /**
                             * Creates a new DocString instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDocString=} [properties] Properties to set
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DocString} DocString instance
                             */
                            DocString.create = function create(properties) {
                                return new DocString(properties);
                            };

                            /**
                             * Encodes the specified DocString message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Step.DocString.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDocString} message DocString message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            DocString.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.location != null && message.hasOwnProperty("location"))
                                    $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.contentType != null && message.hasOwnProperty("contentType"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.contentType);
                                if (message.content != null && message.hasOwnProperty("content"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.content);
                                if (message.delimiter != null && message.hasOwnProperty("delimiter"))
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.delimiter);
                                return writer;
                            };

                            /**
                             * Encodes the specified DocString message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Step.DocString.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDocString} message DocString message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            DocString.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a DocString message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DocString} DocString
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            DocString.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        message.contentType = reader.string();
                                        break;
                                    case 3:
                                        message.content = reader.string();
                                        break;
                                    case 4:
                                        message.delimiter = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a DocString message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DocString} DocString
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            DocString.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a DocString message.
                             * @function verify
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            DocString.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.location != null && message.hasOwnProperty("location")) {
                                    var error = $root.io.cucumber.messages.Location.verify(message.location);
                                    if (error)
                                        return "location." + error;
                                }
                                if (message.contentType != null && message.hasOwnProperty("contentType"))
                                    if (!$util.isString(message.contentType))
                                        return "contentType: string expected";
                                if (message.content != null && message.hasOwnProperty("content"))
                                    if (!$util.isString(message.content))
                                        return "content: string expected";
                                if (message.delimiter != null && message.hasOwnProperty("delimiter"))
                                    if (!$util.isString(message.delimiter))
                                        return "delimiter: string expected";
                                return null;
                            };

                            /**
                             * Creates a DocString message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DocString} DocString
                             */
                            DocString.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString)
                                    return object;
                                var message = new $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString();
                                if (object.location != null) {
                                    if (typeof object.location !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Step.DocString.location: object expected");
                                    message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                                }
                                if (object.contentType != null)
                                    message.contentType = String(object.contentType);
                                if (object.content != null)
                                    message.content = String(object.content);
                                if (object.delimiter != null)
                                    message.delimiter = String(object.delimiter);
                                return message;
                            };

                            /**
                             * Creates a plain object from a DocString message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.DocString} message DocString
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            DocString.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.location = null;
                                    object.contentType = "";
                                    object.content = "";
                                    object.delimiter = "";
                                }
                                if (message.location != null && message.hasOwnProperty("location"))
                                    object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                                if (message.contentType != null && message.hasOwnProperty("contentType"))
                                    object.contentType = message.contentType;
                                if (message.content != null && message.hasOwnProperty("content"))
                                    object.content = message.content;
                                if (message.delimiter != null && message.hasOwnProperty("delimiter"))
                                    object.delimiter = message.delimiter;
                                return object;
                            };

                            /**
                             * Converts this DocString to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            DocString.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return DocString;
                        })();

                        return Step;
                    })();

                    return Feature;
                })();

                return GherkinDocument;
            })();

            messages.Attachment = (function() {

                /**
                 * Properties of an Attachment.
                 * @memberof io.cucumber.messages
                 * @interface IAttachment
                 * @property {io.cucumber.messages.ISourceReference|null} [source] Attachment source
                 * @property {string|null} [data] Attachment data
                 * @property {io.cucumber.messages.IMedia|null} [media] Attachment media
                 * @property {string|null} [testStepId] Attachment testStepId
                 * @property {string|null} [testCaseStartedId] Attachment testCaseStartedId
                 */

                /**
                 * Constructs a new Attachment.
                 * @memberof io.cucumber.messages
                 * @classdesc An attachment represents any kind of data associated with a line in a
                 * [Source](#io.cucumber.messages.Source) file. It can be used for:
                 * 
                 * * Syntax errors during parse time
                 * * Screenshots captured and attached during execution
                 * * Logs captured and attached during execution
                 * 
                 * It is not to be used for runtime errors raised/thrown during execution. This
                 * is captured in `TestResult`.
                 * @implements IAttachment
                 * @constructor
                 * @param {io.cucumber.messages.IAttachment=} [properties] Properties to set
                 */
                function Attachment(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Attachment source.
                 * @member {io.cucumber.messages.ISourceReference|null|undefined} source
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 */
                Attachment.prototype.source = null;

                /**
                 * Attachment data.
                 * @member {string} data
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 */
                Attachment.prototype.data = "";

                /**
                 * Attachment media.
                 * @member {io.cucumber.messages.IMedia|null|undefined} media
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 */
                Attachment.prototype.media = null;

                /**
                 * Attachment testStepId.
                 * @member {string} testStepId
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 */
                Attachment.prototype.testStepId = "";

                /**
                 * Attachment testCaseStartedId.
                 * @member {string} testCaseStartedId
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 */
                Attachment.prototype.testCaseStartedId = "";

                /**
                 * Creates a new Attachment instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {io.cucumber.messages.IAttachment=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Attachment} Attachment instance
                 */
                Attachment.create = function create(properties) {
                    return new Attachment(properties);
                };

                /**
                 * Encodes the specified Attachment message. Does not implicitly {@link io.cucumber.messages.Attachment.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {io.cucumber.messages.IAttachment} message Attachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Attachment.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.source != null && message.hasOwnProperty("source"))
                        $root.io.cucumber.messages.SourceReference.encode(message.source, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.data != null && message.hasOwnProperty("data"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
                    if (message.media != null && message.hasOwnProperty("media"))
                        $root.io.cucumber.messages.Media.encode(message.media, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.testStepId);
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.testCaseStartedId);
                    return writer;
                };

                /**
                 * Encodes the specified Attachment message, length delimited. Does not implicitly {@link io.cucumber.messages.Attachment.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {io.cucumber.messages.IAttachment} message Attachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Attachment.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Attachment message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Attachment} Attachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Attachment.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Attachment();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.source = $root.io.cucumber.messages.SourceReference.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.data = reader.string();
                            break;
                        case 3:
                            message.media = $root.io.cucumber.messages.Media.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.testStepId = reader.string();
                            break;
                        case 5:
                            message.testCaseStartedId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Attachment message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Attachment} Attachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Attachment.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Attachment message.
                 * @function verify
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Attachment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.source != null && message.hasOwnProperty("source")) {
                        var error = $root.io.cucumber.messages.SourceReference.verify(message.source);
                        if (error)
                            return "source." + error;
                    }
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!$util.isString(message.data))
                            return "data: string expected";
                    if (message.media != null && message.hasOwnProperty("media")) {
                        var error = $root.io.cucumber.messages.Media.verify(message.media);
                        if (error)
                            return "media." + error;
                    }
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        if (!$util.isString(message.testStepId))
                            return "testStepId: string expected";
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        if (!$util.isString(message.testCaseStartedId))
                            return "testCaseStartedId: string expected";
                    return null;
                };

                /**
                 * Creates an Attachment message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Attachment} Attachment
                 */
                Attachment.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Attachment)
                        return object;
                    var message = new $root.io.cucumber.messages.Attachment();
                    if (object.source != null) {
                        if (typeof object.source !== "object")
                            throw TypeError(".io.cucumber.messages.Attachment.source: object expected");
                        message.source = $root.io.cucumber.messages.SourceReference.fromObject(object.source);
                    }
                    if (object.data != null)
                        message.data = String(object.data);
                    if (object.media != null) {
                        if (typeof object.media !== "object")
                            throw TypeError(".io.cucumber.messages.Attachment.media: object expected");
                        message.media = $root.io.cucumber.messages.Media.fromObject(object.media);
                    }
                    if (object.testStepId != null)
                        message.testStepId = String(object.testStepId);
                    if (object.testCaseStartedId != null)
                        message.testCaseStartedId = String(object.testCaseStartedId);
                    return message;
                };

                /**
                 * Creates a plain object from an Attachment message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {io.cucumber.messages.Attachment} message Attachment
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Attachment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.source = null;
                        object.data = "";
                        object.media = null;
                        object.testStepId = "";
                        object.testCaseStartedId = "";
                    }
                    if (message.source != null && message.hasOwnProperty("source"))
                        object.source = $root.io.cucumber.messages.SourceReference.toObject(message.source, options);
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = message.data;
                    if (message.media != null && message.hasOwnProperty("media"))
                        object.media = $root.io.cucumber.messages.Media.toObject(message.media, options);
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        object.testStepId = message.testStepId;
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        object.testCaseStartedId = message.testCaseStartedId;
                    return object;
                };

                /**
                 * Converts this Attachment to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Attachment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Attachment;
            })();

            messages.Pickle = (function() {

                /**
                 * Properties of a Pickle.
                 * @memberof io.cucumber.messages
                 * @interface IPickle
                 * @property {string|null} [id] A unique id for the pickle. This is a [SHA1](https://en.wikipedia.org/wiki/SHA-1) hash
                 * from the source data and the `locations` of the pickle.
                 * This ID will change if source the file is modified.
                 * @property {string|null} [uri] Pickle uri
                 * @property {string|null} [name] Pickle name
                 * @property {string|null} [language] Pickle language
                 * @property {Array.<io.cucumber.messages.Pickle.IPickleStep>|null} [steps] Pickle steps
                 * @property {Array.<io.cucumber.messages.Pickle.IPickleTag>|null} [tags] One or more tags. If this pickle is constructed from a Gherkin document,
                 * It includes inherited tags from the `Feature` as well.
                 * @property {Array.<string>|null} [astNodeIds] Points to the AST node locations of the pickle. The last one represents the unique
                 * id of the pickle. A pickle constructed from `Examples` will have the first
                 * id originating from the `Scenario` AST node, and the second from the `TableRow` AST node.
                 */

                /**
                 * Constructs a new Pickle.
                 * @memberof io.cucumber.messages
                 * @classdesc A `Pickle` represents a test case Cucumber can *execute*. It is typically derived
                 * from another format, such as [GherkinDocument](#io.cucumber.messages.GherkinDocument).
                 * In the future a `Pickle` may be derived from other formats such as Markdown or
                 * Excel files.
                 * 
                 * By making `Pickle` the main data structure Cucumber uses for execution, the
                 * implementation of Cucumber itself becomes simpler, as it doesn't have to deal
                 * with the complex structure of a [GherkinDocument](#io.cucumber.messages.GherkinDocument).
                 * @implements IPickle
                 * @constructor
                 * @param {io.cucumber.messages.IPickle=} [properties] Properties to set
                 */
                function Pickle(properties) {
                    this.steps = [];
                    this.tags = [];
                    this.astNodeIds = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * A unique id for the pickle. This is a [SHA1](https://en.wikipedia.org/wiki/SHA-1) hash
                 * from the source data and the `locations` of the pickle.
                 * This ID will change if source the file is modified.
                 * @member {string} id
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 */
                Pickle.prototype.id = "";

                /**
                 * Pickle uri.
                 * @member {string} uri
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 */
                Pickle.prototype.uri = "";

                /**
                 * Pickle name.
                 * @member {string} name
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 */
                Pickle.prototype.name = "";

                /**
                 * Pickle language.
                 * @member {string} language
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 */
                Pickle.prototype.language = "";

                /**
                 * Pickle steps.
                 * @member {Array.<io.cucumber.messages.Pickle.IPickleStep>} steps
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 */
                Pickle.prototype.steps = $util.emptyArray;

                /**
                 * One or more tags. If this pickle is constructed from a Gherkin document,
                 * It includes inherited tags from the `Feature` as well.
                 * @member {Array.<io.cucumber.messages.Pickle.IPickleTag>} tags
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 */
                Pickle.prototype.tags = $util.emptyArray;

                /**
                 * Points to the AST node locations of the pickle. The last one represents the unique
                 * id of the pickle. A pickle constructed from `Examples` will have the first
                 * id originating from the `Scenario` AST node, and the second from the `TableRow` AST node.
                 * @member {Array.<string>} astNodeIds
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 */
                Pickle.prototype.astNodeIds = $util.emptyArray;

                /**
                 * Creates a new Pickle instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {io.cucumber.messages.IPickle=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Pickle} Pickle instance
                 */
                Pickle.create = function create(properties) {
                    return new Pickle(properties);
                };

                /**
                 * Encodes the specified Pickle message. Does not implicitly {@link io.cucumber.messages.Pickle.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {io.cucumber.messages.IPickle} message Pickle message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Pickle.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.uri);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    if (message.language != null && message.hasOwnProperty("language"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.language);
                    if (message.steps != null && message.steps.length)
                        for (var i = 0; i < message.steps.length; ++i)
                            $root.io.cucumber.messages.Pickle.PickleStep.encode(message.steps[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.tags != null && message.tags.length)
                        for (var i = 0; i < message.tags.length; ++i)
                            $root.io.cucumber.messages.Pickle.PickleTag.encode(message.tags[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.astNodeIds != null && message.astNodeIds.length)
                        for (var i = 0; i < message.astNodeIds.length; ++i)
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.astNodeIds[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Pickle message, length delimited. Does not implicitly {@link io.cucumber.messages.Pickle.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {io.cucumber.messages.IPickle} message Pickle message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Pickle.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Pickle message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Pickle} Pickle
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Pickle.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Pickle();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.uri = reader.string();
                            break;
                        case 3:
                            message.name = reader.string();
                            break;
                        case 4:
                            message.language = reader.string();
                            break;
                        case 5:
                            if (!(message.steps && message.steps.length))
                                message.steps = [];
                            message.steps.push($root.io.cucumber.messages.Pickle.PickleStep.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push($root.io.cucumber.messages.Pickle.PickleTag.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.astNodeIds && message.astNodeIds.length))
                                message.astNodeIds = [];
                            message.astNodeIds.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Pickle message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Pickle} Pickle
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Pickle.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Pickle message.
                 * @function verify
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Pickle.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.language != null && message.hasOwnProperty("language"))
                        if (!$util.isString(message.language))
                            return "language: string expected";
                    if (message.steps != null && message.hasOwnProperty("steps")) {
                        if (!Array.isArray(message.steps))
                            return "steps: array expected";
                        for (var i = 0; i < message.steps.length; ++i) {
                            var error = $root.io.cucumber.messages.Pickle.PickleStep.verify(message.steps[i]);
                            if (error)
                                return "steps." + error;
                        }
                    }
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!Array.isArray(message.tags))
                            return "tags: array expected";
                        for (var i = 0; i < message.tags.length; ++i) {
                            var error = $root.io.cucumber.messages.Pickle.PickleTag.verify(message.tags[i]);
                            if (error)
                                return "tags." + error;
                        }
                    }
                    if (message.astNodeIds != null && message.hasOwnProperty("astNodeIds")) {
                        if (!Array.isArray(message.astNodeIds))
                            return "astNodeIds: array expected";
                        for (var i = 0; i < message.astNodeIds.length; ++i)
                            if (!$util.isString(message.astNodeIds[i]))
                                return "astNodeIds: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Pickle message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Pickle} Pickle
                 */
                Pickle.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Pickle)
                        return object;
                    var message = new $root.io.cucumber.messages.Pickle();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.uri != null)
                        message.uri = String(object.uri);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.language != null)
                        message.language = String(object.language);
                    if (object.steps) {
                        if (!Array.isArray(object.steps))
                            throw TypeError(".io.cucumber.messages.Pickle.steps: array expected");
                        message.steps = [];
                        for (var i = 0; i < object.steps.length; ++i) {
                            if (typeof object.steps[i] !== "object")
                                throw TypeError(".io.cucumber.messages.Pickle.steps: object expected");
                            message.steps[i] = $root.io.cucumber.messages.Pickle.PickleStep.fromObject(object.steps[i]);
                        }
                    }
                    if (object.tags) {
                        if (!Array.isArray(object.tags))
                            throw TypeError(".io.cucumber.messages.Pickle.tags: array expected");
                        message.tags = [];
                        for (var i = 0; i < object.tags.length; ++i) {
                            if (typeof object.tags[i] !== "object")
                                throw TypeError(".io.cucumber.messages.Pickle.tags: object expected");
                            message.tags[i] = $root.io.cucumber.messages.Pickle.PickleTag.fromObject(object.tags[i]);
                        }
                    }
                    if (object.astNodeIds) {
                        if (!Array.isArray(object.astNodeIds))
                            throw TypeError(".io.cucumber.messages.Pickle.astNodeIds: array expected");
                        message.astNodeIds = [];
                        for (var i = 0; i < object.astNodeIds.length; ++i)
                            message.astNodeIds[i] = String(object.astNodeIds[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Pickle message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {io.cucumber.messages.Pickle} message Pickle
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Pickle.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.steps = [];
                        object.tags = [];
                        object.astNodeIds = [];
                    }
                    if (options.defaults) {
                        object.id = "";
                        object.uri = "";
                        object.name = "";
                        object.language = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        object.uri = message.uri;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.language != null && message.hasOwnProperty("language"))
                        object.language = message.language;
                    if (message.steps && message.steps.length) {
                        object.steps = [];
                        for (var j = 0; j < message.steps.length; ++j)
                            object.steps[j] = $root.io.cucumber.messages.Pickle.PickleStep.toObject(message.steps[j], options);
                    }
                    if (message.tags && message.tags.length) {
                        object.tags = [];
                        for (var j = 0; j < message.tags.length; ++j)
                            object.tags[j] = $root.io.cucumber.messages.Pickle.PickleTag.toObject(message.tags[j], options);
                    }
                    if (message.astNodeIds && message.astNodeIds.length) {
                        object.astNodeIds = [];
                        for (var j = 0; j < message.astNodeIds.length; ++j)
                            object.astNodeIds[j] = message.astNodeIds[j];
                    }
                    return object;
                };

                /**
                 * Converts this Pickle to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Pickle.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Pickle.PickleTag = (function() {

                    /**
                     * Properties of a PickleTag.
                     * @memberof io.cucumber.messages.Pickle
                     * @interface IPickleTag
                     * @property {string|null} [name] PickleTag name
                     * @property {string|null} [astNodeId] PickleTag astNodeId
                     */

                    /**
                     * Constructs a new PickleTag.
                     * @memberof io.cucumber.messages.Pickle
                     * @classdesc A tag
                     * @implements IPickleTag
                     * @constructor
                     * @param {io.cucumber.messages.Pickle.IPickleTag=} [properties] Properties to set
                     */
                    function PickleTag(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PickleTag name.
                     * @member {string} name
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @instance
                     */
                    PickleTag.prototype.name = "";

                    /**
                     * PickleTag astNodeId.
                     * @member {string} astNodeId
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @instance
                     */
                    PickleTag.prototype.astNodeId = "";

                    /**
                     * Creates a new PickleTag instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {io.cucumber.messages.Pickle.IPickleTag=} [properties] Properties to set
                     * @returns {io.cucumber.messages.Pickle.PickleTag} PickleTag instance
                     */
                    PickleTag.create = function create(properties) {
                        return new PickleTag(properties);
                    };

                    /**
                     * Encodes the specified PickleTag message. Does not implicitly {@link io.cucumber.messages.Pickle.PickleTag.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {io.cucumber.messages.Pickle.IPickleTag} message PickleTag message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleTag.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && message.hasOwnProperty("name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.astNodeId != null && message.hasOwnProperty("astNodeId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.astNodeId);
                        return writer;
                    };

                    /**
                     * Encodes the specified PickleTag message, length delimited. Does not implicitly {@link io.cucumber.messages.Pickle.PickleTag.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {io.cucumber.messages.Pickle.IPickleTag} message PickleTag message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleTag.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PickleTag message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.Pickle.PickleTag} PickleTag
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleTag.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Pickle.PickleTag();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.astNodeId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PickleTag message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.Pickle.PickleTag} PickleTag
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleTag.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PickleTag message.
                     * @function verify
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PickleTag.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.astNodeId != null && message.hasOwnProperty("astNodeId"))
                            if (!$util.isString(message.astNodeId))
                                return "astNodeId: string expected";
                        return null;
                    };

                    /**
                     * Creates a PickleTag message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.Pickle.PickleTag} PickleTag
                     */
                    PickleTag.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.Pickle.PickleTag)
                            return object;
                        var message = new $root.io.cucumber.messages.Pickle.PickleTag();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.astNodeId != null)
                            message.astNodeId = String(object.astNodeId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a PickleTag message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {io.cucumber.messages.Pickle.PickleTag} message PickleTag
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PickleTag.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.astNodeId = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.astNodeId != null && message.hasOwnProperty("astNodeId"))
                            object.astNodeId = message.astNodeId;
                        return object;
                    };

                    /**
                     * Converts this PickleTag to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PickleTag.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return PickleTag;
                })();

                Pickle.PickleStep = (function() {

                    /**
                     * Properties of a PickleStep.
                     * @memberof io.cucumber.messages.Pickle
                     * @interface IPickleStep
                     * @property {string|null} [text] PickleStep text
                     * @property {io.cucumber.messages.IPickleStepArgument|null} [argument] PickleStep argument
                     * @property {string|null} [id] PickleStep id
                     * @property {Array.<string>|null} [astNodeIds] PickleStep astNodeIds
                     */

                    /**
                     * Constructs a new PickleStep.
                     * @memberof io.cucumber.messages.Pickle
                     * @classdesc An executable step
                     * @implements IPickleStep
                     * @constructor
                     * @param {io.cucumber.messages.Pickle.IPickleStep=} [properties] Properties to set
                     */
                    function PickleStep(properties) {
                        this.astNodeIds = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PickleStep text.
                     * @member {string} text
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @instance
                     */
                    PickleStep.prototype.text = "";

                    /**
                     * PickleStep argument.
                     * @member {io.cucumber.messages.IPickleStepArgument|null|undefined} argument
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @instance
                     */
                    PickleStep.prototype.argument = null;

                    /**
                     * PickleStep id.
                     * @member {string} id
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @instance
                     */
                    PickleStep.prototype.id = "";

                    /**
                     * PickleStep astNodeIds.
                     * @member {Array.<string>} astNodeIds
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @instance
                     */
                    PickleStep.prototype.astNodeIds = $util.emptyArray;

                    /**
                     * Creates a new PickleStep instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {io.cucumber.messages.Pickle.IPickleStep=} [properties] Properties to set
                     * @returns {io.cucumber.messages.Pickle.PickleStep} PickleStep instance
                     */
                    PickleStep.create = function create(properties) {
                        return new PickleStep(properties);
                    };

                    /**
                     * Encodes the specified PickleStep message. Does not implicitly {@link io.cucumber.messages.Pickle.PickleStep.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {io.cucumber.messages.Pickle.IPickleStep} message PickleStep message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleStep.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.text != null && message.hasOwnProperty("text"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                        if (message.argument != null && message.hasOwnProperty("argument"))
                            $root.io.cucumber.messages.PickleStepArgument.encode(message.argument, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.id);
                        if (message.astNodeIds != null && message.astNodeIds.length)
                            for (var i = 0; i < message.astNodeIds.length; ++i)
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.astNodeIds[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified PickleStep message, length delimited. Does not implicitly {@link io.cucumber.messages.Pickle.PickleStep.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {io.cucumber.messages.Pickle.IPickleStep} message PickleStep message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleStep.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PickleStep message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.Pickle.PickleStep} PickleStep
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleStep.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Pickle.PickleStep();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.text = reader.string();
                                break;
                            case 2:
                                message.argument = $root.io.cucumber.messages.PickleStepArgument.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.id = reader.string();
                                break;
                            case 4:
                                if (!(message.astNodeIds && message.astNodeIds.length))
                                    message.astNodeIds = [];
                                message.astNodeIds.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PickleStep message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.Pickle.PickleStep} PickleStep
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleStep.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PickleStep message.
                     * @function verify
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PickleStep.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.text != null && message.hasOwnProperty("text"))
                            if (!$util.isString(message.text))
                                return "text: string expected";
                        if (message.argument != null && message.hasOwnProperty("argument")) {
                            var error = $root.io.cucumber.messages.PickleStepArgument.verify(message.argument);
                            if (error)
                                return "argument." + error;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.astNodeIds != null && message.hasOwnProperty("astNodeIds")) {
                            if (!Array.isArray(message.astNodeIds))
                                return "astNodeIds: array expected";
                            for (var i = 0; i < message.astNodeIds.length; ++i)
                                if (!$util.isString(message.astNodeIds[i]))
                                    return "astNodeIds: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a PickleStep message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.Pickle.PickleStep} PickleStep
                     */
                    PickleStep.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.Pickle.PickleStep)
                            return object;
                        var message = new $root.io.cucumber.messages.Pickle.PickleStep();
                        if (object.text != null)
                            message.text = String(object.text);
                        if (object.argument != null) {
                            if (typeof object.argument !== "object")
                                throw TypeError(".io.cucumber.messages.Pickle.PickleStep.argument: object expected");
                            message.argument = $root.io.cucumber.messages.PickleStepArgument.fromObject(object.argument);
                        }
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.astNodeIds) {
                            if (!Array.isArray(object.astNodeIds))
                                throw TypeError(".io.cucumber.messages.Pickle.PickleStep.astNodeIds: array expected");
                            message.astNodeIds = [];
                            for (var i = 0; i < object.astNodeIds.length; ++i)
                                message.astNodeIds[i] = String(object.astNodeIds[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a PickleStep message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {io.cucumber.messages.Pickle.PickleStep} message PickleStep
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PickleStep.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.astNodeIds = [];
                        if (options.defaults) {
                            object.text = "";
                            object.argument = null;
                            object.id = "";
                        }
                        if (message.text != null && message.hasOwnProperty("text"))
                            object.text = message.text;
                        if (message.argument != null && message.hasOwnProperty("argument"))
                            object.argument = $root.io.cucumber.messages.PickleStepArgument.toObject(message.argument, options);
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.astNodeIds && message.astNodeIds.length) {
                            object.astNodeIds = [];
                            for (var j = 0; j < message.astNodeIds.length; ++j)
                                object.astNodeIds[j] = message.astNodeIds[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this PickleStep to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PickleStep.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return PickleStep;
                })();

                return Pickle;
            })();

            messages.PickleStepArgument = (function() {

                /**
                 * Properties of a PickleStepArgument.
                 * @memberof io.cucumber.messages
                 * @interface IPickleStepArgument
                 * @property {io.cucumber.messages.PickleStepArgument.IPickleDocString|null} [docString] PickleStepArgument docString
                 * @property {io.cucumber.messages.PickleStepArgument.IPickleTable|null} [dataTable] PickleStepArgument dataTable
                 */

                /**
                 * Constructs a new PickleStepArgument.
                 * @memberof io.cucumber.messages
                 * @classdesc A wrapper for either a doc string or a table.
                 * @implements IPickleStepArgument
                 * @constructor
                 * @param {io.cucumber.messages.IPickleStepArgument=} [properties] Properties to set
                 */
                function PickleStepArgument(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PickleStepArgument docString.
                 * @member {io.cucumber.messages.PickleStepArgument.IPickleDocString|null|undefined} docString
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @instance
                 */
                PickleStepArgument.prototype.docString = null;

                /**
                 * PickleStepArgument dataTable.
                 * @member {io.cucumber.messages.PickleStepArgument.IPickleTable|null|undefined} dataTable
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @instance
                 */
                PickleStepArgument.prototype.dataTable = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * PickleStepArgument message.
                 * @member {"docString"|"dataTable"|undefined} message
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @instance
                 */
                Object.defineProperty(PickleStepArgument.prototype, "message", {
                    get: $util.oneOfGetter($oneOfFields = ["docString", "dataTable"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new PickleStepArgument instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {io.cucumber.messages.IPickleStepArgument=} [properties] Properties to set
                 * @returns {io.cucumber.messages.PickleStepArgument} PickleStepArgument instance
                 */
                PickleStepArgument.create = function create(properties) {
                    return new PickleStepArgument(properties);
                };

                /**
                 * Encodes the specified PickleStepArgument message. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {io.cucumber.messages.IPickleStepArgument} message PickleStepArgument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PickleStepArgument.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.docString != null && message.hasOwnProperty("docString"))
                        $root.io.cucumber.messages.PickleStepArgument.PickleDocString.encode(message.docString, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.dataTable != null && message.hasOwnProperty("dataTable"))
                        $root.io.cucumber.messages.PickleStepArgument.PickleTable.encode(message.dataTable, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PickleStepArgument message, length delimited. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {io.cucumber.messages.IPickleStepArgument} message PickleStepArgument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PickleStepArgument.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PickleStepArgument message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.PickleStepArgument} PickleStepArgument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PickleStepArgument.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.PickleStepArgument();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.docString = $root.io.cucumber.messages.PickleStepArgument.PickleDocString.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.dataTable = $root.io.cucumber.messages.PickleStepArgument.PickleTable.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PickleStepArgument message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.PickleStepArgument} PickleStepArgument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PickleStepArgument.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PickleStepArgument message.
                 * @function verify
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PickleStepArgument.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.docString != null && message.hasOwnProperty("docString")) {
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.PickleStepArgument.PickleDocString.verify(message.docString);
                            if (error)
                                return "docString." + error;
                        }
                    }
                    if (message.dataTable != null && message.hasOwnProperty("dataTable")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.PickleStepArgument.PickleTable.verify(message.dataTable);
                            if (error)
                                return "dataTable." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a PickleStepArgument message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.PickleStepArgument} PickleStepArgument
                 */
                PickleStepArgument.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.PickleStepArgument)
                        return object;
                    var message = new $root.io.cucumber.messages.PickleStepArgument();
                    if (object.docString != null) {
                        if (typeof object.docString !== "object")
                            throw TypeError(".io.cucumber.messages.PickleStepArgument.docString: object expected");
                        message.docString = $root.io.cucumber.messages.PickleStepArgument.PickleDocString.fromObject(object.docString);
                    }
                    if (object.dataTable != null) {
                        if (typeof object.dataTable !== "object")
                            throw TypeError(".io.cucumber.messages.PickleStepArgument.dataTable: object expected");
                        message.dataTable = $root.io.cucumber.messages.PickleStepArgument.PickleTable.fromObject(object.dataTable);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PickleStepArgument message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {io.cucumber.messages.PickleStepArgument} message PickleStepArgument
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PickleStepArgument.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.docString != null && message.hasOwnProperty("docString")) {
                        object.docString = $root.io.cucumber.messages.PickleStepArgument.PickleDocString.toObject(message.docString, options);
                        if (options.oneofs)
                            object.message = "docString";
                    }
                    if (message.dataTable != null && message.hasOwnProperty("dataTable")) {
                        object.dataTable = $root.io.cucumber.messages.PickleStepArgument.PickleTable.toObject(message.dataTable, options);
                        if (options.oneofs)
                            object.message = "dataTable";
                    }
                    return object;
                };

                /**
                 * Converts this PickleStepArgument to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PickleStepArgument.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                PickleStepArgument.PickleDocString = (function() {

                    /**
                     * Properties of a PickleDocString.
                     * @memberof io.cucumber.messages.PickleStepArgument
                     * @interface IPickleDocString
                     * @property {string|null} [contentType] PickleDocString contentType
                     * @property {string|null} [content] PickleDocString content
                     */

                    /**
                     * Constructs a new PickleDocString.
                     * @memberof io.cucumber.messages.PickleStepArgument
                     * @classdesc Represents a PickleDocString.
                     * @implements IPickleDocString
                     * @constructor
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleDocString=} [properties] Properties to set
                     */
                    function PickleDocString(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PickleDocString contentType.
                     * @member {string} contentType
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @instance
                     */
                    PickleDocString.prototype.contentType = "";

                    /**
                     * PickleDocString content.
                     * @member {string} content
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @instance
                     */
                    PickleDocString.prototype.content = "";

                    /**
                     * Creates a new PickleDocString instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleDocString=} [properties] Properties to set
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleDocString} PickleDocString instance
                     */
                    PickleDocString.create = function create(properties) {
                        return new PickleDocString(properties);
                    };

                    /**
                     * Encodes the specified PickleDocString message. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleDocString.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleDocString} message PickleDocString message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleDocString.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contentType != null && message.hasOwnProperty("contentType"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contentType);
                        if (message.content != null && message.hasOwnProperty("content"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
                        return writer;
                    };

                    /**
                     * Encodes the specified PickleDocString message, length delimited. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleDocString.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleDocString} message PickleDocString message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleDocString.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PickleDocString message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleDocString} PickleDocString
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleDocString.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.PickleStepArgument.PickleDocString();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contentType = reader.string();
                                break;
                            case 2:
                                message.content = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PickleDocString message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleDocString} PickleDocString
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleDocString.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PickleDocString message.
                     * @function verify
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PickleDocString.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contentType != null && message.hasOwnProperty("contentType"))
                            if (!$util.isString(message.contentType))
                                return "contentType: string expected";
                        if (message.content != null && message.hasOwnProperty("content"))
                            if (!$util.isString(message.content))
                                return "content: string expected";
                        return null;
                    };

                    /**
                     * Creates a PickleDocString message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleDocString} PickleDocString
                     */
                    PickleDocString.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.PickleStepArgument.PickleDocString)
                            return object;
                        var message = new $root.io.cucumber.messages.PickleStepArgument.PickleDocString();
                        if (object.contentType != null)
                            message.contentType = String(object.contentType);
                        if (object.content != null)
                            message.content = String(object.content);
                        return message;
                    };

                    /**
                     * Creates a plain object from a PickleDocString message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.PickleDocString} message PickleDocString
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PickleDocString.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contentType = "";
                            object.content = "";
                        }
                        if (message.contentType != null && message.hasOwnProperty("contentType"))
                            object.contentType = message.contentType;
                        if (message.content != null && message.hasOwnProperty("content"))
                            object.content = message.content;
                        return object;
                    };

                    /**
                     * Converts this PickleDocString to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PickleDocString.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return PickleDocString;
                })();

                PickleStepArgument.PickleTable = (function() {

                    /**
                     * Properties of a PickleTable.
                     * @memberof io.cucumber.messages.PickleStepArgument
                     * @interface IPickleTable
                     * @property {Array.<io.cucumber.messages.PickleStepArgument.PickleTable.IPickleTableRow>|null} [rows] PickleTable rows
                     */

                    /**
                     * Constructs a new PickleTable.
                     * @memberof io.cucumber.messages.PickleStepArgument
                     * @classdesc Represents a PickleTable.
                     * @implements IPickleTable
                     * @constructor
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleTable=} [properties] Properties to set
                     */
                    function PickleTable(properties) {
                        this.rows = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PickleTable rows.
                     * @member {Array.<io.cucumber.messages.PickleStepArgument.PickleTable.IPickleTableRow>} rows
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @instance
                     */
                    PickleTable.prototype.rows = $util.emptyArray;

                    /**
                     * Creates a new PickleTable instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleTable=} [properties] Properties to set
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleTable} PickleTable instance
                     */
                    PickleTable.create = function create(properties) {
                        return new PickleTable(properties);
                    };

                    /**
                     * Encodes the specified PickleTable message. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleTable.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleTable} message PickleTable message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleTable.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.rows != null && message.rows.length)
                            for (var i = 0; i < message.rows.length; ++i)
                                $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.encode(message.rows[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified PickleTable message, length delimited. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleTable.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleTable} message PickleTable message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleTable.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PickleTable message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleTable} PickleTable
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleTable.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.PickleStepArgument.PickleTable();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.rows && message.rows.length))
                                    message.rows = [];
                                message.rows.push($root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PickleTable message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleTable} PickleTable
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleTable.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PickleTable message.
                     * @function verify
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PickleTable.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.rows != null && message.hasOwnProperty("rows")) {
                            if (!Array.isArray(message.rows))
                                return "rows: array expected";
                            for (var i = 0; i < message.rows.length; ++i) {
                                var error = $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.verify(message.rows[i]);
                                if (error)
                                    return "rows." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a PickleTable message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleTable} PickleTable
                     */
                    PickleTable.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.PickleStepArgument.PickleTable)
                            return object;
                        var message = new $root.io.cucumber.messages.PickleStepArgument.PickleTable();
                        if (object.rows) {
                            if (!Array.isArray(object.rows))
                                throw TypeError(".io.cucumber.messages.PickleStepArgument.PickleTable.rows: array expected");
                            message.rows = [];
                            for (var i = 0; i < object.rows.length; ++i) {
                                if (typeof object.rows[i] !== "object")
                                    throw TypeError(".io.cucumber.messages.PickleStepArgument.PickleTable.rows: object expected");
                                message.rows[i] = $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.fromObject(object.rows[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a PickleTable message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.PickleTable} message PickleTable
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PickleTable.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.rows = [];
                        if (message.rows && message.rows.length) {
                            object.rows = [];
                            for (var j = 0; j < message.rows.length; ++j)
                                object.rows[j] = $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.toObject(message.rows[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this PickleTable to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PickleTable.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    PickleTable.PickleTableRow = (function() {

                        /**
                         * Properties of a PickleTableRow.
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                         * @interface IPickleTableRow
                         * @property {Array.<io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.IPickleTableCell>|null} [cells] PickleTableRow cells
                         */

                        /**
                         * Constructs a new PickleTableRow.
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                         * @classdesc Represents a PickleTableRow.
                         * @implements IPickleTableRow
                         * @constructor
                         * @param {io.cucumber.messages.PickleStepArgument.PickleTable.IPickleTableRow=} [properties] Properties to set
                         */
                        function PickleTableRow(properties) {
                            this.cells = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * PickleTableRow cells.
                         * @member {Array.<io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.IPickleTableCell>} cells
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @instance
                         */
                        PickleTableRow.prototype.cells = $util.emptyArray;

                        /**
                         * Creates a new PickleTableRow instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {io.cucumber.messages.PickleStepArgument.PickleTable.IPickleTableRow=} [properties] Properties to set
                         * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow} PickleTableRow instance
                         */
                        PickleTableRow.create = function create(properties) {
                            return new PickleTableRow(properties);
                        };

                        /**
                         * Encodes the specified PickleTableRow message. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {io.cucumber.messages.PickleStepArgument.PickleTable.IPickleTableRow} message PickleTableRow message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PickleTableRow.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.cells != null && message.cells.length)
                                for (var i = 0; i < message.cells.length; ++i)
                                    $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell.encode(message.cells[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified PickleTableRow message, length delimited. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {io.cucumber.messages.PickleStepArgument.PickleTable.IPickleTableRow} message PickleTableRow message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PickleTableRow.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a PickleTableRow message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow} PickleTableRow
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PickleTableRow.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    if (!(message.cells && message.cells.length))
                                        message.cells = [];
                                    message.cells.push($root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell.decode(reader, reader.uint32()));
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a PickleTableRow message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow} PickleTableRow
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PickleTableRow.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a PickleTableRow message.
                         * @function verify
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PickleTableRow.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.cells != null && message.hasOwnProperty("cells")) {
                                if (!Array.isArray(message.cells))
                                    return "cells: array expected";
                                for (var i = 0; i < message.cells.length; ++i) {
                                    var error = $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell.verify(message.cells[i]);
                                    if (error)
                                        return "cells." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a PickleTableRow message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow} PickleTableRow
                         */
                        PickleTableRow.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow)
                                return object;
                            var message = new $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow();
                            if (object.cells) {
                                if (!Array.isArray(object.cells))
                                    throw TypeError(".io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.cells: array expected");
                                message.cells = [];
                                for (var i = 0; i < object.cells.length; ++i) {
                                    if (typeof object.cells[i] !== "object")
                                        throw TypeError(".io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.cells: object expected");
                                    message.cells[i] = $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell.fromObject(object.cells[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a PickleTableRow message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow} message PickleTableRow
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PickleTableRow.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.cells = [];
                            if (message.cells && message.cells.length) {
                                object.cells = [];
                                for (var j = 0; j < message.cells.length; ++j)
                                    object.cells[j] = $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell.toObject(message.cells[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this PickleTableRow to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PickleTableRow.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        PickleTableRow.PickleTableCell = (function() {

                            /**
                             * Properties of a PickleTableCell.
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                             * @interface IPickleTableCell
                             * @property {string|null} [value] PickleTableCell value
                             */

                            /**
                             * Constructs a new PickleTableCell.
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                             * @classdesc Represents a PickleTableCell.
                             * @implements IPickleTableCell
                             * @constructor
                             * @param {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.IPickleTableCell=} [properties] Properties to set
                             */
                            function PickleTableCell(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * PickleTableCell value.
                             * @member {string} value
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @instance
                             */
                            PickleTableCell.prototype.value = "";

                            /**
                             * Creates a new PickleTableCell instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.IPickleTableCell=} [properties] Properties to set
                             * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell} PickleTableCell instance
                             */
                            PickleTableCell.create = function create(properties) {
                                return new PickleTableCell(properties);
                            };

                            /**
                             * Encodes the specified PickleTableCell message. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.IPickleTableCell} message PickleTableCell message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            PickleTableCell.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.value != null && message.hasOwnProperty("value"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                                return writer;
                            };

                            /**
                             * Encodes the specified PickleTableCell message, length delimited. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.IPickleTableCell} message PickleTableCell message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            PickleTableCell.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a PickleTableCell message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell} PickleTableCell
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            PickleTableCell.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.value = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a PickleTableCell message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell} PickleTableCell
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            PickleTableCell.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a PickleTableCell message.
                             * @function verify
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            PickleTableCell.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.value != null && message.hasOwnProperty("value"))
                                    if (!$util.isString(message.value))
                                        return "value: string expected";
                                return null;
                            };

                            /**
                             * Creates a PickleTableCell message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell} PickleTableCell
                             */
                            PickleTableCell.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell)
                                    return object;
                                var message = new $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell();
                                if (object.value != null)
                                    message.value = String(object.value);
                                return message;
                            };

                            /**
                             * Creates a plain object from a PickleTableCell message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell} message PickleTableCell
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            PickleTableCell.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults)
                                    object.value = "";
                                if (message.value != null && message.hasOwnProperty("value"))
                                    object.value = message.value;
                                return object;
                            };

                            /**
                             * Converts this PickleTableCell to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            PickleTableCell.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return PickleTableCell;
                        })();

                        return PickleTableRow;
                    })();

                    return PickleTable;
                })();

                return PickleStepArgument;
            })();

            messages.TestCase = (function() {

                /**
                 * Properties of a TestCase.
                 * @memberof io.cucumber.messages
                 * @interface ITestCase
                 * @property {string|null} [id] TestCase id
                 * @property {string|null} [pickleId] TestCase pickleId
                 * @property {Array.<io.cucumber.messages.TestCase.ITestStep>|null} [testSteps] TestCase testSteps
                 */

                /**
                 * Constructs a new TestCase.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestCase.
                 * @implements ITestCase
                 * @constructor
                 * @param {io.cucumber.messages.ITestCase=} [properties] Properties to set
                 */
                function TestCase(properties) {
                    this.testSteps = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestCase id.
                 * @member {string} id
                 * @memberof io.cucumber.messages.TestCase
                 * @instance
                 */
                TestCase.prototype.id = "";

                /**
                 * TestCase pickleId.
                 * @member {string} pickleId
                 * @memberof io.cucumber.messages.TestCase
                 * @instance
                 */
                TestCase.prototype.pickleId = "";

                /**
                 * TestCase testSteps.
                 * @member {Array.<io.cucumber.messages.TestCase.ITestStep>} testSteps
                 * @memberof io.cucumber.messages.TestCase
                 * @instance
                 */
                TestCase.prototype.testSteps = $util.emptyArray;

                /**
                 * Creates a new TestCase instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {io.cucumber.messages.ITestCase=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestCase} TestCase instance
                 */
                TestCase.create = function create(properties) {
                    return new TestCase(properties);
                };

                /**
                 * Encodes the specified TestCase message. Does not implicitly {@link io.cucumber.messages.TestCase.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {io.cucumber.messages.ITestCase} message TestCase message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCase.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.pickleId != null && message.hasOwnProperty("pickleId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.pickleId);
                    if (message.testSteps != null && message.testSteps.length)
                        for (var i = 0; i < message.testSteps.length; ++i)
                            $root.io.cucumber.messages.TestCase.TestStep.encode(message.testSteps[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TestCase message, length delimited. Does not implicitly {@link io.cucumber.messages.TestCase.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {io.cucumber.messages.ITestCase} message TestCase message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCase.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestCase message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestCase} TestCase
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCase.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestCase();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.pickleId = reader.string();
                            break;
                        case 3:
                            if (!(message.testSteps && message.testSteps.length))
                                message.testSteps = [];
                            message.testSteps.push($root.io.cucumber.messages.TestCase.TestStep.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestCase message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestCase} TestCase
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCase.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestCase message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestCase.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.pickleId != null && message.hasOwnProperty("pickleId"))
                        if (!$util.isString(message.pickleId))
                            return "pickleId: string expected";
                    if (message.testSteps != null && message.hasOwnProperty("testSteps")) {
                        if (!Array.isArray(message.testSteps))
                            return "testSteps: array expected";
                        for (var i = 0; i < message.testSteps.length; ++i) {
                            var error = $root.io.cucumber.messages.TestCase.TestStep.verify(message.testSteps[i]);
                            if (error)
                                return "testSteps." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TestCase message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestCase} TestCase
                 */
                TestCase.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestCase)
                        return object;
                    var message = new $root.io.cucumber.messages.TestCase();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.pickleId != null)
                        message.pickleId = String(object.pickleId);
                    if (object.testSteps) {
                        if (!Array.isArray(object.testSteps))
                            throw TypeError(".io.cucumber.messages.TestCase.testSteps: array expected");
                        message.testSteps = [];
                        for (var i = 0; i < object.testSteps.length; ++i) {
                            if (typeof object.testSteps[i] !== "object")
                                throw TypeError(".io.cucumber.messages.TestCase.testSteps: object expected");
                            message.testSteps[i] = $root.io.cucumber.messages.TestCase.TestStep.fromObject(object.testSteps[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TestCase message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {io.cucumber.messages.TestCase} message TestCase
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestCase.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.testSteps = [];
                    if (options.defaults) {
                        object.id = "";
                        object.pickleId = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.pickleId != null && message.hasOwnProperty("pickleId"))
                        object.pickleId = message.pickleId;
                    if (message.testSteps && message.testSteps.length) {
                        object.testSteps = [];
                        for (var j = 0; j < message.testSteps.length; ++j)
                            object.testSteps[j] = $root.io.cucumber.messages.TestCase.TestStep.toObject(message.testSteps[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this TestCase to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestCase
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestCase.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                TestCase.TestStep = (function() {

                    /**
                     * Properties of a TestStep.
                     * @memberof io.cucumber.messages.TestCase
                     * @interface ITestStep
                     * @property {string|null} [id] TestStep id
                     * @property {string|null} [pickleStepId] TestStep pickleStepId
                     * @property {Array.<string>|null} [stepDefinitionIds] TestStep stepDefinitionIds
                     * @property {Array.<io.cucumber.messages.IStepMatchArgument>|null} [stepMatchArguments] TestStep stepMatchArguments
                     * @property {string|null} [hookId] TestStep hookId
                     */

                    /**
                     * Constructs a new TestStep.
                     * @memberof io.cucumber.messages.TestCase
                     * @classdesc Represents a TestStep.
                     * @implements ITestStep
                     * @constructor
                     * @param {io.cucumber.messages.TestCase.ITestStep=} [properties] Properties to set
                     */
                    function TestStep(properties) {
                        this.stepDefinitionIds = [];
                        this.stepMatchArguments = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TestStep id.
                     * @member {string} id
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @instance
                     */
                    TestStep.prototype.id = "";

                    /**
                     * TestStep pickleStepId.
                     * @member {string} pickleStepId
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @instance
                     */
                    TestStep.prototype.pickleStepId = "";

                    /**
                     * TestStep stepDefinitionIds.
                     * @member {Array.<string>} stepDefinitionIds
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @instance
                     */
                    TestStep.prototype.stepDefinitionIds = $util.emptyArray;

                    /**
                     * TestStep stepMatchArguments.
                     * @member {Array.<io.cucumber.messages.IStepMatchArgument>} stepMatchArguments
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @instance
                     */
                    TestStep.prototype.stepMatchArguments = $util.emptyArray;

                    /**
                     * TestStep hookId.
                     * @member {string} hookId
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @instance
                     */
                    TestStep.prototype.hookId = "";

                    /**
                     * Creates a new TestStep instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {io.cucumber.messages.TestCase.ITestStep=} [properties] Properties to set
                     * @returns {io.cucumber.messages.TestCase.TestStep} TestStep instance
                     */
                    TestStep.create = function create(properties) {
                        return new TestStep(properties);
                    };

                    /**
                     * Encodes the specified TestStep message. Does not implicitly {@link io.cucumber.messages.TestCase.TestStep.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {io.cucumber.messages.TestCase.ITestStep} message TestStep message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TestStep.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                        if (message.pickleStepId != null && message.hasOwnProperty("pickleStepId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.pickleStepId);
                        if (message.stepDefinitionIds != null && message.stepDefinitionIds.length)
                            for (var i = 0; i < message.stepDefinitionIds.length; ++i)
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stepDefinitionIds[i]);
                        if (message.stepMatchArguments != null && message.stepMatchArguments.length)
                            for (var i = 0; i < message.stepMatchArguments.length; ++i)
                                $root.io.cucumber.messages.StepMatchArgument.encode(message.stepMatchArguments[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.hookId != null && message.hasOwnProperty("hookId"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.hookId);
                        return writer;
                    };

                    /**
                     * Encodes the specified TestStep message, length delimited. Does not implicitly {@link io.cucumber.messages.TestCase.TestStep.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {io.cucumber.messages.TestCase.ITestStep} message TestStep message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TestStep.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TestStep message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.TestCase.TestStep} TestStep
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TestStep.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestCase.TestStep();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            case 2:
                                message.pickleStepId = reader.string();
                                break;
                            case 3:
                                if (!(message.stepDefinitionIds && message.stepDefinitionIds.length))
                                    message.stepDefinitionIds = [];
                                message.stepDefinitionIds.push(reader.string());
                                break;
                            case 4:
                                if (!(message.stepMatchArguments && message.stepMatchArguments.length))
                                    message.stepMatchArguments = [];
                                message.stepMatchArguments.push($root.io.cucumber.messages.StepMatchArgument.decode(reader, reader.uint32()));
                                break;
                            case 5:
                                message.hookId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TestStep message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.TestCase.TestStep} TestStep
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TestStep.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TestStep message.
                     * @function verify
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TestStep.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.pickleStepId != null && message.hasOwnProperty("pickleStepId"))
                            if (!$util.isString(message.pickleStepId))
                                return "pickleStepId: string expected";
                        if (message.stepDefinitionIds != null && message.hasOwnProperty("stepDefinitionIds")) {
                            if (!Array.isArray(message.stepDefinitionIds))
                                return "stepDefinitionIds: array expected";
                            for (var i = 0; i < message.stepDefinitionIds.length; ++i)
                                if (!$util.isString(message.stepDefinitionIds[i]))
                                    return "stepDefinitionIds: string[] expected";
                        }
                        if (message.stepMatchArguments != null && message.hasOwnProperty("stepMatchArguments")) {
                            if (!Array.isArray(message.stepMatchArguments))
                                return "stepMatchArguments: array expected";
                            for (var i = 0; i < message.stepMatchArguments.length; ++i) {
                                var error = $root.io.cucumber.messages.StepMatchArgument.verify(message.stepMatchArguments[i]);
                                if (error)
                                    return "stepMatchArguments." + error;
                            }
                        }
                        if (message.hookId != null && message.hasOwnProperty("hookId"))
                            if (!$util.isString(message.hookId))
                                return "hookId: string expected";
                        return null;
                    };

                    /**
                     * Creates a TestStep message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.TestCase.TestStep} TestStep
                     */
                    TestStep.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.TestCase.TestStep)
                            return object;
                        var message = new $root.io.cucumber.messages.TestCase.TestStep();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.pickleStepId != null)
                            message.pickleStepId = String(object.pickleStepId);
                        if (object.stepDefinitionIds) {
                            if (!Array.isArray(object.stepDefinitionIds))
                                throw TypeError(".io.cucumber.messages.TestCase.TestStep.stepDefinitionIds: array expected");
                            message.stepDefinitionIds = [];
                            for (var i = 0; i < object.stepDefinitionIds.length; ++i)
                                message.stepDefinitionIds[i] = String(object.stepDefinitionIds[i]);
                        }
                        if (object.stepMatchArguments) {
                            if (!Array.isArray(object.stepMatchArguments))
                                throw TypeError(".io.cucumber.messages.TestCase.TestStep.stepMatchArguments: array expected");
                            message.stepMatchArguments = [];
                            for (var i = 0; i < object.stepMatchArguments.length; ++i) {
                                if (typeof object.stepMatchArguments[i] !== "object")
                                    throw TypeError(".io.cucumber.messages.TestCase.TestStep.stepMatchArguments: object expected");
                                message.stepMatchArguments[i] = $root.io.cucumber.messages.StepMatchArgument.fromObject(object.stepMatchArguments[i]);
                            }
                        }
                        if (object.hookId != null)
                            message.hookId = String(object.hookId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a TestStep message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {io.cucumber.messages.TestCase.TestStep} message TestStep
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TestStep.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.stepDefinitionIds = [];
                            object.stepMatchArguments = [];
                        }
                        if (options.defaults) {
                            object.id = "";
                            object.pickleStepId = "";
                            object.hookId = "";
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.pickleStepId != null && message.hasOwnProperty("pickleStepId"))
                            object.pickleStepId = message.pickleStepId;
                        if (message.stepDefinitionIds && message.stepDefinitionIds.length) {
                            object.stepDefinitionIds = [];
                            for (var j = 0; j < message.stepDefinitionIds.length; ++j)
                                object.stepDefinitionIds[j] = message.stepDefinitionIds[j];
                        }
                        if (message.stepMatchArguments && message.stepMatchArguments.length) {
                            object.stepMatchArguments = [];
                            for (var j = 0; j < message.stepMatchArguments.length; ++j)
                                object.stepMatchArguments[j] = $root.io.cucumber.messages.StepMatchArgument.toObject(message.stepMatchArguments[j], options);
                        }
                        if (message.hookId != null && message.hasOwnProperty("hookId"))
                            object.hookId = message.hookId;
                        return object;
                    };

                    /**
                     * Converts this TestStep to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TestStep.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return TestStep;
                })();

                return TestCase;
            })();

            messages.PickleAccepted = (function() {

                /**
                 * Properties of a PickleAccepted.
                 * @memberof io.cucumber.messages
                 * @interface IPickleAccepted
                 * @property {string|null} [pickleId] PickleAccepted pickleId
                 */

                /**
                 * Constructs a new PickleAccepted.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a PickleAccepted.
                 * @implements IPickleAccepted
                 * @constructor
                 * @param {io.cucumber.messages.IPickleAccepted=} [properties] Properties to set
                 */
                function PickleAccepted(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PickleAccepted pickleId.
                 * @member {string} pickleId
                 * @memberof io.cucumber.messages.PickleAccepted
                 * @instance
                 */
                PickleAccepted.prototype.pickleId = "";

                /**
                 * Creates a new PickleAccepted instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.PickleAccepted
                 * @static
                 * @param {io.cucumber.messages.IPickleAccepted=} [properties] Properties to set
                 * @returns {io.cucumber.messages.PickleAccepted} PickleAccepted instance
                 */
                PickleAccepted.create = function create(properties) {
                    return new PickleAccepted(properties);
                };

                /**
                 * Encodes the specified PickleAccepted message. Does not implicitly {@link io.cucumber.messages.PickleAccepted.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.PickleAccepted
                 * @static
                 * @param {io.cucumber.messages.IPickleAccepted} message PickleAccepted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PickleAccepted.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pickleId != null && message.hasOwnProperty("pickleId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.pickleId);
                    return writer;
                };

                /**
                 * Encodes the specified PickleAccepted message, length delimited. Does not implicitly {@link io.cucumber.messages.PickleAccepted.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.PickleAccepted
                 * @static
                 * @param {io.cucumber.messages.IPickleAccepted} message PickleAccepted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PickleAccepted.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PickleAccepted message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.PickleAccepted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.PickleAccepted} PickleAccepted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PickleAccepted.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.PickleAccepted();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pickleId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PickleAccepted message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.PickleAccepted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.PickleAccepted} PickleAccepted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PickleAccepted.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PickleAccepted message.
                 * @function verify
                 * @memberof io.cucumber.messages.PickleAccepted
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PickleAccepted.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pickleId != null && message.hasOwnProperty("pickleId"))
                        if (!$util.isString(message.pickleId))
                            return "pickleId: string expected";
                    return null;
                };

                /**
                 * Creates a PickleAccepted message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.PickleAccepted
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.PickleAccepted} PickleAccepted
                 */
                PickleAccepted.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.PickleAccepted)
                        return object;
                    var message = new $root.io.cucumber.messages.PickleAccepted();
                    if (object.pickleId != null)
                        message.pickleId = String(object.pickleId);
                    return message;
                };

                /**
                 * Creates a plain object from a PickleAccepted message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.PickleAccepted
                 * @static
                 * @param {io.cucumber.messages.PickleAccepted} message PickleAccepted
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PickleAccepted.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.pickleId = "";
                    if (message.pickleId != null && message.hasOwnProperty("pickleId"))
                        object.pickleId = message.pickleId;
                    return object;
                };

                /**
                 * Converts this PickleAccepted to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.PickleAccepted
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PickleAccepted.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PickleAccepted;
            })();

            messages.PickleRejected = (function() {

                /**
                 * Properties of a PickleRejected.
                 * @memberof io.cucumber.messages
                 * @interface IPickleRejected
                 * @property {string|null} [pickleId] PickleRejected pickleId
                 */

                /**
                 * Constructs a new PickleRejected.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a PickleRejected.
                 * @implements IPickleRejected
                 * @constructor
                 * @param {io.cucumber.messages.IPickleRejected=} [properties] Properties to set
                 */
                function PickleRejected(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PickleRejected pickleId.
                 * @member {string} pickleId
                 * @memberof io.cucumber.messages.PickleRejected
                 * @instance
                 */
                PickleRejected.prototype.pickleId = "";

                /**
                 * Creates a new PickleRejected instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.PickleRejected
                 * @static
                 * @param {io.cucumber.messages.IPickleRejected=} [properties] Properties to set
                 * @returns {io.cucumber.messages.PickleRejected} PickleRejected instance
                 */
                PickleRejected.create = function create(properties) {
                    return new PickleRejected(properties);
                };

                /**
                 * Encodes the specified PickleRejected message. Does not implicitly {@link io.cucumber.messages.PickleRejected.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.PickleRejected
                 * @static
                 * @param {io.cucumber.messages.IPickleRejected} message PickleRejected message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PickleRejected.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pickleId != null && message.hasOwnProperty("pickleId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.pickleId);
                    return writer;
                };

                /**
                 * Encodes the specified PickleRejected message, length delimited. Does not implicitly {@link io.cucumber.messages.PickleRejected.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.PickleRejected
                 * @static
                 * @param {io.cucumber.messages.IPickleRejected} message PickleRejected message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PickleRejected.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PickleRejected message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.PickleRejected
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.PickleRejected} PickleRejected
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PickleRejected.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.PickleRejected();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            message.pickleId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PickleRejected message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.PickleRejected
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.PickleRejected} PickleRejected
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PickleRejected.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PickleRejected message.
                 * @function verify
                 * @memberof io.cucumber.messages.PickleRejected
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PickleRejected.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pickleId != null && message.hasOwnProperty("pickleId"))
                        if (!$util.isString(message.pickleId))
                            return "pickleId: string expected";
                    return null;
                };

                /**
                 * Creates a PickleRejected message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.PickleRejected
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.PickleRejected} PickleRejected
                 */
                PickleRejected.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.PickleRejected)
                        return object;
                    var message = new $root.io.cucumber.messages.PickleRejected();
                    if (object.pickleId != null)
                        message.pickleId = String(object.pickleId);
                    return message;
                };

                /**
                 * Creates a plain object from a PickleRejected message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.PickleRejected
                 * @static
                 * @param {io.cucumber.messages.PickleRejected} message PickleRejected
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PickleRejected.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.pickleId = "";
                    if (message.pickleId != null && message.hasOwnProperty("pickleId"))
                        object.pickleId = message.pickleId;
                    return object;
                };

                /**
                 * Converts this PickleRejected to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.PickleRejected
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PickleRejected.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PickleRejected;
            })();

            messages.TestRunStarted = (function() {

                /**
                 * Properties of a TestRunStarted.
                 * @memberof io.cucumber.messages
                 * @interface ITestRunStarted
                 * @property {io.cucumber.messages.ITimestamp|null} [timestamp] TestRunStarted timestamp
                 */

                /**
                 * Constructs a new TestRunStarted.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestRunStarted.
                 * @implements ITestRunStarted
                 * @constructor
                 * @param {io.cucumber.messages.ITestRunStarted=} [properties] Properties to set
                 */
                function TestRunStarted(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestRunStarted timestamp.
                 * @member {io.cucumber.messages.ITimestamp|null|undefined} timestamp
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @instance
                 */
                TestRunStarted.prototype.timestamp = null;

                /**
                 * Creates a new TestRunStarted instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {io.cucumber.messages.ITestRunStarted=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestRunStarted} TestRunStarted instance
                 */
                TestRunStarted.create = function create(properties) {
                    return new TestRunStarted(properties);
                };

                /**
                 * Encodes the specified TestRunStarted message. Does not implicitly {@link io.cucumber.messages.TestRunStarted.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {io.cucumber.messages.ITestRunStarted} message TestRunStarted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestRunStarted.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        $root.io.cucumber.messages.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TestRunStarted message, length delimited. Does not implicitly {@link io.cucumber.messages.TestRunStarted.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {io.cucumber.messages.ITestRunStarted} message TestRunStarted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestRunStarted.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestRunStarted message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestRunStarted} TestRunStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestRunStarted.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestRunStarted();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestamp = $root.io.cucumber.messages.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestRunStarted message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestRunStarted} TestRunStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestRunStarted.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestRunStarted message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestRunStarted.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.io.cucumber.messages.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    return null;
                };

                /**
                 * Creates a TestRunStarted message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestRunStarted} TestRunStarted
                 */
                TestRunStarted.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestRunStarted)
                        return object;
                    var message = new $root.io.cucumber.messages.TestRunStarted();
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".io.cucumber.messages.TestRunStarted.timestamp: object expected");
                        message.timestamp = $root.io.cucumber.messages.Timestamp.fromObject(object.timestamp);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TestRunStarted message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {io.cucumber.messages.TestRunStarted} message TestRunStarted
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestRunStarted.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.timestamp = null;
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.io.cucumber.messages.Timestamp.toObject(message.timestamp, options);
                    return object;
                };

                /**
                 * Converts this TestRunStarted to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestRunStarted.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TestRunStarted;
            })();

            messages.TestCasePreparedStep = (function() {

                /**
                 * Properties of a TestCasePreparedStep.
                 * @memberof io.cucumber.messages
                 * @interface ITestCasePreparedStep
                 * @property {io.cucumber.messages.ISourceReference|null} [sourceLocation] TestCasePreparedStep sourceLocation
                 * @property {io.cucumber.messages.ISourceReference|null} [actionLocation] TestCasePreparedStep actionLocation
                 */

                /**
                 * Constructs a new TestCasePreparedStep.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestCasePreparedStep.
                 * @implements ITestCasePreparedStep
                 * @constructor
                 * @param {io.cucumber.messages.ITestCasePreparedStep=} [properties] Properties to set
                 */
                function TestCasePreparedStep(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestCasePreparedStep sourceLocation.
                 * @member {io.cucumber.messages.ISourceReference|null|undefined} sourceLocation
                 * @memberof io.cucumber.messages.TestCasePreparedStep
                 * @instance
                 */
                TestCasePreparedStep.prototype.sourceLocation = null;

                /**
                 * TestCasePreparedStep actionLocation.
                 * @member {io.cucumber.messages.ISourceReference|null|undefined} actionLocation
                 * @memberof io.cucumber.messages.TestCasePreparedStep
                 * @instance
                 */
                TestCasePreparedStep.prototype.actionLocation = null;

                /**
                 * Creates a new TestCasePreparedStep instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestCasePreparedStep
                 * @static
                 * @param {io.cucumber.messages.ITestCasePreparedStep=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestCasePreparedStep} TestCasePreparedStep instance
                 */
                TestCasePreparedStep.create = function create(properties) {
                    return new TestCasePreparedStep(properties);
                };

                /**
                 * Encodes the specified TestCasePreparedStep message. Does not implicitly {@link io.cucumber.messages.TestCasePreparedStep.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestCasePreparedStep
                 * @static
                 * @param {io.cucumber.messages.ITestCasePreparedStep} message TestCasePreparedStep message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCasePreparedStep.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sourceLocation != null && message.hasOwnProperty("sourceLocation"))
                        $root.io.cucumber.messages.SourceReference.encode(message.sourceLocation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.actionLocation != null && message.hasOwnProperty("actionLocation"))
                        $root.io.cucumber.messages.SourceReference.encode(message.actionLocation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TestCasePreparedStep message, length delimited. Does not implicitly {@link io.cucumber.messages.TestCasePreparedStep.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestCasePreparedStep
                 * @static
                 * @param {io.cucumber.messages.ITestCasePreparedStep} message TestCasePreparedStep message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCasePreparedStep.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestCasePreparedStep message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestCasePreparedStep
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestCasePreparedStep} TestCasePreparedStep
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCasePreparedStep.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestCasePreparedStep();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sourceLocation = $root.io.cucumber.messages.SourceReference.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.actionLocation = $root.io.cucumber.messages.SourceReference.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestCasePreparedStep message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestCasePreparedStep
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestCasePreparedStep} TestCasePreparedStep
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCasePreparedStep.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestCasePreparedStep message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestCasePreparedStep
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestCasePreparedStep.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sourceLocation != null && message.hasOwnProperty("sourceLocation")) {
                        var error = $root.io.cucumber.messages.SourceReference.verify(message.sourceLocation);
                        if (error)
                            return "sourceLocation." + error;
                    }
                    if (message.actionLocation != null && message.hasOwnProperty("actionLocation")) {
                        var error = $root.io.cucumber.messages.SourceReference.verify(message.actionLocation);
                        if (error)
                            return "actionLocation." + error;
                    }
                    return null;
                };

                /**
                 * Creates a TestCasePreparedStep message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestCasePreparedStep
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestCasePreparedStep} TestCasePreparedStep
                 */
                TestCasePreparedStep.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestCasePreparedStep)
                        return object;
                    var message = new $root.io.cucumber.messages.TestCasePreparedStep();
                    if (object.sourceLocation != null) {
                        if (typeof object.sourceLocation !== "object")
                            throw TypeError(".io.cucumber.messages.TestCasePreparedStep.sourceLocation: object expected");
                        message.sourceLocation = $root.io.cucumber.messages.SourceReference.fromObject(object.sourceLocation);
                    }
                    if (object.actionLocation != null) {
                        if (typeof object.actionLocation !== "object")
                            throw TypeError(".io.cucumber.messages.TestCasePreparedStep.actionLocation: object expected");
                        message.actionLocation = $root.io.cucumber.messages.SourceReference.fromObject(object.actionLocation);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TestCasePreparedStep message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestCasePreparedStep
                 * @static
                 * @param {io.cucumber.messages.TestCasePreparedStep} message TestCasePreparedStep
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestCasePreparedStep.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sourceLocation = null;
                        object.actionLocation = null;
                    }
                    if (message.sourceLocation != null && message.hasOwnProperty("sourceLocation"))
                        object.sourceLocation = $root.io.cucumber.messages.SourceReference.toObject(message.sourceLocation, options);
                    if (message.actionLocation != null && message.hasOwnProperty("actionLocation"))
                        object.actionLocation = $root.io.cucumber.messages.SourceReference.toObject(message.actionLocation, options);
                    return object;
                };

                /**
                 * Converts this TestCasePreparedStep to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestCasePreparedStep
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestCasePreparedStep.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TestCasePreparedStep;
            })();

            messages.TestCasePrepared = (function() {

                /**
                 * Properties of a TestCasePrepared.
                 * @memberof io.cucumber.messages
                 * @interface ITestCasePrepared
                 * @property {string|null} [pickleId] TestCasePrepared pickleId
                 * @property {Array.<io.cucumber.messages.ITestCasePreparedStep>|null} [steps] TestCasePrepared steps
                 */

                /**
                 * Constructs a new TestCasePrepared.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestCasePrepared.
                 * @implements ITestCasePrepared
                 * @constructor
                 * @param {io.cucumber.messages.ITestCasePrepared=} [properties] Properties to set
                 */
                function TestCasePrepared(properties) {
                    this.steps = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestCasePrepared pickleId.
                 * @member {string} pickleId
                 * @memberof io.cucumber.messages.TestCasePrepared
                 * @instance
                 */
                TestCasePrepared.prototype.pickleId = "";

                /**
                 * TestCasePrepared steps.
                 * @member {Array.<io.cucumber.messages.ITestCasePreparedStep>} steps
                 * @memberof io.cucumber.messages.TestCasePrepared
                 * @instance
                 */
                TestCasePrepared.prototype.steps = $util.emptyArray;

                /**
                 * Creates a new TestCasePrepared instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestCasePrepared
                 * @static
                 * @param {io.cucumber.messages.ITestCasePrepared=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestCasePrepared} TestCasePrepared instance
                 */
                TestCasePrepared.create = function create(properties) {
                    return new TestCasePrepared(properties);
                };

                /**
                 * Encodes the specified TestCasePrepared message. Does not implicitly {@link io.cucumber.messages.TestCasePrepared.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestCasePrepared
                 * @static
                 * @param {io.cucumber.messages.ITestCasePrepared} message TestCasePrepared message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCasePrepared.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pickleId != null && message.hasOwnProperty("pickleId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.pickleId);
                    if (message.steps != null && message.steps.length)
                        for (var i = 0; i < message.steps.length; ++i)
                            $root.io.cucumber.messages.TestCasePreparedStep.encode(message.steps[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TestCasePrepared message, length delimited. Does not implicitly {@link io.cucumber.messages.TestCasePrepared.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestCasePrepared
                 * @static
                 * @param {io.cucumber.messages.ITestCasePrepared} message TestCasePrepared message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCasePrepared.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestCasePrepared message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestCasePrepared
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestCasePrepared} TestCasePrepared
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCasePrepared.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestCasePrepared();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pickleId = reader.string();
                            break;
                        case 2:
                            if (!(message.steps && message.steps.length))
                                message.steps = [];
                            message.steps.push($root.io.cucumber.messages.TestCasePreparedStep.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestCasePrepared message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestCasePrepared
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestCasePrepared} TestCasePrepared
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCasePrepared.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestCasePrepared message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestCasePrepared
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestCasePrepared.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pickleId != null && message.hasOwnProperty("pickleId"))
                        if (!$util.isString(message.pickleId))
                            return "pickleId: string expected";
                    if (message.steps != null && message.hasOwnProperty("steps")) {
                        if (!Array.isArray(message.steps))
                            return "steps: array expected";
                        for (var i = 0; i < message.steps.length; ++i) {
                            var error = $root.io.cucumber.messages.TestCasePreparedStep.verify(message.steps[i]);
                            if (error)
                                return "steps." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TestCasePrepared message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestCasePrepared
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestCasePrepared} TestCasePrepared
                 */
                TestCasePrepared.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestCasePrepared)
                        return object;
                    var message = new $root.io.cucumber.messages.TestCasePrepared();
                    if (object.pickleId != null)
                        message.pickleId = String(object.pickleId);
                    if (object.steps) {
                        if (!Array.isArray(object.steps))
                            throw TypeError(".io.cucumber.messages.TestCasePrepared.steps: array expected");
                        message.steps = [];
                        for (var i = 0; i < object.steps.length; ++i) {
                            if (typeof object.steps[i] !== "object")
                                throw TypeError(".io.cucumber.messages.TestCasePrepared.steps: object expected");
                            message.steps[i] = $root.io.cucumber.messages.TestCasePreparedStep.fromObject(object.steps[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TestCasePrepared message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestCasePrepared
                 * @static
                 * @param {io.cucumber.messages.TestCasePrepared} message TestCasePrepared
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestCasePrepared.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.steps = [];
                    if (options.defaults)
                        object.pickleId = "";
                    if (message.pickleId != null && message.hasOwnProperty("pickleId"))
                        object.pickleId = message.pickleId;
                    if (message.steps && message.steps.length) {
                        object.steps = [];
                        for (var j = 0; j < message.steps.length; ++j)
                            object.steps[j] = $root.io.cucumber.messages.TestCasePreparedStep.toObject(message.steps[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this TestCasePrepared to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestCasePrepared
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestCasePrepared.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TestCasePrepared;
            })();

            messages.TestCaseStarted = (function() {

                /**
                 * Properties of a TestCaseStarted.
                 * @memberof io.cucumber.messages
                 * @interface ITestCaseStarted
                 * @property {io.cucumber.messages.ITimestamp|null} [timestamp] TestCaseStarted timestamp
                 * @property {io.cucumber.messages.TestCaseStarted.IPlatform|null} [platform] TestCaseStarted platform
                 * @property {number|null} [attempt] The first attempt should have value 0, and for each retry the value
                 * should increase by 1.
                 * @property {string|null} [testCaseId] TestCaseStarted testCaseId
                 * @property {string|null} [id] Because a `TestCase` can be run multiple times (in case of a retry),
                 * we use this field to group messages relating to the same attempt.
                 */

                /**
                 * Constructs a new TestCaseStarted.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestCaseStarted.
                 * @implements ITestCaseStarted
                 * @constructor
                 * @param {io.cucumber.messages.ITestCaseStarted=} [properties] Properties to set
                 */
                function TestCaseStarted(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestCaseStarted timestamp.
                 * @member {io.cucumber.messages.ITimestamp|null|undefined} timestamp
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @instance
                 */
                TestCaseStarted.prototype.timestamp = null;

                /**
                 * TestCaseStarted platform.
                 * @member {io.cucumber.messages.TestCaseStarted.IPlatform|null|undefined} platform
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @instance
                 */
                TestCaseStarted.prototype.platform = null;

                /**
                 * The first attempt should have value 0, and for each retry the value
                 * should increase by 1.
                 * @member {number} attempt
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @instance
                 */
                TestCaseStarted.prototype.attempt = 0;

                /**
                 * TestCaseStarted testCaseId.
                 * @member {string} testCaseId
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @instance
                 */
                TestCaseStarted.prototype.testCaseId = "";

                /**
                 * Because a `TestCase` can be run multiple times (in case of a retry),
                 * we use this field to group messages relating to the same attempt.
                 * @member {string} id
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @instance
                 */
                TestCaseStarted.prototype.id = "";

                /**
                 * Creates a new TestCaseStarted instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {io.cucumber.messages.ITestCaseStarted=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestCaseStarted} TestCaseStarted instance
                 */
                TestCaseStarted.create = function create(properties) {
                    return new TestCaseStarted(properties);
                };

                /**
                 * Encodes the specified TestCaseStarted message. Does not implicitly {@link io.cucumber.messages.TestCaseStarted.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {io.cucumber.messages.ITestCaseStarted} message TestCaseStarted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCaseStarted.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        $root.io.cucumber.messages.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.platform != null && message.hasOwnProperty("platform"))
                        $root.io.cucumber.messages.TestCaseStarted.Platform.encode(message.platform, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.attempt != null && message.hasOwnProperty("attempt"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.attempt);
                    if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.testCaseId);
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.id);
                    return writer;
                };

                /**
                 * Encodes the specified TestCaseStarted message, length delimited. Does not implicitly {@link io.cucumber.messages.TestCaseStarted.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {io.cucumber.messages.ITestCaseStarted} message TestCaseStarted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCaseStarted.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestCaseStarted message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestCaseStarted} TestCaseStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCaseStarted.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestCaseStarted();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestamp = $root.io.cucumber.messages.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.platform = $root.io.cucumber.messages.TestCaseStarted.Platform.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.attempt = reader.uint32();
                            break;
                        case 4:
                            message.testCaseId = reader.string();
                            break;
                        case 5:
                            message.id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestCaseStarted message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestCaseStarted} TestCaseStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCaseStarted.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestCaseStarted message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestCaseStarted.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.io.cucumber.messages.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    if (message.platform != null && message.hasOwnProperty("platform")) {
                        var error = $root.io.cucumber.messages.TestCaseStarted.Platform.verify(message.platform);
                        if (error)
                            return "platform." + error;
                    }
                    if (message.attempt != null && message.hasOwnProperty("attempt"))
                        if (!$util.isInteger(message.attempt))
                            return "attempt: integer expected";
                    if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                        if (!$util.isString(message.testCaseId))
                            return "testCaseId: string expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    return null;
                };

                /**
                 * Creates a TestCaseStarted message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestCaseStarted} TestCaseStarted
                 */
                TestCaseStarted.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestCaseStarted)
                        return object;
                    var message = new $root.io.cucumber.messages.TestCaseStarted();
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".io.cucumber.messages.TestCaseStarted.timestamp: object expected");
                        message.timestamp = $root.io.cucumber.messages.Timestamp.fromObject(object.timestamp);
                    }
                    if (object.platform != null) {
                        if (typeof object.platform !== "object")
                            throw TypeError(".io.cucumber.messages.TestCaseStarted.platform: object expected");
                        message.platform = $root.io.cucumber.messages.TestCaseStarted.Platform.fromObject(object.platform);
                    }
                    if (object.attempt != null)
                        message.attempt = object.attempt >>> 0;
                    if (object.testCaseId != null)
                        message.testCaseId = String(object.testCaseId);
                    if (object.id != null)
                        message.id = String(object.id);
                    return message;
                };

                /**
                 * Creates a plain object from a TestCaseStarted message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {io.cucumber.messages.TestCaseStarted} message TestCaseStarted
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestCaseStarted.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.timestamp = null;
                        object.platform = null;
                        object.attempt = 0;
                        object.testCaseId = "";
                        object.id = "";
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.io.cucumber.messages.Timestamp.toObject(message.timestamp, options);
                    if (message.platform != null && message.hasOwnProperty("platform"))
                        object.platform = $root.io.cucumber.messages.TestCaseStarted.Platform.toObject(message.platform, options);
                    if (message.attempt != null && message.hasOwnProperty("attempt"))
                        object.attempt = message.attempt;
                    if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                        object.testCaseId = message.testCaseId;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    return object;
                };

                /**
                 * Converts this TestCaseStarted to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestCaseStarted.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                TestCaseStarted.Platform = (function() {

                    /**
                     * Properties of a Platform.
                     * @memberof io.cucumber.messages.TestCaseStarted
                     * @interface IPlatform
                     * @property {string|null} [implementation] Platform implementation
                     * @property {string|null} [version] Platform version
                     * @property {string|null} [os] Platform os
                     * @property {string|null} [cpu] Platform cpu
                     */

                    /**
                     * Constructs a new Platform.
                     * @memberof io.cucumber.messages.TestCaseStarted
                     * @classdesc Represents a Platform.
                     * @implements IPlatform
                     * @constructor
                     * @param {io.cucumber.messages.TestCaseStarted.IPlatform=} [properties] Properties to set
                     */
                    function Platform(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Platform implementation.
                     * @member {string} implementation
                     * @memberof io.cucumber.messages.TestCaseStarted.Platform
                     * @instance
                     */
                    Platform.prototype.implementation = "";

                    /**
                     * Platform version.
                     * @member {string} version
                     * @memberof io.cucumber.messages.TestCaseStarted.Platform
                     * @instance
                     */
                    Platform.prototype.version = "";

                    /**
                     * Platform os.
                     * @member {string} os
                     * @memberof io.cucumber.messages.TestCaseStarted.Platform
                     * @instance
                     */
                    Platform.prototype.os = "";

                    /**
                     * Platform cpu.
                     * @member {string} cpu
                     * @memberof io.cucumber.messages.TestCaseStarted.Platform
                     * @instance
                     */
                    Platform.prototype.cpu = "";

                    /**
                     * Creates a new Platform instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.TestCaseStarted.Platform
                     * @static
                     * @param {io.cucumber.messages.TestCaseStarted.IPlatform=} [properties] Properties to set
                     * @returns {io.cucumber.messages.TestCaseStarted.Platform} Platform instance
                     */
                    Platform.create = function create(properties) {
                        return new Platform(properties);
                    };

                    /**
                     * Encodes the specified Platform message. Does not implicitly {@link io.cucumber.messages.TestCaseStarted.Platform.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.TestCaseStarted.Platform
                     * @static
                     * @param {io.cucumber.messages.TestCaseStarted.IPlatform} message Platform message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Platform.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.implementation != null && message.hasOwnProperty("implementation"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.implementation);
                        if (message.version != null && message.hasOwnProperty("version"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                        if (message.os != null && message.hasOwnProperty("os"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.os);
                        if (message.cpu != null && message.hasOwnProperty("cpu"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.cpu);
                        return writer;
                    };

                    /**
                     * Encodes the specified Platform message, length delimited. Does not implicitly {@link io.cucumber.messages.TestCaseStarted.Platform.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.TestCaseStarted.Platform
                     * @static
                     * @param {io.cucumber.messages.TestCaseStarted.IPlatform} message Platform message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Platform.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Platform message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.TestCaseStarted.Platform
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.TestCaseStarted.Platform} Platform
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Platform.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestCaseStarted.Platform();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.implementation = reader.string();
                                break;
                            case 2:
                                message.version = reader.string();
                                break;
                            case 3:
                                message.os = reader.string();
                                break;
                            case 4:
                                message.cpu = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Platform message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.TestCaseStarted.Platform
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.TestCaseStarted.Platform} Platform
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Platform.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Platform message.
                     * @function verify
                     * @memberof io.cucumber.messages.TestCaseStarted.Platform
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Platform.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.implementation != null && message.hasOwnProperty("implementation"))
                            if (!$util.isString(message.implementation))
                                return "implementation: string expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isString(message.version))
                                return "version: string expected";
                        if (message.os != null && message.hasOwnProperty("os"))
                            if (!$util.isString(message.os))
                                return "os: string expected";
                        if (message.cpu != null && message.hasOwnProperty("cpu"))
                            if (!$util.isString(message.cpu))
                                return "cpu: string expected";
                        return null;
                    };

                    /**
                     * Creates a Platform message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.TestCaseStarted.Platform
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.TestCaseStarted.Platform} Platform
                     */
                    Platform.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.TestCaseStarted.Platform)
                            return object;
                        var message = new $root.io.cucumber.messages.TestCaseStarted.Platform();
                        if (object.implementation != null)
                            message.implementation = String(object.implementation);
                        if (object.version != null)
                            message.version = String(object.version);
                        if (object.os != null)
                            message.os = String(object.os);
                        if (object.cpu != null)
                            message.cpu = String(object.cpu);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Platform message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.TestCaseStarted.Platform
                     * @static
                     * @param {io.cucumber.messages.TestCaseStarted.Platform} message Platform
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Platform.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.implementation = "";
                            object.version = "";
                            object.os = "";
                            object.cpu = "";
                        }
                        if (message.implementation != null && message.hasOwnProperty("implementation"))
                            object.implementation = message.implementation;
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.os != null && message.hasOwnProperty("os"))
                            object.os = message.os;
                        if (message.cpu != null && message.hasOwnProperty("cpu"))
                            object.cpu = message.cpu;
                        return object;
                    };

                    /**
                     * Converts this Platform to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.TestCaseStarted.Platform
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Platform.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Platform;
                })();

                return TestCaseStarted;
            })();

            messages.TestCaseFinished = (function() {

                /**
                 * Properties of a TestCaseFinished.
                 * @memberof io.cucumber.messages
                 * @interface ITestCaseFinished
                 * @property {io.cucumber.messages.ITimestamp|null} [timestamp] TestCaseFinished timestamp
                 * @property {io.cucumber.messages.ITestResult|null} [testResult] TestCaseFinished testResult
                 * @property {string|null} [testCaseStartedId] TestCaseFinished testCaseStartedId
                 */

                /**
                 * Constructs a new TestCaseFinished.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestCaseFinished.
                 * @implements ITestCaseFinished
                 * @constructor
                 * @param {io.cucumber.messages.ITestCaseFinished=} [properties] Properties to set
                 */
                function TestCaseFinished(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestCaseFinished timestamp.
                 * @member {io.cucumber.messages.ITimestamp|null|undefined} timestamp
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @instance
                 */
                TestCaseFinished.prototype.timestamp = null;

                /**
                 * TestCaseFinished testResult.
                 * @member {io.cucumber.messages.ITestResult|null|undefined} testResult
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @instance
                 */
                TestCaseFinished.prototype.testResult = null;

                /**
                 * TestCaseFinished testCaseStartedId.
                 * @member {string} testCaseStartedId
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @instance
                 */
                TestCaseFinished.prototype.testCaseStartedId = "";

                /**
                 * Creates a new TestCaseFinished instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {io.cucumber.messages.ITestCaseFinished=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestCaseFinished} TestCaseFinished instance
                 */
                TestCaseFinished.create = function create(properties) {
                    return new TestCaseFinished(properties);
                };

                /**
                 * Encodes the specified TestCaseFinished message. Does not implicitly {@link io.cucumber.messages.TestCaseFinished.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {io.cucumber.messages.ITestCaseFinished} message TestCaseFinished message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCaseFinished.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        $root.io.cucumber.messages.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.testResult != null && message.hasOwnProperty("testResult"))
                        $root.io.cucumber.messages.TestResult.encode(message.testResult, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.testCaseStartedId);
                    return writer;
                };

                /**
                 * Encodes the specified TestCaseFinished message, length delimited. Does not implicitly {@link io.cucumber.messages.TestCaseFinished.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {io.cucumber.messages.ITestCaseFinished} message TestCaseFinished message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCaseFinished.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestCaseFinished message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestCaseFinished} TestCaseFinished
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCaseFinished.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestCaseFinished();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestamp = $root.io.cucumber.messages.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.testResult = $root.io.cucumber.messages.TestResult.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.testCaseStartedId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestCaseFinished message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestCaseFinished} TestCaseFinished
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCaseFinished.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestCaseFinished message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestCaseFinished.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.io.cucumber.messages.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    if (message.testResult != null && message.hasOwnProperty("testResult")) {
                        var error = $root.io.cucumber.messages.TestResult.verify(message.testResult);
                        if (error)
                            return "testResult." + error;
                    }
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        if (!$util.isString(message.testCaseStartedId))
                            return "testCaseStartedId: string expected";
                    return null;
                };

                /**
                 * Creates a TestCaseFinished message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestCaseFinished} TestCaseFinished
                 */
                TestCaseFinished.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestCaseFinished)
                        return object;
                    var message = new $root.io.cucumber.messages.TestCaseFinished();
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".io.cucumber.messages.TestCaseFinished.timestamp: object expected");
                        message.timestamp = $root.io.cucumber.messages.Timestamp.fromObject(object.timestamp);
                    }
                    if (object.testResult != null) {
                        if (typeof object.testResult !== "object")
                            throw TypeError(".io.cucumber.messages.TestCaseFinished.testResult: object expected");
                        message.testResult = $root.io.cucumber.messages.TestResult.fromObject(object.testResult);
                    }
                    if (object.testCaseStartedId != null)
                        message.testCaseStartedId = String(object.testCaseStartedId);
                    return message;
                };

                /**
                 * Creates a plain object from a TestCaseFinished message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {io.cucumber.messages.TestCaseFinished} message TestCaseFinished
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestCaseFinished.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.timestamp = null;
                        object.testResult = null;
                        object.testCaseStartedId = "";
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.io.cucumber.messages.Timestamp.toObject(message.timestamp, options);
                    if (message.testResult != null && message.hasOwnProperty("testResult"))
                        object.testResult = $root.io.cucumber.messages.TestResult.toObject(message.testResult, options);
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        object.testCaseStartedId = message.testCaseStartedId;
                    return object;
                };

                /**
                 * Converts this TestCaseFinished to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestCaseFinished.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TestCaseFinished;
            })();

            messages.TestStepStarted = (function() {

                /**
                 * Properties of a TestStepStarted.
                 * @memberof io.cucumber.messages
                 * @interface ITestStepStarted
                 * @property {io.cucumber.messages.ITimestamp|null} [timestamp] TestStepStarted timestamp
                 * @property {string|null} [testStepId] TestStepStarted testStepId
                 * @property {string|null} [testCaseStartedId] TestStepStarted testCaseStartedId
                 */

                /**
                 * Constructs a new TestStepStarted.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestStepStarted.
                 * @implements ITestStepStarted
                 * @constructor
                 * @param {io.cucumber.messages.ITestStepStarted=} [properties] Properties to set
                 */
                function TestStepStarted(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestStepStarted timestamp.
                 * @member {io.cucumber.messages.ITimestamp|null|undefined} timestamp
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @instance
                 */
                TestStepStarted.prototype.timestamp = null;

                /**
                 * TestStepStarted testStepId.
                 * @member {string} testStepId
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @instance
                 */
                TestStepStarted.prototype.testStepId = "";

                /**
                 * TestStepStarted testCaseStartedId.
                 * @member {string} testCaseStartedId
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @instance
                 */
                TestStepStarted.prototype.testCaseStartedId = "";

                /**
                 * Creates a new TestStepStarted instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {io.cucumber.messages.ITestStepStarted=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestStepStarted} TestStepStarted instance
                 */
                TestStepStarted.create = function create(properties) {
                    return new TestStepStarted(properties);
                };

                /**
                 * Encodes the specified TestStepStarted message. Does not implicitly {@link io.cucumber.messages.TestStepStarted.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {io.cucumber.messages.ITestStepStarted} message TestStepStarted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestStepStarted.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        $root.io.cucumber.messages.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.testStepId);
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.testCaseStartedId);
                    return writer;
                };

                /**
                 * Encodes the specified TestStepStarted message, length delimited. Does not implicitly {@link io.cucumber.messages.TestStepStarted.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {io.cucumber.messages.ITestStepStarted} message TestStepStarted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestStepStarted.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestStepStarted message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestStepStarted} TestStepStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestStepStarted.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestStepStarted();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestamp = $root.io.cucumber.messages.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.testStepId = reader.string();
                            break;
                        case 3:
                            message.testCaseStartedId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestStepStarted message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestStepStarted} TestStepStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestStepStarted.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestStepStarted message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestStepStarted.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.io.cucumber.messages.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        if (!$util.isString(message.testStepId))
                            return "testStepId: string expected";
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        if (!$util.isString(message.testCaseStartedId))
                            return "testCaseStartedId: string expected";
                    return null;
                };

                /**
                 * Creates a TestStepStarted message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestStepStarted} TestStepStarted
                 */
                TestStepStarted.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestStepStarted)
                        return object;
                    var message = new $root.io.cucumber.messages.TestStepStarted();
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".io.cucumber.messages.TestStepStarted.timestamp: object expected");
                        message.timestamp = $root.io.cucumber.messages.Timestamp.fromObject(object.timestamp);
                    }
                    if (object.testStepId != null)
                        message.testStepId = String(object.testStepId);
                    if (object.testCaseStartedId != null)
                        message.testCaseStartedId = String(object.testCaseStartedId);
                    return message;
                };

                /**
                 * Creates a plain object from a TestStepStarted message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {io.cucumber.messages.TestStepStarted} message TestStepStarted
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestStepStarted.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.timestamp = null;
                        object.testStepId = "";
                        object.testCaseStartedId = "";
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.io.cucumber.messages.Timestamp.toObject(message.timestamp, options);
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        object.testStepId = message.testStepId;
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        object.testCaseStartedId = message.testCaseStartedId;
                    return object;
                };

                /**
                 * Converts this TestStepStarted to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestStepStarted.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TestStepStarted;
            })();

            messages.TestStepFinished = (function() {

                /**
                 * Properties of a TestStepFinished.
                 * @memberof io.cucumber.messages
                 * @interface ITestStepFinished
                 * @property {io.cucumber.messages.ITestResult|null} [testResult] TestStepFinished testResult
                 * @property {io.cucumber.messages.ITimestamp|null} [timestamp] TestStepFinished timestamp
                 * @property {string|null} [testStepId] TestStepFinished testStepId
                 * @property {string|null} [testCaseStartedId] TestStepFinished testCaseStartedId
                 */

                /**
                 * Constructs a new TestStepFinished.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestStepFinished.
                 * @implements ITestStepFinished
                 * @constructor
                 * @param {io.cucumber.messages.ITestStepFinished=} [properties] Properties to set
                 */
                function TestStepFinished(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestStepFinished testResult.
                 * @member {io.cucumber.messages.ITestResult|null|undefined} testResult
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @instance
                 */
                TestStepFinished.prototype.testResult = null;

                /**
                 * TestStepFinished timestamp.
                 * @member {io.cucumber.messages.ITimestamp|null|undefined} timestamp
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @instance
                 */
                TestStepFinished.prototype.timestamp = null;

                /**
                 * TestStepFinished testStepId.
                 * @member {string} testStepId
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @instance
                 */
                TestStepFinished.prototype.testStepId = "";

                /**
                 * TestStepFinished testCaseStartedId.
                 * @member {string} testCaseStartedId
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @instance
                 */
                TestStepFinished.prototype.testCaseStartedId = "";

                /**
                 * Creates a new TestStepFinished instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {io.cucumber.messages.ITestStepFinished=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestStepFinished} TestStepFinished instance
                 */
                TestStepFinished.create = function create(properties) {
                    return new TestStepFinished(properties);
                };

                /**
                 * Encodes the specified TestStepFinished message. Does not implicitly {@link io.cucumber.messages.TestStepFinished.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {io.cucumber.messages.ITestStepFinished} message TestStepFinished message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestStepFinished.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.testResult != null && message.hasOwnProperty("testResult"))
                        $root.io.cucumber.messages.TestResult.encode(message.testResult, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        $root.io.cucumber.messages.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.testStepId);
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.testCaseStartedId);
                    return writer;
                };

                /**
                 * Encodes the specified TestStepFinished message, length delimited. Does not implicitly {@link io.cucumber.messages.TestStepFinished.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {io.cucumber.messages.ITestStepFinished} message TestStepFinished message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestStepFinished.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestStepFinished message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestStepFinished} TestStepFinished
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestStepFinished.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestStepFinished();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.testResult = $root.io.cucumber.messages.TestResult.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.timestamp = $root.io.cucumber.messages.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.testStepId = reader.string();
                            break;
                        case 4:
                            message.testCaseStartedId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestStepFinished message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestStepFinished} TestStepFinished
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestStepFinished.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestStepFinished message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestStepFinished.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.testResult != null && message.hasOwnProperty("testResult")) {
                        var error = $root.io.cucumber.messages.TestResult.verify(message.testResult);
                        if (error)
                            return "testResult." + error;
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.io.cucumber.messages.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        if (!$util.isString(message.testStepId))
                            return "testStepId: string expected";
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        if (!$util.isString(message.testCaseStartedId))
                            return "testCaseStartedId: string expected";
                    return null;
                };

                /**
                 * Creates a TestStepFinished message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestStepFinished} TestStepFinished
                 */
                TestStepFinished.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestStepFinished)
                        return object;
                    var message = new $root.io.cucumber.messages.TestStepFinished();
                    if (object.testResult != null) {
                        if (typeof object.testResult !== "object")
                            throw TypeError(".io.cucumber.messages.TestStepFinished.testResult: object expected");
                        message.testResult = $root.io.cucumber.messages.TestResult.fromObject(object.testResult);
                    }
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".io.cucumber.messages.TestStepFinished.timestamp: object expected");
                        message.timestamp = $root.io.cucumber.messages.Timestamp.fromObject(object.timestamp);
                    }
                    if (object.testStepId != null)
                        message.testStepId = String(object.testStepId);
                    if (object.testCaseStartedId != null)
                        message.testCaseStartedId = String(object.testCaseStartedId);
                    return message;
                };

                /**
                 * Creates a plain object from a TestStepFinished message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {io.cucumber.messages.TestStepFinished} message TestStepFinished
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestStepFinished.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.testResult = null;
                        object.timestamp = null;
                        object.testStepId = "";
                        object.testCaseStartedId = "";
                    }
                    if (message.testResult != null && message.hasOwnProperty("testResult"))
                        object.testResult = $root.io.cucumber.messages.TestResult.toObject(message.testResult, options);
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.io.cucumber.messages.Timestamp.toObject(message.timestamp, options);
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        object.testStepId = message.testStepId;
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        object.testCaseStartedId = message.testCaseStartedId;
                    return object;
                };

                /**
                 * Converts this TestStepFinished to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestStepFinished.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TestStepFinished;
            })();

            messages.TestResult = (function() {

                /**
                 * Properties of a TestResult.
                 * @memberof io.cucumber.messages
                 * @interface ITestResult
                 * @property {io.cucumber.messages.TestResult.Status|null} [status] TestResult status
                 * @property {string|null} [message] TestResult message
                 * @property {io.cucumber.messages.IDuration|null} [duration] TestResult duration
                 * @property {boolean|null} [willBeRetried] TestResult willBeRetried
                 */

                /**
                 * Constructs a new TestResult.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestResult.
                 * @implements ITestResult
                 * @constructor
                 * @param {io.cucumber.messages.ITestResult=} [properties] Properties to set
                 */
                function TestResult(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestResult status.
                 * @member {io.cucumber.messages.TestResult.Status} status
                 * @memberof io.cucumber.messages.TestResult
                 * @instance
                 */
                TestResult.prototype.status = 0;

                /**
                 * TestResult message.
                 * @member {string} message
                 * @memberof io.cucumber.messages.TestResult
                 * @instance
                 */
                TestResult.prototype.message = "";

                /**
                 * TestResult duration.
                 * @member {io.cucumber.messages.IDuration|null|undefined} duration
                 * @memberof io.cucumber.messages.TestResult
                 * @instance
                 */
                TestResult.prototype.duration = null;

                /**
                 * TestResult willBeRetried.
                 * @member {boolean} willBeRetried
                 * @memberof io.cucumber.messages.TestResult
                 * @instance
                 */
                TestResult.prototype.willBeRetried = false;

                /**
                 * Creates a new TestResult instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestResult
                 * @static
                 * @param {io.cucumber.messages.ITestResult=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestResult} TestResult instance
                 */
                TestResult.create = function create(properties) {
                    return new TestResult(properties);
                };

                /**
                 * Encodes the specified TestResult message. Does not implicitly {@link io.cucumber.messages.TestResult.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestResult
                 * @static
                 * @param {io.cucumber.messages.ITestResult} message TestResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && message.hasOwnProperty("status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.message != null && message.hasOwnProperty("message"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        $root.io.cucumber.messages.Duration.encode(message.duration, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.willBeRetried != null && message.hasOwnProperty("willBeRetried"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.willBeRetried);
                    return writer;
                };

                /**
                 * Encodes the specified TestResult message, length delimited. Does not implicitly {@link io.cucumber.messages.TestResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestResult
                 * @static
                 * @param {io.cucumber.messages.ITestResult} message TestResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestResult} TestResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.message = reader.string();
                            break;
                        case 3:
                            message.duration = $root.io.cucumber.messages.Duration.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.willBeRetried = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestResult} TestResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestResult message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    if (message.duration != null && message.hasOwnProperty("duration")) {
                        var error = $root.io.cucumber.messages.Duration.verify(message.duration);
                        if (error)
                            return "duration." + error;
                    }
                    if (message.willBeRetried != null && message.hasOwnProperty("willBeRetried"))
                        if (typeof message.willBeRetried !== "boolean")
                            return "willBeRetried: boolean expected";
                    return null;
                };

                /**
                 * Creates a TestResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestResult} TestResult
                 */
                TestResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestResult)
                        return object;
                    var message = new $root.io.cucumber.messages.TestResult();
                    switch (object.status) {
                    case "UNKNOWN":
                    case 0:
                        message.status = 0;
                        break;
                    case "PASSED":
                    case 1:
                        message.status = 1;
                        break;
                    case "SKIPPED":
                    case 2:
                        message.status = 2;
                        break;
                    case "PENDING":
                    case 3:
                        message.status = 3;
                        break;
                    case "UNDEFINED":
                    case 4:
                        message.status = 4;
                        break;
                    case "AMBIGUOUS":
                    case 5:
                        message.status = 5;
                        break;
                    case "FAILED":
                    case 6:
                        message.status = 6;
                        break;
                    }
                    if (object.message != null)
                        message.message = String(object.message);
                    if (object.duration != null) {
                        if (typeof object.duration !== "object")
                            throw TypeError(".io.cucumber.messages.TestResult.duration: object expected");
                        message.duration = $root.io.cucumber.messages.Duration.fromObject(object.duration);
                    }
                    if (object.willBeRetried != null)
                        message.willBeRetried = Boolean(object.willBeRetried);
                    return message;
                };

                /**
                 * Creates a plain object from a TestResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestResult
                 * @static
                 * @param {io.cucumber.messages.TestResult} message TestResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.status = options.enums === String ? "UNKNOWN" : 0;
                        object.message = "";
                        object.duration = null;
                        object.willBeRetried = false;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.io.cucumber.messages.TestResult.Status[message.status] : message.status;
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        object.duration = $root.io.cucumber.messages.Duration.toObject(message.duration, options);
                    if (message.willBeRetried != null && message.hasOwnProperty("willBeRetried"))
                        object.willBeRetried = message.willBeRetried;
                    return object;
                };

                /**
                 * Converts this TestResult to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Status of a step. Can also represent status of a Pickle (aggregated
                 * from the status of its steps).
                 * 
                 * The ordinal values of statuses are significant. The status of a Pickle
                 * is determined by the union of statuses of its steps. The
                 * status of the Pickle is the status with the highest ordinal
                 * in the enum.
                 * 
                 * For example, if a pickle has steps with statuses passed, undefined and skipped,
                 * then the pickle's status is undefined.
                 * @name io.cucumber.messages.TestResult.Status
                 * @enum {string}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} PASSED=1 PASSED value
                 * @property {number} SKIPPED=2 SKIPPED value
                 * @property {number} PENDING=3 PENDING value
                 * @property {number} UNDEFINED=4 UNDEFINED value
                 * @property {number} AMBIGUOUS=5 AMBIGUOUS value
                 * @property {number} FAILED=6 FAILED value
                 */
                TestResult.Status = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "PASSED"] = 1;
                    values[valuesById[2] = "SKIPPED"] = 2;
                    values[valuesById[3] = "PENDING"] = 3;
                    values[valuesById[4] = "UNDEFINED"] = 4;
                    values[valuesById[5] = "AMBIGUOUS"] = 5;
                    values[valuesById[6] = "FAILED"] = 6;
                    return values;
                })();

                return TestResult;
            })();

            messages.TestRunFinished = (function() {

                /**
                 * Properties of a TestRunFinished.
                 * @memberof io.cucumber.messages
                 * @interface ITestRunFinished
                 * @property {boolean|null} [success] TestRunFinished success
                 * @property {io.cucumber.messages.ITimestamp|null} [timestamp] TestRunFinished timestamp
                 */

                /**
                 * Constructs a new TestRunFinished.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestRunFinished.
                 * @implements ITestRunFinished
                 * @constructor
                 * @param {io.cucumber.messages.ITestRunFinished=} [properties] Properties to set
                 */
                function TestRunFinished(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestRunFinished success.
                 * @member {boolean} success
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @instance
                 */
                TestRunFinished.prototype.success = false;

                /**
                 * TestRunFinished timestamp.
                 * @member {io.cucumber.messages.ITimestamp|null|undefined} timestamp
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @instance
                 */
                TestRunFinished.prototype.timestamp = null;

                /**
                 * Creates a new TestRunFinished instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {io.cucumber.messages.ITestRunFinished=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestRunFinished} TestRunFinished instance
                 */
                TestRunFinished.create = function create(properties) {
                    return new TestRunFinished(properties);
                };

                /**
                 * Encodes the specified TestRunFinished message. Does not implicitly {@link io.cucumber.messages.TestRunFinished.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {io.cucumber.messages.ITestRunFinished} message TestRunFinished message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestRunFinished.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.success != null && message.hasOwnProperty("success"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.success);
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        $root.io.cucumber.messages.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TestRunFinished message, length delimited. Does not implicitly {@link io.cucumber.messages.TestRunFinished.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {io.cucumber.messages.ITestRunFinished} message TestRunFinished message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestRunFinished.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestRunFinished message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestRunFinished} TestRunFinished
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestRunFinished.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestRunFinished();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.success = reader.bool();
                            break;
                        case 2:
                            message.timestamp = $root.io.cucumber.messages.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestRunFinished message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestRunFinished} TestRunFinished
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestRunFinished.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestRunFinished message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestRunFinished.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.success != null && message.hasOwnProperty("success"))
                        if (typeof message.success !== "boolean")
                            return "success: boolean expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.io.cucumber.messages.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    return null;
                };

                /**
                 * Creates a TestRunFinished message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestRunFinished} TestRunFinished
                 */
                TestRunFinished.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestRunFinished)
                        return object;
                    var message = new $root.io.cucumber.messages.TestRunFinished();
                    if (object.success != null)
                        message.success = Boolean(object.success);
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".io.cucumber.messages.TestRunFinished.timestamp: object expected");
                        message.timestamp = $root.io.cucumber.messages.Timestamp.fromObject(object.timestamp);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TestRunFinished message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {io.cucumber.messages.TestRunFinished} message TestRunFinished
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestRunFinished.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.success = false;
                        object.timestamp = null;
                    }
                    if (message.success != null && message.hasOwnProperty("success"))
                        object.success = message.success;
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.io.cucumber.messages.Timestamp.toObject(message.timestamp, options);
                    return object;
                };

                /**
                 * Converts this TestRunFinished to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestRunFinished.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TestRunFinished;
            })();

            messages.CommandStart = (function() {

                /**
                 * Properties of a CommandStart.
                 * @memberof io.cucumber.messages
                 * @interface ICommandStart
                 * @property {string|null} [baseDirectory] CommandStart baseDirectory
                 * @property {io.cucumber.messages.ISourcesConfig|null} [sourcesConfig] CommandStart sourcesConfig
                 * @property {io.cucumber.messages.IRuntimeConfig|null} [runtimeConfig] CommandStart runtimeConfig
                 * @property {io.cucumber.messages.ISupportCodeConfig|null} [supportCodeConfig] CommandStart supportCodeConfig
                 */

                /**
                 * Constructs a new CommandStart.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a CommandStart.
                 * @implements ICommandStart
                 * @constructor
                 * @param {io.cucumber.messages.ICommandStart=} [properties] Properties to set
                 */
                function CommandStart(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CommandStart baseDirectory.
                 * @member {string} baseDirectory
                 * @memberof io.cucumber.messages.CommandStart
                 * @instance
                 */
                CommandStart.prototype.baseDirectory = "";

                /**
                 * CommandStart sourcesConfig.
                 * @member {io.cucumber.messages.ISourcesConfig|null|undefined} sourcesConfig
                 * @memberof io.cucumber.messages.CommandStart
                 * @instance
                 */
                CommandStart.prototype.sourcesConfig = null;

                /**
                 * CommandStart runtimeConfig.
                 * @member {io.cucumber.messages.IRuntimeConfig|null|undefined} runtimeConfig
                 * @memberof io.cucumber.messages.CommandStart
                 * @instance
                 */
                CommandStart.prototype.runtimeConfig = null;

                /**
                 * CommandStart supportCodeConfig.
                 * @member {io.cucumber.messages.ISupportCodeConfig|null|undefined} supportCodeConfig
                 * @memberof io.cucumber.messages.CommandStart
                 * @instance
                 */
                CommandStart.prototype.supportCodeConfig = null;

                /**
                 * Creates a new CommandStart instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.CommandStart
                 * @static
                 * @param {io.cucumber.messages.ICommandStart=} [properties] Properties to set
                 * @returns {io.cucumber.messages.CommandStart} CommandStart instance
                 */
                CommandStart.create = function create(properties) {
                    return new CommandStart(properties);
                };

                /**
                 * Encodes the specified CommandStart message. Does not implicitly {@link io.cucumber.messages.CommandStart.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.CommandStart
                 * @static
                 * @param {io.cucumber.messages.ICommandStart} message CommandStart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandStart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.baseDirectory != null && message.hasOwnProperty("baseDirectory"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.baseDirectory);
                    if (message.sourcesConfig != null && message.hasOwnProperty("sourcesConfig"))
                        $root.io.cucumber.messages.SourcesConfig.encode(message.sourcesConfig, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.runtimeConfig != null && message.hasOwnProperty("runtimeConfig"))
                        $root.io.cucumber.messages.RuntimeConfig.encode(message.runtimeConfig, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.supportCodeConfig != null && message.hasOwnProperty("supportCodeConfig"))
                        $root.io.cucumber.messages.SupportCodeConfig.encode(message.supportCodeConfig, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CommandStart message, length delimited. Does not implicitly {@link io.cucumber.messages.CommandStart.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.CommandStart
                 * @static
                 * @param {io.cucumber.messages.ICommandStart} message CommandStart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandStart.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CommandStart message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.CommandStart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.CommandStart} CommandStart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandStart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.CommandStart();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            message.baseDirectory = reader.string();
                            break;
                        case 3:
                            message.sourcesConfig = $root.io.cucumber.messages.SourcesConfig.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.runtimeConfig = $root.io.cucumber.messages.RuntimeConfig.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.supportCodeConfig = $root.io.cucumber.messages.SupportCodeConfig.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CommandStart message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.CommandStart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.CommandStart} CommandStart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandStart.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CommandStart message.
                 * @function verify
                 * @memberof io.cucumber.messages.CommandStart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CommandStart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.baseDirectory != null && message.hasOwnProperty("baseDirectory"))
                        if (!$util.isString(message.baseDirectory))
                            return "baseDirectory: string expected";
                    if (message.sourcesConfig != null && message.hasOwnProperty("sourcesConfig")) {
                        var error = $root.io.cucumber.messages.SourcesConfig.verify(message.sourcesConfig);
                        if (error)
                            return "sourcesConfig." + error;
                    }
                    if (message.runtimeConfig != null && message.hasOwnProperty("runtimeConfig")) {
                        var error = $root.io.cucumber.messages.RuntimeConfig.verify(message.runtimeConfig);
                        if (error)
                            return "runtimeConfig." + error;
                    }
                    if (message.supportCodeConfig != null && message.hasOwnProperty("supportCodeConfig")) {
                        var error = $root.io.cucumber.messages.SupportCodeConfig.verify(message.supportCodeConfig);
                        if (error)
                            return "supportCodeConfig." + error;
                    }
                    return null;
                };

                /**
                 * Creates a CommandStart message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.CommandStart
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.CommandStart} CommandStart
                 */
                CommandStart.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.CommandStart)
                        return object;
                    var message = new $root.io.cucumber.messages.CommandStart();
                    if (object.baseDirectory != null)
                        message.baseDirectory = String(object.baseDirectory);
                    if (object.sourcesConfig != null) {
                        if (typeof object.sourcesConfig !== "object")
                            throw TypeError(".io.cucumber.messages.CommandStart.sourcesConfig: object expected");
                        message.sourcesConfig = $root.io.cucumber.messages.SourcesConfig.fromObject(object.sourcesConfig);
                    }
                    if (object.runtimeConfig != null) {
                        if (typeof object.runtimeConfig !== "object")
                            throw TypeError(".io.cucumber.messages.CommandStart.runtimeConfig: object expected");
                        message.runtimeConfig = $root.io.cucumber.messages.RuntimeConfig.fromObject(object.runtimeConfig);
                    }
                    if (object.supportCodeConfig != null) {
                        if (typeof object.supportCodeConfig !== "object")
                            throw TypeError(".io.cucumber.messages.CommandStart.supportCodeConfig: object expected");
                        message.supportCodeConfig = $root.io.cucumber.messages.SupportCodeConfig.fromObject(object.supportCodeConfig);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CommandStart message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.CommandStart
                 * @static
                 * @param {io.cucumber.messages.CommandStart} message CommandStart
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CommandStart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.baseDirectory = "";
                        object.sourcesConfig = null;
                        object.runtimeConfig = null;
                        object.supportCodeConfig = null;
                    }
                    if (message.baseDirectory != null && message.hasOwnProperty("baseDirectory"))
                        object.baseDirectory = message.baseDirectory;
                    if (message.sourcesConfig != null && message.hasOwnProperty("sourcesConfig"))
                        object.sourcesConfig = $root.io.cucumber.messages.SourcesConfig.toObject(message.sourcesConfig, options);
                    if (message.runtimeConfig != null && message.hasOwnProperty("runtimeConfig"))
                        object.runtimeConfig = $root.io.cucumber.messages.RuntimeConfig.toObject(message.runtimeConfig, options);
                    if (message.supportCodeConfig != null && message.hasOwnProperty("supportCodeConfig"))
                        object.supportCodeConfig = $root.io.cucumber.messages.SupportCodeConfig.toObject(message.supportCodeConfig, options);
                    return object;
                };

                /**
                 * Converts this CommandStart to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.CommandStart
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CommandStart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CommandStart;
            })();

            messages.SourcesConfig = (function() {

                /**
                 * Properties of a SourcesConfig.
                 * @memberof io.cucumber.messages
                 * @interface ISourcesConfig
                 * @property {Array.<string>|null} [absolutePaths] SourcesConfig absolutePaths
                 * @property {string|null} [language] SourcesConfig language
                 * @property {io.cucumber.messages.ISourcesFilterConfig|null} [filters] SourcesConfig filters
                 * @property {io.cucumber.messages.ISourcesOrder|null} [order] SourcesConfig order
                 */

                /**
                 * Constructs a new SourcesConfig.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a SourcesConfig.
                 * @implements ISourcesConfig
                 * @constructor
                 * @param {io.cucumber.messages.ISourcesConfig=} [properties] Properties to set
                 */
                function SourcesConfig(properties) {
                    this.absolutePaths = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SourcesConfig absolutePaths.
                 * @member {Array.<string>} absolutePaths
                 * @memberof io.cucumber.messages.SourcesConfig
                 * @instance
                 */
                SourcesConfig.prototype.absolutePaths = $util.emptyArray;

                /**
                 * SourcesConfig language.
                 * @member {string} language
                 * @memberof io.cucumber.messages.SourcesConfig
                 * @instance
                 */
                SourcesConfig.prototype.language = "";

                /**
                 * SourcesConfig filters.
                 * @member {io.cucumber.messages.ISourcesFilterConfig|null|undefined} filters
                 * @memberof io.cucumber.messages.SourcesConfig
                 * @instance
                 */
                SourcesConfig.prototype.filters = null;

                /**
                 * SourcesConfig order.
                 * @member {io.cucumber.messages.ISourcesOrder|null|undefined} order
                 * @memberof io.cucumber.messages.SourcesConfig
                 * @instance
                 */
                SourcesConfig.prototype.order = null;

                /**
                 * Creates a new SourcesConfig instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.SourcesConfig
                 * @static
                 * @param {io.cucumber.messages.ISourcesConfig=} [properties] Properties to set
                 * @returns {io.cucumber.messages.SourcesConfig} SourcesConfig instance
                 */
                SourcesConfig.create = function create(properties) {
                    return new SourcesConfig(properties);
                };

                /**
                 * Encodes the specified SourcesConfig message. Does not implicitly {@link io.cucumber.messages.SourcesConfig.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.SourcesConfig
                 * @static
                 * @param {io.cucumber.messages.ISourcesConfig} message SourcesConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourcesConfig.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.absolutePaths != null && message.absolutePaths.length)
                        for (var i = 0; i < message.absolutePaths.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.absolutePaths[i]);
                    if (message.language != null && message.hasOwnProperty("language"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.language);
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        $root.io.cucumber.messages.SourcesFilterConfig.encode(message.filters, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.order != null && message.hasOwnProperty("order"))
                        $root.io.cucumber.messages.SourcesOrder.encode(message.order, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SourcesConfig message, length delimited. Does not implicitly {@link io.cucumber.messages.SourcesConfig.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.SourcesConfig
                 * @static
                 * @param {io.cucumber.messages.ISourcesConfig} message SourcesConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourcesConfig.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SourcesConfig message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.SourcesConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.SourcesConfig} SourcesConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourcesConfig.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.SourcesConfig();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.absolutePaths && message.absolutePaths.length))
                                message.absolutePaths = [];
                            message.absolutePaths.push(reader.string());
                            break;
                        case 2:
                            message.language = reader.string();
                            break;
                        case 3:
                            message.filters = $root.io.cucumber.messages.SourcesFilterConfig.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.order = $root.io.cucumber.messages.SourcesOrder.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SourcesConfig message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.SourcesConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.SourcesConfig} SourcesConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourcesConfig.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SourcesConfig message.
                 * @function verify
                 * @memberof io.cucumber.messages.SourcesConfig
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourcesConfig.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.absolutePaths != null && message.hasOwnProperty("absolutePaths")) {
                        if (!Array.isArray(message.absolutePaths))
                            return "absolutePaths: array expected";
                        for (var i = 0; i < message.absolutePaths.length; ++i)
                            if (!$util.isString(message.absolutePaths[i]))
                                return "absolutePaths: string[] expected";
                    }
                    if (message.language != null && message.hasOwnProperty("language"))
                        if (!$util.isString(message.language))
                            return "language: string expected";
                    if (message.filters != null && message.hasOwnProperty("filters")) {
                        var error = $root.io.cucumber.messages.SourcesFilterConfig.verify(message.filters);
                        if (error)
                            return "filters." + error;
                    }
                    if (message.order != null && message.hasOwnProperty("order")) {
                        var error = $root.io.cucumber.messages.SourcesOrder.verify(message.order);
                        if (error)
                            return "order." + error;
                    }
                    return null;
                };

                /**
                 * Creates a SourcesConfig message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.SourcesConfig
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.SourcesConfig} SourcesConfig
                 */
                SourcesConfig.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.SourcesConfig)
                        return object;
                    var message = new $root.io.cucumber.messages.SourcesConfig();
                    if (object.absolutePaths) {
                        if (!Array.isArray(object.absolutePaths))
                            throw TypeError(".io.cucumber.messages.SourcesConfig.absolutePaths: array expected");
                        message.absolutePaths = [];
                        for (var i = 0; i < object.absolutePaths.length; ++i)
                            message.absolutePaths[i] = String(object.absolutePaths[i]);
                    }
                    if (object.language != null)
                        message.language = String(object.language);
                    if (object.filters != null) {
                        if (typeof object.filters !== "object")
                            throw TypeError(".io.cucumber.messages.SourcesConfig.filters: object expected");
                        message.filters = $root.io.cucumber.messages.SourcesFilterConfig.fromObject(object.filters);
                    }
                    if (object.order != null) {
                        if (typeof object.order !== "object")
                            throw TypeError(".io.cucumber.messages.SourcesConfig.order: object expected");
                        message.order = $root.io.cucumber.messages.SourcesOrder.fromObject(object.order);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SourcesConfig message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.SourcesConfig
                 * @static
                 * @param {io.cucumber.messages.SourcesConfig} message SourcesConfig
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourcesConfig.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.absolutePaths = [];
                    if (options.defaults) {
                        object.language = "";
                        object.filters = null;
                        object.order = null;
                    }
                    if (message.absolutePaths && message.absolutePaths.length) {
                        object.absolutePaths = [];
                        for (var j = 0; j < message.absolutePaths.length; ++j)
                            object.absolutePaths[j] = message.absolutePaths[j];
                    }
                    if (message.language != null && message.hasOwnProperty("language"))
                        object.language = message.language;
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        object.filters = $root.io.cucumber.messages.SourcesFilterConfig.toObject(message.filters, options);
                    if (message.order != null && message.hasOwnProperty("order"))
                        object.order = $root.io.cucumber.messages.SourcesOrder.toObject(message.order, options);
                    return object;
                };

                /**
                 * Converts this SourcesConfig to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.SourcesConfig
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourcesConfig.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SourcesConfig;
            })();

            messages.SourcesFilterConfig = (function() {

                /**
                 * Properties of a SourcesFilterConfig.
                 * @memberof io.cucumber.messages
                 * @interface ISourcesFilterConfig
                 * @property {string|null} [tagExpression] SourcesFilterConfig tagExpression
                 * @property {Array.<string>|null} [nameRegularExpressions] SourcesFilterConfig nameRegularExpressions
                 * @property {Array.<io.cucumber.messages.IUriToLinesMapping>|null} [uriToLinesMapping] SourcesFilterConfig uriToLinesMapping
                 */

                /**
                 * Constructs a new SourcesFilterConfig.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a SourcesFilterConfig.
                 * @implements ISourcesFilterConfig
                 * @constructor
                 * @param {io.cucumber.messages.ISourcesFilterConfig=} [properties] Properties to set
                 */
                function SourcesFilterConfig(properties) {
                    this.nameRegularExpressions = [];
                    this.uriToLinesMapping = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SourcesFilterConfig tagExpression.
                 * @member {string} tagExpression
                 * @memberof io.cucumber.messages.SourcesFilterConfig
                 * @instance
                 */
                SourcesFilterConfig.prototype.tagExpression = "";

                /**
                 * SourcesFilterConfig nameRegularExpressions.
                 * @member {Array.<string>} nameRegularExpressions
                 * @memberof io.cucumber.messages.SourcesFilterConfig
                 * @instance
                 */
                SourcesFilterConfig.prototype.nameRegularExpressions = $util.emptyArray;

                /**
                 * SourcesFilterConfig uriToLinesMapping.
                 * @member {Array.<io.cucumber.messages.IUriToLinesMapping>} uriToLinesMapping
                 * @memberof io.cucumber.messages.SourcesFilterConfig
                 * @instance
                 */
                SourcesFilterConfig.prototype.uriToLinesMapping = $util.emptyArray;

                /**
                 * Creates a new SourcesFilterConfig instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.SourcesFilterConfig
                 * @static
                 * @param {io.cucumber.messages.ISourcesFilterConfig=} [properties] Properties to set
                 * @returns {io.cucumber.messages.SourcesFilterConfig} SourcesFilterConfig instance
                 */
                SourcesFilterConfig.create = function create(properties) {
                    return new SourcesFilterConfig(properties);
                };

                /**
                 * Encodes the specified SourcesFilterConfig message. Does not implicitly {@link io.cucumber.messages.SourcesFilterConfig.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.SourcesFilterConfig
                 * @static
                 * @param {io.cucumber.messages.ISourcesFilterConfig} message SourcesFilterConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourcesFilterConfig.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.tagExpression != null && message.hasOwnProperty("tagExpression"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.tagExpression);
                    if (message.nameRegularExpressions != null && message.nameRegularExpressions.length)
                        for (var i = 0; i < message.nameRegularExpressions.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.nameRegularExpressions[i]);
                    if (message.uriToLinesMapping != null && message.uriToLinesMapping.length)
                        for (var i = 0; i < message.uriToLinesMapping.length; ++i)
                            $root.io.cucumber.messages.UriToLinesMapping.encode(message.uriToLinesMapping[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SourcesFilterConfig message, length delimited. Does not implicitly {@link io.cucumber.messages.SourcesFilterConfig.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.SourcesFilterConfig
                 * @static
                 * @param {io.cucumber.messages.ISourcesFilterConfig} message SourcesFilterConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourcesFilterConfig.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SourcesFilterConfig message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.SourcesFilterConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.SourcesFilterConfig} SourcesFilterConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourcesFilterConfig.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.SourcesFilterConfig();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.tagExpression = reader.string();
                            break;
                        case 2:
                            if (!(message.nameRegularExpressions && message.nameRegularExpressions.length))
                                message.nameRegularExpressions = [];
                            message.nameRegularExpressions.push(reader.string());
                            break;
                        case 3:
                            if (!(message.uriToLinesMapping && message.uriToLinesMapping.length))
                                message.uriToLinesMapping = [];
                            message.uriToLinesMapping.push($root.io.cucumber.messages.UriToLinesMapping.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SourcesFilterConfig message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.SourcesFilterConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.SourcesFilterConfig} SourcesFilterConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourcesFilterConfig.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SourcesFilterConfig message.
                 * @function verify
                 * @memberof io.cucumber.messages.SourcesFilterConfig
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourcesFilterConfig.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.tagExpression != null && message.hasOwnProperty("tagExpression"))
                        if (!$util.isString(message.tagExpression))
                            return "tagExpression: string expected";
                    if (message.nameRegularExpressions != null && message.hasOwnProperty("nameRegularExpressions")) {
                        if (!Array.isArray(message.nameRegularExpressions))
                            return "nameRegularExpressions: array expected";
                        for (var i = 0; i < message.nameRegularExpressions.length; ++i)
                            if (!$util.isString(message.nameRegularExpressions[i]))
                                return "nameRegularExpressions: string[] expected";
                    }
                    if (message.uriToLinesMapping != null && message.hasOwnProperty("uriToLinesMapping")) {
                        if (!Array.isArray(message.uriToLinesMapping))
                            return "uriToLinesMapping: array expected";
                        for (var i = 0; i < message.uriToLinesMapping.length; ++i) {
                            var error = $root.io.cucumber.messages.UriToLinesMapping.verify(message.uriToLinesMapping[i]);
                            if (error)
                                return "uriToLinesMapping." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SourcesFilterConfig message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.SourcesFilterConfig
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.SourcesFilterConfig} SourcesFilterConfig
                 */
                SourcesFilterConfig.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.SourcesFilterConfig)
                        return object;
                    var message = new $root.io.cucumber.messages.SourcesFilterConfig();
                    if (object.tagExpression != null)
                        message.tagExpression = String(object.tagExpression);
                    if (object.nameRegularExpressions) {
                        if (!Array.isArray(object.nameRegularExpressions))
                            throw TypeError(".io.cucumber.messages.SourcesFilterConfig.nameRegularExpressions: array expected");
                        message.nameRegularExpressions = [];
                        for (var i = 0; i < object.nameRegularExpressions.length; ++i)
                            message.nameRegularExpressions[i] = String(object.nameRegularExpressions[i]);
                    }
                    if (object.uriToLinesMapping) {
                        if (!Array.isArray(object.uriToLinesMapping))
                            throw TypeError(".io.cucumber.messages.SourcesFilterConfig.uriToLinesMapping: array expected");
                        message.uriToLinesMapping = [];
                        for (var i = 0; i < object.uriToLinesMapping.length; ++i) {
                            if (typeof object.uriToLinesMapping[i] !== "object")
                                throw TypeError(".io.cucumber.messages.SourcesFilterConfig.uriToLinesMapping: object expected");
                            message.uriToLinesMapping[i] = $root.io.cucumber.messages.UriToLinesMapping.fromObject(object.uriToLinesMapping[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SourcesFilterConfig message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.SourcesFilterConfig
                 * @static
                 * @param {io.cucumber.messages.SourcesFilterConfig} message SourcesFilterConfig
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourcesFilterConfig.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.nameRegularExpressions = [];
                        object.uriToLinesMapping = [];
                    }
                    if (options.defaults)
                        object.tagExpression = "";
                    if (message.tagExpression != null && message.hasOwnProperty("tagExpression"))
                        object.tagExpression = message.tagExpression;
                    if (message.nameRegularExpressions && message.nameRegularExpressions.length) {
                        object.nameRegularExpressions = [];
                        for (var j = 0; j < message.nameRegularExpressions.length; ++j)
                            object.nameRegularExpressions[j] = message.nameRegularExpressions[j];
                    }
                    if (message.uriToLinesMapping && message.uriToLinesMapping.length) {
                        object.uriToLinesMapping = [];
                        for (var j = 0; j < message.uriToLinesMapping.length; ++j)
                            object.uriToLinesMapping[j] = $root.io.cucumber.messages.UriToLinesMapping.toObject(message.uriToLinesMapping[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SourcesFilterConfig to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.SourcesFilterConfig
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourcesFilterConfig.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SourcesFilterConfig;
            })();

            messages.UriToLinesMapping = (function() {

                /**
                 * Properties of an UriToLinesMapping.
                 * @memberof io.cucumber.messages
                 * @interface IUriToLinesMapping
                 * @property {string|null} [absolutePath] UriToLinesMapping absolutePath
                 * @property {Array.<number|Long>|null} [lines] UriToLinesMapping lines
                 */

                /**
                 * Constructs a new UriToLinesMapping.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents an UriToLinesMapping.
                 * @implements IUriToLinesMapping
                 * @constructor
                 * @param {io.cucumber.messages.IUriToLinesMapping=} [properties] Properties to set
                 */
                function UriToLinesMapping(properties) {
                    this.lines = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UriToLinesMapping absolutePath.
                 * @member {string} absolutePath
                 * @memberof io.cucumber.messages.UriToLinesMapping
                 * @instance
                 */
                UriToLinesMapping.prototype.absolutePath = "";

                /**
                 * UriToLinesMapping lines.
                 * @member {Array.<number|Long>} lines
                 * @memberof io.cucumber.messages.UriToLinesMapping
                 * @instance
                 */
                UriToLinesMapping.prototype.lines = $util.emptyArray;

                /**
                 * Creates a new UriToLinesMapping instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.UriToLinesMapping
                 * @static
                 * @param {io.cucumber.messages.IUriToLinesMapping=} [properties] Properties to set
                 * @returns {io.cucumber.messages.UriToLinesMapping} UriToLinesMapping instance
                 */
                UriToLinesMapping.create = function create(properties) {
                    return new UriToLinesMapping(properties);
                };

                /**
                 * Encodes the specified UriToLinesMapping message. Does not implicitly {@link io.cucumber.messages.UriToLinesMapping.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.UriToLinesMapping
                 * @static
                 * @param {io.cucumber.messages.IUriToLinesMapping} message UriToLinesMapping message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UriToLinesMapping.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.absolutePath != null && message.hasOwnProperty("absolutePath"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.absolutePath);
                    if (message.lines != null && message.lines.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.lines.length; ++i)
                            writer.uint64(message.lines[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Encodes the specified UriToLinesMapping message, length delimited. Does not implicitly {@link io.cucumber.messages.UriToLinesMapping.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.UriToLinesMapping
                 * @static
                 * @param {io.cucumber.messages.IUriToLinesMapping} message UriToLinesMapping message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UriToLinesMapping.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UriToLinesMapping message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.UriToLinesMapping
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.UriToLinesMapping} UriToLinesMapping
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UriToLinesMapping.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.UriToLinesMapping();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.absolutePath = reader.string();
                            break;
                        case 2:
                            if (!(message.lines && message.lines.length))
                                message.lines = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.lines.push(reader.uint64());
                            } else
                                message.lines.push(reader.uint64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UriToLinesMapping message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.UriToLinesMapping
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.UriToLinesMapping} UriToLinesMapping
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UriToLinesMapping.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UriToLinesMapping message.
                 * @function verify
                 * @memberof io.cucumber.messages.UriToLinesMapping
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UriToLinesMapping.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.absolutePath != null && message.hasOwnProperty("absolutePath"))
                        if (!$util.isString(message.absolutePath))
                            return "absolutePath: string expected";
                    if (message.lines != null && message.hasOwnProperty("lines")) {
                        if (!Array.isArray(message.lines))
                            return "lines: array expected";
                        for (var i = 0; i < message.lines.length; ++i)
                            if (!$util.isInteger(message.lines[i]) && !(message.lines[i] && $util.isInteger(message.lines[i].low) && $util.isInteger(message.lines[i].high)))
                                return "lines: integer|Long[] expected";
                    }
                    return null;
                };

                /**
                 * Creates an UriToLinesMapping message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.UriToLinesMapping
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.UriToLinesMapping} UriToLinesMapping
                 */
                UriToLinesMapping.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.UriToLinesMapping)
                        return object;
                    var message = new $root.io.cucumber.messages.UriToLinesMapping();
                    if (object.absolutePath != null)
                        message.absolutePath = String(object.absolutePath);
                    if (object.lines) {
                        if (!Array.isArray(object.lines))
                            throw TypeError(".io.cucumber.messages.UriToLinesMapping.lines: array expected");
                        message.lines = [];
                        for (var i = 0; i < object.lines.length; ++i)
                            if ($util.Long)
                                (message.lines[i] = $util.Long.fromValue(object.lines[i])).unsigned = true;
                            else if (typeof object.lines[i] === "string")
                                message.lines[i] = parseInt(object.lines[i], 10);
                            else if (typeof object.lines[i] === "number")
                                message.lines[i] = object.lines[i];
                            else if (typeof object.lines[i] === "object")
                                message.lines[i] = new $util.LongBits(object.lines[i].low >>> 0, object.lines[i].high >>> 0).toNumber(true);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an UriToLinesMapping message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.UriToLinesMapping
                 * @static
                 * @param {io.cucumber.messages.UriToLinesMapping} message UriToLinesMapping
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UriToLinesMapping.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.lines = [];
                    if (options.defaults)
                        object.absolutePath = "";
                    if (message.absolutePath != null && message.hasOwnProperty("absolutePath"))
                        object.absolutePath = message.absolutePath;
                    if (message.lines && message.lines.length) {
                        object.lines = [];
                        for (var j = 0; j < message.lines.length; ++j)
                            if (typeof message.lines[j] === "number")
                                object.lines[j] = options.longs === String ? String(message.lines[j]) : message.lines[j];
                            else
                                object.lines[j] = options.longs === String ? $util.Long.prototype.toString.call(message.lines[j]) : options.longs === Number ? new $util.LongBits(message.lines[j].low >>> 0, message.lines[j].high >>> 0).toNumber(true) : message.lines[j];
                    }
                    return object;
                };

                /**
                 * Converts this UriToLinesMapping to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.UriToLinesMapping
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UriToLinesMapping.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UriToLinesMapping;
            })();

            messages.SourcesOrder = (function() {

                /**
                 * Properties of a SourcesOrder.
                 * @memberof io.cucumber.messages
                 * @interface ISourcesOrder
                 * @property {io.cucumber.messages.SourcesOrderType|null} [type] SourcesOrder type
                 * @property {number|Long|null} [seed] SourcesOrder seed
                 */

                /**
                 * Constructs a new SourcesOrder.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a SourcesOrder.
                 * @implements ISourcesOrder
                 * @constructor
                 * @param {io.cucumber.messages.ISourcesOrder=} [properties] Properties to set
                 */
                function SourcesOrder(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SourcesOrder type.
                 * @member {io.cucumber.messages.SourcesOrderType} type
                 * @memberof io.cucumber.messages.SourcesOrder
                 * @instance
                 */
                SourcesOrder.prototype.type = 0;

                /**
                 * SourcesOrder seed.
                 * @member {number|Long} seed
                 * @memberof io.cucumber.messages.SourcesOrder
                 * @instance
                 */
                SourcesOrder.prototype.seed = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new SourcesOrder instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.SourcesOrder
                 * @static
                 * @param {io.cucumber.messages.ISourcesOrder=} [properties] Properties to set
                 * @returns {io.cucumber.messages.SourcesOrder} SourcesOrder instance
                 */
                SourcesOrder.create = function create(properties) {
                    return new SourcesOrder(properties);
                };

                /**
                 * Encodes the specified SourcesOrder message. Does not implicitly {@link io.cucumber.messages.SourcesOrder.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.SourcesOrder
                 * @static
                 * @param {io.cucumber.messages.ISourcesOrder} message SourcesOrder message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourcesOrder.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.seed != null && message.hasOwnProperty("seed"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.seed);
                    return writer;
                };

                /**
                 * Encodes the specified SourcesOrder message, length delimited. Does not implicitly {@link io.cucumber.messages.SourcesOrder.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.SourcesOrder
                 * @static
                 * @param {io.cucumber.messages.ISourcesOrder} message SourcesOrder message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourcesOrder.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SourcesOrder message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.SourcesOrder
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.SourcesOrder} SourcesOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourcesOrder.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.SourcesOrder();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.seed = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SourcesOrder message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.SourcesOrder
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.SourcesOrder} SourcesOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourcesOrder.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SourcesOrder message.
                 * @function verify
                 * @memberof io.cucumber.messages.SourcesOrder
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourcesOrder.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.seed != null && message.hasOwnProperty("seed"))
                        if (!$util.isInteger(message.seed) && !(message.seed && $util.isInteger(message.seed.low) && $util.isInteger(message.seed.high)))
                            return "seed: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a SourcesOrder message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.SourcesOrder
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.SourcesOrder} SourcesOrder
                 */
                SourcesOrder.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.SourcesOrder)
                        return object;
                    var message = new $root.io.cucumber.messages.SourcesOrder();
                    switch (object.type) {
                    case "ORDER_OF_DEFINITION":
                    case 0:
                        message.type = 0;
                        break;
                    case "RANDOM":
                    case 1:
                        message.type = 1;
                        break;
                    }
                    if (object.seed != null)
                        if ($util.Long)
                            (message.seed = $util.Long.fromValue(object.seed)).unsigned = true;
                        else if (typeof object.seed === "string")
                            message.seed = parseInt(object.seed, 10);
                        else if (typeof object.seed === "number")
                            message.seed = object.seed;
                        else if (typeof object.seed === "object")
                            message.seed = new $util.LongBits(object.seed.low >>> 0, object.seed.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a SourcesOrder message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.SourcesOrder
                 * @static
                 * @param {io.cucumber.messages.SourcesOrder} message SourcesOrder
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourcesOrder.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "ORDER_OF_DEFINITION" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.seed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seed = options.longs === String ? "0" : 0;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.io.cucumber.messages.SourcesOrderType[message.type] : message.type;
                    if (message.seed != null && message.hasOwnProperty("seed"))
                        if (typeof message.seed === "number")
                            object.seed = options.longs === String ? String(message.seed) : message.seed;
                        else
                            object.seed = options.longs === String ? $util.Long.prototype.toString.call(message.seed) : options.longs === Number ? new $util.LongBits(message.seed.low >>> 0, message.seed.high >>> 0).toNumber(true) : message.seed;
                    return object;
                };

                /**
                 * Converts this SourcesOrder to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.SourcesOrder
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourcesOrder.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SourcesOrder;
            })();

            /**
             * SourcesOrderType enum.
             * @name io.cucumber.messages.SourcesOrderType
             * @enum {string}
             * @property {number} ORDER_OF_DEFINITION=0 ORDER_OF_DEFINITION value
             * @property {number} RANDOM=1 RANDOM value
             */
            messages.SourcesOrderType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ORDER_OF_DEFINITION"] = 0;
                values[valuesById[1] = "RANDOM"] = 1;
                return values;
            })();

            messages.RuntimeConfig = (function() {

                /**
                 * Properties of a RuntimeConfig.
                 * @memberof io.cucumber.messages
                 * @interface IRuntimeConfig
                 * @property {boolean|null} [isFailFast] RuntimeConfig isFailFast
                 * @property {boolean|null} [isDryRun] RuntimeConfig isDryRun
                 * @property {boolean|null} [isStrict] RuntimeConfig isStrict
                 * @property {number|Long|null} [maxParallel] RuntimeConfig maxParallel
                 */

                /**
                 * Constructs a new RuntimeConfig.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a RuntimeConfig.
                 * @implements IRuntimeConfig
                 * @constructor
                 * @param {io.cucumber.messages.IRuntimeConfig=} [properties] Properties to set
                 */
                function RuntimeConfig(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RuntimeConfig isFailFast.
                 * @member {boolean} isFailFast
                 * @memberof io.cucumber.messages.RuntimeConfig
                 * @instance
                 */
                RuntimeConfig.prototype.isFailFast = false;

                /**
                 * RuntimeConfig isDryRun.
                 * @member {boolean} isDryRun
                 * @memberof io.cucumber.messages.RuntimeConfig
                 * @instance
                 */
                RuntimeConfig.prototype.isDryRun = false;

                /**
                 * RuntimeConfig isStrict.
                 * @member {boolean} isStrict
                 * @memberof io.cucumber.messages.RuntimeConfig
                 * @instance
                 */
                RuntimeConfig.prototype.isStrict = false;

                /**
                 * RuntimeConfig maxParallel.
                 * @member {number|Long} maxParallel
                 * @memberof io.cucumber.messages.RuntimeConfig
                 * @instance
                 */
                RuntimeConfig.prototype.maxParallel = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new RuntimeConfig instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.RuntimeConfig
                 * @static
                 * @param {io.cucumber.messages.IRuntimeConfig=} [properties] Properties to set
                 * @returns {io.cucumber.messages.RuntimeConfig} RuntimeConfig instance
                 */
                RuntimeConfig.create = function create(properties) {
                    return new RuntimeConfig(properties);
                };

                /**
                 * Encodes the specified RuntimeConfig message. Does not implicitly {@link io.cucumber.messages.RuntimeConfig.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.RuntimeConfig
                 * @static
                 * @param {io.cucumber.messages.IRuntimeConfig} message RuntimeConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RuntimeConfig.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.isFailFast != null && message.hasOwnProperty("isFailFast"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isFailFast);
                    if (message.isDryRun != null && message.hasOwnProperty("isDryRun"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isDryRun);
                    if (message.isStrict != null && message.hasOwnProperty("isStrict"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isStrict);
                    if (message.maxParallel != null && message.hasOwnProperty("maxParallel"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.maxParallel);
                    return writer;
                };

                /**
                 * Encodes the specified RuntimeConfig message, length delimited. Does not implicitly {@link io.cucumber.messages.RuntimeConfig.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.RuntimeConfig
                 * @static
                 * @param {io.cucumber.messages.IRuntimeConfig} message RuntimeConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RuntimeConfig.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RuntimeConfig message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.RuntimeConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.RuntimeConfig} RuntimeConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RuntimeConfig.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.RuntimeConfig();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.isFailFast = reader.bool();
                            break;
                        case 2:
                            message.isDryRun = reader.bool();
                            break;
                        case 3:
                            message.isStrict = reader.bool();
                            break;
                        case 4:
                            message.maxParallel = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RuntimeConfig message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.RuntimeConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.RuntimeConfig} RuntimeConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RuntimeConfig.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RuntimeConfig message.
                 * @function verify
                 * @memberof io.cucumber.messages.RuntimeConfig
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RuntimeConfig.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.isFailFast != null && message.hasOwnProperty("isFailFast"))
                        if (typeof message.isFailFast !== "boolean")
                            return "isFailFast: boolean expected";
                    if (message.isDryRun != null && message.hasOwnProperty("isDryRun"))
                        if (typeof message.isDryRun !== "boolean")
                            return "isDryRun: boolean expected";
                    if (message.isStrict != null && message.hasOwnProperty("isStrict"))
                        if (typeof message.isStrict !== "boolean")
                            return "isStrict: boolean expected";
                    if (message.maxParallel != null && message.hasOwnProperty("maxParallel"))
                        if (!$util.isInteger(message.maxParallel) && !(message.maxParallel && $util.isInteger(message.maxParallel.low) && $util.isInteger(message.maxParallel.high)))
                            return "maxParallel: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a RuntimeConfig message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.RuntimeConfig
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.RuntimeConfig} RuntimeConfig
                 */
                RuntimeConfig.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.RuntimeConfig)
                        return object;
                    var message = new $root.io.cucumber.messages.RuntimeConfig();
                    if (object.isFailFast != null)
                        message.isFailFast = Boolean(object.isFailFast);
                    if (object.isDryRun != null)
                        message.isDryRun = Boolean(object.isDryRun);
                    if (object.isStrict != null)
                        message.isStrict = Boolean(object.isStrict);
                    if (object.maxParallel != null)
                        if ($util.Long)
                            (message.maxParallel = $util.Long.fromValue(object.maxParallel)).unsigned = true;
                        else if (typeof object.maxParallel === "string")
                            message.maxParallel = parseInt(object.maxParallel, 10);
                        else if (typeof object.maxParallel === "number")
                            message.maxParallel = object.maxParallel;
                        else if (typeof object.maxParallel === "object")
                            message.maxParallel = new $util.LongBits(object.maxParallel.low >>> 0, object.maxParallel.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a RuntimeConfig message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.RuntimeConfig
                 * @static
                 * @param {io.cucumber.messages.RuntimeConfig} message RuntimeConfig
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RuntimeConfig.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.isFailFast = false;
                        object.isDryRun = false;
                        object.isStrict = false;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.maxParallel = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.maxParallel = options.longs === String ? "0" : 0;
                    }
                    if (message.isFailFast != null && message.hasOwnProperty("isFailFast"))
                        object.isFailFast = message.isFailFast;
                    if (message.isDryRun != null && message.hasOwnProperty("isDryRun"))
                        object.isDryRun = message.isDryRun;
                    if (message.isStrict != null && message.hasOwnProperty("isStrict"))
                        object.isStrict = message.isStrict;
                    if (message.maxParallel != null && message.hasOwnProperty("maxParallel"))
                        if (typeof message.maxParallel === "number")
                            object.maxParallel = options.longs === String ? String(message.maxParallel) : message.maxParallel;
                        else
                            object.maxParallel = options.longs === String ? $util.Long.prototype.toString.call(message.maxParallel) : options.longs === Number ? new $util.LongBits(message.maxParallel.low >>> 0, message.maxParallel.high >>> 0).toNumber(true) : message.maxParallel;
                    return object;
                };

                /**
                 * Converts this RuntimeConfig to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.RuntimeConfig
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RuntimeConfig.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RuntimeConfig;
            })();

            messages.SupportCodeConfig = (function() {

                /**
                 * Properties of a SupportCodeConfig.
                 * @memberof io.cucumber.messages
                 * @interface ISupportCodeConfig
                 * @property {Array.<io.cucumber.messages.IHook>|null} [beforeTestCaseHooks] SupportCodeConfig beforeTestCaseHooks
                 * @property {Array.<io.cucumber.messages.IHook>|null} [afterTestCaseHooks] SupportCodeConfig afterTestCaseHooks
                 * @property {Array.<io.cucumber.messages.IStepDefinition>|null} [stepDefinitions] SupportCodeConfig stepDefinitions
                 * @property {Array.<io.cucumber.messages.IParameterType>|null} [parameterTypes] SupportCodeConfig parameterTypes
                 */

                /**
                 * Constructs a new SupportCodeConfig.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a SupportCodeConfig.
                 * @implements ISupportCodeConfig
                 * @constructor
                 * @param {io.cucumber.messages.ISupportCodeConfig=} [properties] Properties to set
                 */
                function SupportCodeConfig(properties) {
                    this.beforeTestCaseHooks = [];
                    this.afterTestCaseHooks = [];
                    this.stepDefinitions = [];
                    this.parameterTypes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SupportCodeConfig beforeTestCaseHooks.
                 * @member {Array.<io.cucumber.messages.IHook>} beforeTestCaseHooks
                 * @memberof io.cucumber.messages.SupportCodeConfig
                 * @instance
                 */
                SupportCodeConfig.prototype.beforeTestCaseHooks = $util.emptyArray;

                /**
                 * SupportCodeConfig afterTestCaseHooks.
                 * @member {Array.<io.cucumber.messages.IHook>} afterTestCaseHooks
                 * @memberof io.cucumber.messages.SupportCodeConfig
                 * @instance
                 */
                SupportCodeConfig.prototype.afterTestCaseHooks = $util.emptyArray;

                /**
                 * SupportCodeConfig stepDefinitions.
                 * @member {Array.<io.cucumber.messages.IStepDefinition>} stepDefinitions
                 * @memberof io.cucumber.messages.SupportCodeConfig
                 * @instance
                 */
                SupportCodeConfig.prototype.stepDefinitions = $util.emptyArray;

                /**
                 * SupportCodeConfig parameterTypes.
                 * @member {Array.<io.cucumber.messages.IParameterType>} parameterTypes
                 * @memberof io.cucumber.messages.SupportCodeConfig
                 * @instance
                 */
                SupportCodeConfig.prototype.parameterTypes = $util.emptyArray;

                /**
                 * Creates a new SupportCodeConfig instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.SupportCodeConfig
                 * @static
                 * @param {io.cucumber.messages.ISupportCodeConfig=} [properties] Properties to set
                 * @returns {io.cucumber.messages.SupportCodeConfig} SupportCodeConfig instance
                 */
                SupportCodeConfig.create = function create(properties) {
                    return new SupportCodeConfig(properties);
                };

                /**
                 * Encodes the specified SupportCodeConfig message. Does not implicitly {@link io.cucumber.messages.SupportCodeConfig.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.SupportCodeConfig
                 * @static
                 * @param {io.cucumber.messages.ISupportCodeConfig} message SupportCodeConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SupportCodeConfig.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.beforeTestCaseHooks != null && message.beforeTestCaseHooks.length)
                        for (var i = 0; i < message.beforeTestCaseHooks.length; ++i)
                            $root.io.cucumber.messages.Hook.encode(message.beforeTestCaseHooks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.afterTestCaseHooks != null && message.afterTestCaseHooks.length)
                        for (var i = 0; i < message.afterTestCaseHooks.length; ++i)
                            $root.io.cucumber.messages.Hook.encode(message.afterTestCaseHooks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.stepDefinitions != null && message.stepDefinitions.length)
                        for (var i = 0; i < message.stepDefinitions.length; ++i)
                            $root.io.cucumber.messages.StepDefinition.encode(message.stepDefinitions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.parameterTypes != null && message.parameterTypes.length)
                        for (var i = 0; i < message.parameterTypes.length; ++i)
                            $root.io.cucumber.messages.ParameterType.encode(message.parameterTypes[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SupportCodeConfig message, length delimited. Does not implicitly {@link io.cucumber.messages.SupportCodeConfig.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.SupportCodeConfig
                 * @static
                 * @param {io.cucumber.messages.ISupportCodeConfig} message SupportCodeConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SupportCodeConfig.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SupportCodeConfig message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.SupportCodeConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.SupportCodeConfig} SupportCodeConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SupportCodeConfig.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.SupportCodeConfig();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.beforeTestCaseHooks && message.beforeTestCaseHooks.length))
                                message.beforeTestCaseHooks = [];
                            message.beforeTestCaseHooks.push($root.io.cucumber.messages.Hook.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.afterTestCaseHooks && message.afterTestCaseHooks.length))
                                message.afterTestCaseHooks = [];
                            message.afterTestCaseHooks.push($root.io.cucumber.messages.Hook.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.stepDefinitions && message.stepDefinitions.length))
                                message.stepDefinitions = [];
                            message.stepDefinitions.push($root.io.cucumber.messages.StepDefinition.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.parameterTypes && message.parameterTypes.length))
                                message.parameterTypes = [];
                            message.parameterTypes.push($root.io.cucumber.messages.ParameterType.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SupportCodeConfig message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.SupportCodeConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.SupportCodeConfig} SupportCodeConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SupportCodeConfig.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SupportCodeConfig message.
                 * @function verify
                 * @memberof io.cucumber.messages.SupportCodeConfig
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SupportCodeConfig.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.beforeTestCaseHooks != null && message.hasOwnProperty("beforeTestCaseHooks")) {
                        if (!Array.isArray(message.beforeTestCaseHooks))
                            return "beforeTestCaseHooks: array expected";
                        for (var i = 0; i < message.beforeTestCaseHooks.length; ++i) {
                            var error = $root.io.cucumber.messages.Hook.verify(message.beforeTestCaseHooks[i]);
                            if (error)
                                return "beforeTestCaseHooks." + error;
                        }
                    }
                    if (message.afterTestCaseHooks != null && message.hasOwnProperty("afterTestCaseHooks")) {
                        if (!Array.isArray(message.afterTestCaseHooks))
                            return "afterTestCaseHooks: array expected";
                        for (var i = 0; i < message.afterTestCaseHooks.length; ++i) {
                            var error = $root.io.cucumber.messages.Hook.verify(message.afterTestCaseHooks[i]);
                            if (error)
                                return "afterTestCaseHooks." + error;
                        }
                    }
                    if (message.stepDefinitions != null && message.hasOwnProperty("stepDefinitions")) {
                        if (!Array.isArray(message.stepDefinitions))
                            return "stepDefinitions: array expected";
                        for (var i = 0; i < message.stepDefinitions.length; ++i) {
                            var error = $root.io.cucumber.messages.StepDefinition.verify(message.stepDefinitions[i]);
                            if (error)
                                return "stepDefinitions." + error;
                        }
                    }
                    if (message.parameterTypes != null && message.hasOwnProperty("parameterTypes")) {
                        if (!Array.isArray(message.parameterTypes))
                            return "parameterTypes: array expected";
                        for (var i = 0; i < message.parameterTypes.length; ++i) {
                            var error = $root.io.cucumber.messages.ParameterType.verify(message.parameterTypes[i]);
                            if (error)
                                return "parameterTypes." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SupportCodeConfig message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.SupportCodeConfig
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.SupportCodeConfig} SupportCodeConfig
                 */
                SupportCodeConfig.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.SupportCodeConfig)
                        return object;
                    var message = new $root.io.cucumber.messages.SupportCodeConfig();
                    if (object.beforeTestCaseHooks) {
                        if (!Array.isArray(object.beforeTestCaseHooks))
                            throw TypeError(".io.cucumber.messages.SupportCodeConfig.beforeTestCaseHooks: array expected");
                        message.beforeTestCaseHooks = [];
                        for (var i = 0; i < object.beforeTestCaseHooks.length; ++i) {
                            if (typeof object.beforeTestCaseHooks[i] !== "object")
                                throw TypeError(".io.cucumber.messages.SupportCodeConfig.beforeTestCaseHooks: object expected");
                            message.beforeTestCaseHooks[i] = $root.io.cucumber.messages.Hook.fromObject(object.beforeTestCaseHooks[i]);
                        }
                    }
                    if (object.afterTestCaseHooks) {
                        if (!Array.isArray(object.afterTestCaseHooks))
                            throw TypeError(".io.cucumber.messages.SupportCodeConfig.afterTestCaseHooks: array expected");
                        message.afterTestCaseHooks = [];
                        for (var i = 0; i < object.afterTestCaseHooks.length; ++i) {
                            if (typeof object.afterTestCaseHooks[i] !== "object")
                                throw TypeError(".io.cucumber.messages.SupportCodeConfig.afterTestCaseHooks: object expected");
                            message.afterTestCaseHooks[i] = $root.io.cucumber.messages.Hook.fromObject(object.afterTestCaseHooks[i]);
                        }
                    }
                    if (object.stepDefinitions) {
                        if (!Array.isArray(object.stepDefinitions))
                            throw TypeError(".io.cucumber.messages.SupportCodeConfig.stepDefinitions: array expected");
                        message.stepDefinitions = [];
                        for (var i = 0; i < object.stepDefinitions.length; ++i) {
                            if (typeof object.stepDefinitions[i] !== "object")
                                throw TypeError(".io.cucumber.messages.SupportCodeConfig.stepDefinitions: object expected");
                            message.stepDefinitions[i] = $root.io.cucumber.messages.StepDefinition.fromObject(object.stepDefinitions[i]);
                        }
                    }
                    if (object.parameterTypes) {
                        if (!Array.isArray(object.parameterTypes))
                            throw TypeError(".io.cucumber.messages.SupportCodeConfig.parameterTypes: array expected");
                        message.parameterTypes = [];
                        for (var i = 0; i < object.parameterTypes.length; ++i) {
                            if (typeof object.parameterTypes[i] !== "object")
                                throw TypeError(".io.cucumber.messages.SupportCodeConfig.parameterTypes: object expected");
                            message.parameterTypes[i] = $root.io.cucumber.messages.ParameterType.fromObject(object.parameterTypes[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SupportCodeConfig message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.SupportCodeConfig
                 * @static
                 * @param {io.cucumber.messages.SupportCodeConfig} message SupportCodeConfig
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SupportCodeConfig.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.beforeTestCaseHooks = [];
                        object.afterTestCaseHooks = [];
                        object.stepDefinitions = [];
                        object.parameterTypes = [];
                    }
                    if (message.beforeTestCaseHooks && message.beforeTestCaseHooks.length) {
                        object.beforeTestCaseHooks = [];
                        for (var j = 0; j < message.beforeTestCaseHooks.length; ++j)
                            object.beforeTestCaseHooks[j] = $root.io.cucumber.messages.Hook.toObject(message.beforeTestCaseHooks[j], options);
                    }
                    if (message.afterTestCaseHooks && message.afterTestCaseHooks.length) {
                        object.afterTestCaseHooks = [];
                        for (var j = 0; j < message.afterTestCaseHooks.length; ++j)
                            object.afterTestCaseHooks[j] = $root.io.cucumber.messages.Hook.toObject(message.afterTestCaseHooks[j], options);
                    }
                    if (message.stepDefinitions && message.stepDefinitions.length) {
                        object.stepDefinitions = [];
                        for (var j = 0; j < message.stepDefinitions.length; ++j)
                            object.stepDefinitions[j] = $root.io.cucumber.messages.StepDefinition.toObject(message.stepDefinitions[j], options);
                    }
                    if (message.parameterTypes && message.parameterTypes.length) {
                        object.parameterTypes = [];
                        for (var j = 0; j < message.parameterTypes.length; ++j)
                            object.parameterTypes[j] = $root.io.cucumber.messages.ParameterType.toObject(message.parameterTypes[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SupportCodeConfig to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.SupportCodeConfig
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SupportCodeConfig.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SupportCodeConfig;
            })();

            messages.Hook = (function() {

                /**
                 * Properties of a Hook.
                 * @memberof io.cucumber.messages
                 * @interface IHook
                 * @property {string|null} [id] Hook id
                 * @property {string|null} [tagExpression] Hook tagExpression
                 * @property {io.cucumber.messages.ISourceReference|null} [sourceReference] Hook sourceReference
                 */

                /**
                 * Constructs a new Hook.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a Hook.
                 * @implements IHook
                 * @constructor
                 * @param {io.cucumber.messages.IHook=} [properties] Properties to set
                 */
                function Hook(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Hook id.
                 * @member {string} id
                 * @memberof io.cucumber.messages.Hook
                 * @instance
                 */
                Hook.prototype.id = "";

                /**
                 * Hook tagExpression.
                 * @member {string} tagExpression
                 * @memberof io.cucumber.messages.Hook
                 * @instance
                 */
                Hook.prototype.tagExpression = "";

                /**
                 * Hook sourceReference.
                 * @member {io.cucumber.messages.ISourceReference|null|undefined} sourceReference
                 * @memberof io.cucumber.messages.Hook
                 * @instance
                 */
                Hook.prototype.sourceReference = null;

                /**
                 * Creates a new Hook instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {io.cucumber.messages.IHook=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Hook} Hook instance
                 */
                Hook.create = function create(properties) {
                    return new Hook(properties);
                };

                /**
                 * Encodes the specified Hook message. Does not implicitly {@link io.cucumber.messages.Hook.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {io.cucumber.messages.IHook} message Hook message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Hook.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.tagExpression != null && message.hasOwnProperty("tagExpression"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.tagExpression);
                    if (message.sourceReference != null && message.hasOwnProperty("sourceReference"))
                        $root.io.cucumber.messages.SourceReference.encode(message.sourceReference, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Hook message, length delimited. Does not implicitly {@link io.cucumber.messages.Hook.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {io.cucumber.messages.IHook} message Hook message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Hook.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Hook message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Hook} Hook
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Hook.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Hook();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.tagExpression = reader.string();
                            break;
                        case 3:
                            message.sourceReference = $root.io.cucumber.messages.SourceReference.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Hook message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Hook} Hook
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Hook.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Hook message.
                 * @function verify
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Hook.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.tagExpression != null && message.hasOwnProperty("tagExpression"))
                        if (!$util.isString(message.tagExpression))
                            return "tagExpression: string expected";
                    if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                        var error = $root.io.cucumber.messages.SourceReference.verify(message.sourceReference);
                        if (error)
                            return "sourceReference." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Hook message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Hook} Hook
                 */
                Hook.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Hook)
                        return object;
                    var message = new $root.io.cucumber.messages.Hook();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.tagExpression != null)
                        message.tagExpression = String(object.tagExpression);
                    if (object.sourceReference != null) {
                        if (typeof object.sourceReference !== "object")
                            throw TypeError(".io.cucumber.messages.Hook.sourceReference: object expected");
                        message.sourceReference = $root.io.cucumber.messages.SourceReference.fromObject(object.sourceReference);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Hook message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {io.cucumber.messages.Hook} message Hook
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Hook.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.tagExpression = "";
                        object.sourceReference = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.tagExpression != null && message.hasOwnProperty("tagExpression"))
                        object.tagExpression = message.tagExpression;
                    if (message.sourceReference != null && message.hasOwnProperty("sourceReference"))
                        object.sourceReference = $root.io.cucumber.messages.SourceReference.toObject(message.sourceReference, options);
                    return object;
                };

                /**
                 * Converts this Hook to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Hook
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Hook.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Hook;
            })();

            messages.StepDefinition = (function() {

                /**
                 * Properties of a StepDefinition.
                 * @memberof io.cucumber.messages
                 * @interface IStepDefinition
                 * @property {string|null} [id] StepDefinition id
                 * @property {io.cucumber.messages.IStepDefinitionPattern|null} [pattern] StepDefinition pattern
                 * @property {io.cucumber.messages.ISourceReference|null} [sourceReference] StepDefinition sourceReference
                 */

                /**
                 * Constructs a new StepDefinition.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a StepDefinition.
                 * @implements IStepDefinition
                 * @constructor
                 * @param {io.cucumber.messages.IStepDefinition=} [properties] Properties to set
                 */
                function StepDefinition(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StepDefinition id.
                 * @member {string} id
                 * @memberof io.cucumber.messages.StepDefinition
                 * @instance
                 */
                StepDefinition.prototype.id = "";

                /**
                 * StepDefinition pattern.
                 * @member {io.cucumber.messages.IStepDefinitionPattern|null|undefined} pattern
                 * @memberof io.cucumber.messages.StepDefinition
                 * @instance
                 */
                StepDefinition.prototype.pattern = null;

                /**
                 * StepDefinition sourceReference.
                 * @member {io.cucumber.messages.ISourceReference|null|undefined} sourceReference
                 * @memberof io.cucumber.messages.StepDefinition
                 * @instance
                 */
                StepDefinition.prototype.sourceReference = null;

                /**
                 * Creates a new StepDefinition instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {io.cucumber.messages.IStepDefinition=} [properties] Properties to set
                 * @returns {io.cucumber.messages.StepDefinition} StepDefinition instance
                 */
                StepDefinition.create = function create(properties) {
                    return new StepDefinition(properties);
                };

                /**
                 * Encodes the specified StepDefinition message. Does not implicitly {@link io.cucumber.messages.StepDefinition.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {io.cucumber.messages.IStepDefinition} message StepDefinition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StepDefinition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.pattern != null && message.hasOwnProperty("pattern"))
                        $root.io.cucumber.messages.StepDefinitionPattern.encode(message.pattern, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.sourceReference != null && message.hasOwnProperty("sourceReference"))
                        $root.io.cucumber.messages.SourceReference.encode(message.sourceReference, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified StepDefinition message, length delimited. Does not implicitly {@link io.cucumber.messages.StepDefinition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {io.cucumber.messages.IStepDefinition} message StepDefinition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StepDefinition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StepDefinition message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.StepDefinition} StepDefinition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StepDefinition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.StepDefinition();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.pattern = $root.io.cucumber.messages.StepDefinitionPattern.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.sourceReference = $root.io.cucumber.messages.SourceReference.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StepDefinition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.StepDefinition} StepDefinition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StepDefinition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StepDefinition message.
                 * @function verify
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StepDefinition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.pattern != null && message.hasOwnProperty("pattern")) {
                        var error = $root.io.cucumber.messages.StepDefinitionPattern.verify(message.pattern);
                        if (error)
                            return "pattern." + error;
                    }
                    if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                        var error = $root.io.cucumber.messages.SourceReference.verify(message.sourceReference);
                        if (error)
                            return "sourceReference." + error;
                    }
                    return null;
                };

                /**
                 * Creates a StepDefinition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.StepDefinition} StepDefinition
                 */
                StepDefinition.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.StepDefinition)
                        return object;
                    var message = new $root.io.cucumber.messages.StepDefinition();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.pattern != null) {
                        if (typeof object.pattern !== "object")
                            throw TypeError(".io.cucumber.messages.StepDefinition.pattern: object expected");
                        message.pattern = $root.io.cucumber.messages.StepDefinitionPattern.fromObject(object.pattern);
                    }
                    if (object.sourceReference != null) {
                        if (typeof object.sourceReference !== "object")
                            throw TypeError(".io.cucumber.messages.StepDefinition.sourceReference: object expected");
                        message.sourceReference = $root.io.cucumber.messages.SourceReference.fromObject(object.sourceReference);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a StepDefinition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {io.cucumber.messages.StepDefinition} message StepDefinition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StepDefinition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.pattern = null;
                        object.sourceReference = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.pattern != null && message.hasOwnProperty("pattern"))
                        object.pattern = $root.io.cucumber.messages.StepDefinitionPattern.toObject(message.pattern, options);
                    if (message.sourceReference != null && message.hasOwnProperty("sourceReference"))
                        object.sourceReference = $root.io.cucumber.messages.SourceReference.toObject(message.sourceReference, options);
                    return object;
                };

                /**
                 * Converts this StepDefinition to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.StepDefinition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StepDefinition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return StepDefinition;
            })();

            messages.StepDefinitionPattern = (function() {

                /**
                 * Properties of a StepDefinitionPattern.
                 * @memberof io.cucumber.messages
                 * @interface IStepDefinitionPattern
                 * @property {string|null} [source] StepDefinitionPattern source
                 * @property {io.cucumber.messages.StepDefinitionPatternType|null} [type] StepDefinitionPattern type
                 */

                /**
                 * Constructs a new StepDefinitionPattern.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a StepDefinitionPattern.
                 * @implements IStepDefinitionPattern
                 * @constructor
                 * @param {io.cucumber.messages.IStepDefinitionPattern=} [properties] Properties to set
                 */
                function StepDefinitionPattern(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StepDefinitionPattern source.
                 * @member {string} source
                 * @memberof io.cucumber.messages.StepDefinitionPattern
                 * @instance
                 */
                StepDefinitionPattern.prototype.source = "";

                /**
                 * StepDefinitionPattern type.
                 * @member {io.cucumber.messages.StepDefinitionPatternType} type
                 * @memberof io.cucumber.messages.StepDefinitionPattern
                 * @instance
                 */
                StepDefinitionPattern.prototype.type = 0;

                /**
                 * Creates a new StepDefinitionPattern instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.StepDefinitionPattern
                 * @static
                 * @param {io.cucumber.messages.IStepDefinitionPattern=} [properties] Properties to set
                 * @returns {io.cucumber.messages.StepDefinitionPattern} StepDefinitionPattern instance
                 */
                StepDefinitionPattern.create = function create(properties) {
                    return new StepDefinitionPattern(properties);
                };

                /**
                 * Encodes the specified StepDefinitionPattern message. Does not implicitly {@link io.cucumber.messages.StepDefinitionPattern.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.StepDefinitionPattern
                 * @static
                 * @param {io.cucumber.messages.IStepDefinitionPattern} message StepDefinitionPattern message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StepDefinitionPattern.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.source != null && message.hasOwnProperty("source"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.source);
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    return writer;
                };

                /**
                 * Encodes the specified StepDefinitionPattern message, length delimited. Does not implicitly {@link io.cucumber.messages.StepDefinitionPattern.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.StepDefinitionPattern
                 * @static
                 * @param {io.cucumber.messages.IStepDefinitionPattern} message StepDefinitionPattern message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StepDefinitionPattern.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StepDefinitionPattern message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.StepDefinitionPattern
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.StepDefinitionPattern} StepDefinitionPattern
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StepDefinitionPattern.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.StepDefinitionPattern();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.source = reader.string();
                            break;
                        case 2:
                            message.type = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StepDefinitionPattern message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.StepDefinitionPattern
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.StepDefinitionPattern} StepDefinitionPattern
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StepDefinitionPattern.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StepDefinitionPattern message.
                 * @function verify
                 * @memberof io.cucumber.messages.StepDefinitionPattern
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StepDefinitionPattern.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.source != null && message.hasOwnProperty("source"))
                        if (!$util.isString(message.source))
                            return "source: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a StepDefinitionPattern message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.StepDefinitionPattern
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.StepDefinitionPattern} StepDefinitionPattern
                 */
                StepDefinitionPattern.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.StepDefinitionPattern)
                        return object;
                    var message = new $root.io.cucumber.messages.StepDefinitionPattern();
                    if (object.source != null)
                        message.source = String(object.source);
                    switch (object.type) {
                    case "CUCUMBER_EXPRESSION":
                    case 0:
                        message.type = 0;
                        break;
                    case "REGULAR_EXPRESSION":
                    case 1:
                        message.type = 1;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a StepDefinitionPattern message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.StepDefinitionPattern
                 * @static
                 * @param {io.cucumber.messages.StepDefinitionPattern} message StepDefinitionPattern
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StepDefinitionPattern.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.source = "";
                        object.type = options.enums === String ? "CUCUMBER_EXPRESSION" : 0;
                    }
                    if (message.source != null && message.hasOwnProperty("source"))
                        object.source = message.source;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.io.cucumber.messages.StepDefinitionPatternType[message.type] : message.type;
                    return object;
                };

                /**
                 * Converts this StepDefinitionPattern to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.StepDefinitionPattern
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StepDefinitionPattern.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return StepDefinitionPattern;
            })();

            /**
             * StepDefinitionPatternType enum.
             * @name io.cucumber.messages.StepDefinitionPatternType
             * @enum {string}
             * @property {number} CUCUMBER_EXPRESSION=0 CUCUMBER_EXPRESSION value
             * @property {number} REGULAR_EXPRESSION=1 REGULAR_EXPRESSION value
             */
            messages.StepDefinitionPatternType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CUCUMBER_EXPRESSION"] = 0;
                values[valuesById[1] = "REGULAR_EXPRESSION"] = 1;
                return values;
            })();

            messages.ParameterType = (function() {

                /**
                 * Properties of a ParameterType.
                 * @memberof io.cucumber.messages
                 * @interface IParameterType
                 * @property {string|null} [name] ParameterType name
                 * @property {Array.<string>|null} [regularExpressions] ParameterType regularExpressions
                 * @property {boolean|null} [preferForRegularExpressionMatch] ParameterType preferForRegularExpressionMatch
                 * @property {boolean|null} [useForSnippets] ParameterType useForSnippets
                 */

                /**
                 * Constructs a new ParameterType.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a ParameterType.
                 * @implements IParameterType
                 * @constructor
                 * @param {io.cucumber.messages.IParameterType=} [properties] Properties to set
                 */
                function ParameterType(properties) {
                    this.regularExpressions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ParameterType name.
                 * @member {string} name
                 * @memberof io.cucumber.messages.ParameterType
                 * @instance
                 */
                ParameterType.prototype.name = "";

                /**
                 * ParameterType regularExpressions.
                 * @member {Array.<string>} regularExpressions
                 * @memberof io.cucumber.messages.ParameterType
                 * @instance
                 */
                ParameterType.prototype.regularExpressions = $util.emptyArray;

                /**
                 * ParameterType preferForRegularExpressionMatch.
                 * @member {boolean} preferForRegularExpressionMatch
                 * @memberof io.cucumber.messages.ParameterType
                 * @instance
                 */
                ParameterType.prototype.preferForRegularExpressionMatch = false;

                /**
                 * ParameterType useForSnippets.
                 * @member {boolean} useForSnippets
                 * @memberof io.cucumber.messages.ParameterType
                 * @instance
                 */
                ParameterType.prototype.useForSnippets = false;

                /**
                 * Creates a new ParameterType instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {io.cucumber.messages.IParameterType=} [properties] Properties to set
                 * @returns {io.cucumber.messages.ParameterType} ParameterType instance
                 */
                ParameterType.create = function create(properties) {
                    return new ParameterType(properties);
                };

                /**
                 * Encodes the specified ParameterType message. Does not implicitly {@link io.cucumber.messages.ParameterType.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {io.cucumber.messages.IParameterType} message ParameterType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ParameterType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.regularExpressions != null && message.regularExpressions.length)
                        for (var i = 0; i < message.regularExpressions.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.regularExpressions[i]);
                    if (message.preferForRegularExpressionMatch != null && message.hasOwnProperty("preferForRegularExpressionMatch"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.preferForRegularExpressionMatch);
                    if (message.useForSnippets != null && message.hasOwnProperty("useForSnippets"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.useForSnippets);
                    return writer;
                };

                /**
                 * Encodes the specified ParameterType message, length delimited. Does not implicitly {@link io.cucumber.messages.ParameterType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {io.cucumber.messages.IParameterType} message ParameterType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ParameterType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ParameterType message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.ParameterType} ParameterType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ParameterType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.ParameterType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.regularExpressions && message.regularExpressions.length))
                                message.regularExpressions = [];
                            message.regularExpressions.push(reader.string());
                            break;
                        case 3:
                            message.preferForRegularExpressionMatch = reader.bool();
                            break;
                        case 4:
                            message.useForSnippets = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ParameterType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.ParameterType} ParameterType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ParameterType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ParameterType message.
                 * @function verify
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ParameterType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.regularExpressions != null && message.hasOwnProperty("regularExpressions")) {
                        if (!Array.isArray(message.regularExpressions))
                            return "regularExpressions: array expected";
                        for (var i = 0; i < message.regularExpressions.length; ++i)
                            if (!$util.isString(message.regularExpressions[i]))
                                return "regularExpressions: string[] expected";
                    }
                    if (message.preferForRegularExpressionMatch != null && message.hasOwnProperty("preferForRegularExpressionMatch"))
                        if (typeof message.preferForRegularExpressionMatch !== "boolean")
                            return "preferForRegularExpressionMatch: boolean expected";
                    if (message.useForSnippets != null && message.hasOwnProperty("useForSnippets"))
                        if (typeof message.useForSnippets !== "boolean")
                            return "useForSnippets: boolean expected";
                    return null;
                };

                /**
                 * Creates a ParameterType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.ParameterType} ParameterType
                 */
                ParameterType.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.ParameterType)
                        return object;
                    var message = new $root.io.cucumber.messages.ParameterType();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.regularExpressions) {
                        if (!Array.isArray(object.regularExpressions))
                            throw TypeError(".io.cucumber.messages.ParameterType.regularExpressions: array expected");
                        message.regularExpressions = [];
                        for (var i = 0; i < object.regularExpressions.length; ++i)
                            message.regularExpressions[i] = String(object.regularExpressions[i]);
                    }
                    if (object.preferForRegularExpressionMatch != null)
                        message.preferForRegularExpressionMatch = Boolean(object.preferForRegularExpressionMatch);
                    if (object.useForSnippets != null)
                        message.useForSnippets = Boolean(object.useForSnippets);
                    return message;
                };

                /**
                 * Creates a plain object from a ParameterType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {io.cucumber.messages.ParameterType} message ParameterType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ParameterType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.regularExpressions = [];
                    if (options.defaults) {
                        object.name = "";
                        object.preferForRegularExpressionMatch = false;
                        object.useForSnippets = false;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.regularExpressions && message.regularExpressions.length) {
                        object.regularExpressions = [];
                        for (var j = 0; j < message.regularExpressions.length; ++j)
                            object.regularExpressions[j] = message.regularExpressions[j];
                    }
                    if (message.preferForRegularExpressionMatch != null && message.hasOwnProperty("preferForRegularExpressionMatch"))
                        object.preferForRegularExpressionMatch = message.preferForRegularExpressionMatch;
                    if (message.useForSnippets != null && message.hasOwnProperty("useForSnippets"))
                        object.useForSnippets = message.useForSnippets;
                    return object;
                };

                /**
                 * Converts this ParameterType to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.ParameterType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ParameterType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ParameterType;
            })();

            messages.CommandActionComplete = (function() {

                /**
                 * Properties of a CommandActionComplete.
                 * @memberof io.cucumber.messages
                 * @interface ICommandActionComplete
                 * @property {string|null} [completedId] CommandActionComplete completedId
                 * @property {io.cucumber.messages.ITestResult|null} [testResult] CommandActionComplete testResult
                 * @property {string|null} [snippet] CommandActionComplete snippet
                 */

                /**
                 * Constructs a new CommandActionComplete.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a CommandActionComplete.
                 * @implements ICommandActionComplete
                 * @constructor
                 * @param {io.cucumber.messages.ICommandActionComplete=} [properties] Properties to set
                 */
                function CommandActionComplete(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CommandActionComplete completedId.
                 * @member {string} completedId
                 * @memberof io.cucumber.messages.CommandActionComplete
                 * @instance
                 */
                CommandActionComplete.prototype.completedId = "";

                /**
                 * CommandActionComplete testResult.
                 * @member {io.cucumber.messages.ITestResult|null|undefined} testResult
                 * @memberof io.cucumber.messages.CommandActionComplete
                 * @instance
                 */
                CommandActionComplete.prototype.testResult = null;

                /**
                 * CommandActionComplete snippet.
                 * @member {string} snippet
                 * @memberof io.cucumber.messages.CommandActionComplete
                 * @instance
                 */
                CommandActionComplete.prototype.snippet = "";

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * CommandActionComplete result.
                 * @member {"testResult"|"snippet"|undefined} result
                 * @memberof io.cucumber.messages.CommandActionComplete
                 * @instance
                 */
                Object.defineProperty(CommandActionComplete.prototype, "result", {
                    get: $util.oneOfGetter($oneOfFields = ["testResult", "snippet"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new CommandActionComplete instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.CommandActionComplete
                 * @static
                 * @param {io.cucumber.messages.ICommandActionComplete=} [properties] Properties to set
                 * @returns {io.cucumber.messages.CommandActionComplete} CommandActionComplete instance
                 */
                CommandActionComplete.create = function create(properties) {
                    return new CommandActionComplete(properties);
                };

                /**
                 * Encodes the specified CommandActionComplete message. Does not implicitly {@link io.cucumber.messages.CommandActionComplete.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.CommandActionComplete
                 * @static
                 * @param {io.cucumber.messages.ICommandActionComplete} message CommandActionComplete message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandActionComplete.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.completedId != null && message.hasOwnProperty("completedId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.completedId);
                    if (message.testResult != null && message.hasOwnProperty("testResult"))
                        $root.io.cucumber.messages.TestResult.encode(message.testResult, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.snippet != null && message.hasOwnProperty("snippet"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.snippet);
                    return writer;
                };

                /**
                 * Encodes the specified CommandActionComplete message, length delimited. Does not implicitly {@link io.cucumber.messages.CommandActionComplete.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.CommandActionComplete
                 * @static
                 * @param {io.cucumber.messages.ICommandActionComplete} message CommandActionComplete message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandActionComplete.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CommandActionComplete message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.CommandActionComplete
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.CommandActionComplete} CommandActionComplete
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandActionComplete.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.CommandActionComplete();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.completedId = reader.string();
                            break;
                        case 2:
                            message.testResult = $root.io.cucumber.messages.TestResult.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.snippet = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CommandActionComplete message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.CommandActionComplete
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.CommandActionComplete} CommandActionComplete
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandActionComplete.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CommandActionComplete message.
                 * @function verify
                 * @memberof io.cucumber.messages.CommandActionComplete
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CommandActionComplete.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.completedId != null && message.hasOwnProperty("completedId"))
                        if (!$util.isString(message.completedId))
                            return "completedId: string expected";
                    if (message.testResult != null && message.hasOwnProperty("testResult")) {
                        properties.result = 1;
                        {
                            var error = $root.io.cucumber.messages.TestResult.verify(message.testResult);
                            if (error)
                                return "testResult." + error;
                        }
                    }
                    if (message.snippet != null && message.hasOwnProperty("snippet")) {
                        if (properties.result === 1)
                            return "result: multiple values";
                        properties.result = 1;
                        if (!$util.isString(message.snippet))
                            return "snippet: string expected";
                    }
                    return null;
                };

                /**
                 * Creates a CommandActionComplete message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.CommandActionComplete
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.CommandActionComplete} CommandActionComplete
                 */
                CommandActionComplete.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.CommandActionComplete)
                        return object;
                    var message = new $root.io.cucumber.messages.CommandActionComplete();
                    if (object.completedId != null)
                        message.completedId = String(object.completedId);
                    if (object.testResult != null) {
                        if (typeof object.testResult !== "object")
                            throw TypeError(".io.cucumber.messages.CommandActionComplete.testResult: object expected");
                        message.testResult = $root.io.cucumber.messages.TestResult.fromObject(object.testResult);
                    }
                    if (object.snippet != null)
                        message.snippet = String(object.snippet);
                    return message;
                };

                /**
                 * Creates a plain object from a CommandActionComplete message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.CommandActionComplete
                 * @static
                 * @param {io.cucumber.messages.CommandActionComplete} message CommandActionComplete
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CommandActionComplete.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.completedId = "";
                    if (message.completedId != null && message.hasOwnProperty("completedId"))
                        object.completedId = message.completedId;
                    if (message.testResult != null && message.hasOwnProperty("testResult")) {
                        object.testResult = $root.io.cucumber.messages.TestResult.toObject(message.testResult, options);
                        if (options.oneofs)
                            object.result = "testResult";
                    }
                    if (message.snippet != null && message.hasOwnProperty("snippet")) {
                        object.snippet = message.snippet;
                        if (options.oneofs)
                            object.result = "snippet";
                    }
                    return object;
                };

                /**
                 * Converts this CommandActionComplete to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.CommandActionComplete
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CommandActionComplete.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CommandActionComplete;
            })();

            messages.CommandRunBeforeTestRunHooks = (function() {

                /**
                 * Properties of a CommandRunBeforeTestRunHooks.
                 * @memberof io.cucumber.messages
                 * @interface ICommandRunBeforeTestRunHooks
                 * @property {string|null} [actionId] CommandRunBeforeTestRunHooks actionId
                 */

                /**
                 * Constructs a new CommandRunBeforeTestRunHooks.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a CommandRunBeforeTestRunHooks.
                 * @implements ICommandRunBeforeTestRunHooks
                 * @constructor
                 * @param {io.cucumber.messages.ICommandRunBeforeTestRunHooks=} [properties] Properties to set
                 */
                function CommandRunBeforeTestRunHooks(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CommandRunBeforeTestRunHooks actionId.
                 * @member {string} actionId
                 * @memberof io.cucumber.messages.CommandRunBeforeTestRunHooks
                 * @instance
                 */
                CommandRunBeforeTestRunHooks.prototype.actionId = "";

                /**
                 * Creates a new CommandRunBeforeTestRunHooks instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.CommandRunBeforeTestRunHooks
                 * @static
                 * @param {io.cucumber.messages.ICommandRunBeforeTestRunHooks=} [properties] Properties to set
                 * @returns {io.cucumber.messages.CommandRunBeforeTestRunHooks} CommandRunBeforeTestRunHooks instance
                 */
                CommandRunBeforeTestRunHooks.create = function create(properties) {
                    return new CommandRunBeforeTestRunHooks(properties);
                };

                /**
                 * Encodes the specified CommandRunBeforeTestRunHooks message. Does not implicitly {@link io.cucumber.messages.CommandRunBeforeTestRunHooks.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.CommandRunBeforeTestRunHooks
                 * @static
                 * @param {io.cucumber.messages.ICommandRunBeforeTestRunHooks} message CommandRunBeforeTestRunHooks message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandRunBeforeTestRunHooks.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.actionId);
                    return writer;
                };

                /**
                 * Encodes the specified CommandRunBeforeTestRunHooks message, length delimited. Does not implicitly {@link io.cucumber.messages.CommandRunBeforeTestRunHooks.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.CommandRunBeforeTestRunHooks
                 * @static
                 * @param {io.cucumber.messages.ICommandRunBeforeTestRunHooks} message CommandRunBeforeTestRunHooks message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandRunBeforeTestRunHooks.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CommandRunBeforeTestRunHooks message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.CommandRunBeforeTestRunHooks
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.CommandRunBeforeTestRunHooks} CommandRunBeforeTestRunHooks
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandRunBeforeTestRunHooks.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.CommandRunBeforeTestRunHooks();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.actionId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CommandRunBeforeTestRunHooks message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.CommandRunBeforeTestRunHooks
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.CommandRunBeforeTestRunHooks} CommandRunBeforeTestRunHooks
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandRunBeforeTestRunHooks.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CommandRunBeforeTestRunHooks message.
                 * @function verify
                 * @memberof io.cucumber.messages.CommandRunBeforeTestRunHooks
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CommandRunBeforeTestRunHooks.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        if (!$util.isString(message.actionId))
                            return "actionId: string expected";
                    return null;
                };

                /**
                 * Creates a CommandRunBeforeTestRunHooks message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.CommandRunBeforeTestRunHooks
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.CommandRunBeforeTestRunHooks} CommandRunBeforeTestRunHooks
                 */
                CommandRunBeforeTestRunHooks.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.CommandRunBeforeTestRunHooks)
                        return object;
                    var message = new $root.io.cucumber.messages.CommandRunBeforeTestRunHooks();
                    if (object.actionId != null)
                        message.actionId = String(object.actionId);
                    return message;
                };

                /**
                 * Creates a plain object from a CommandRunBeforeTestRunHooks message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.CommandRunBeforeTestRunHooks
                 * @static
                 * @param {io.cucumber.messages.CommandRunBeforeTestRunHooks} message CommandRunBeforeTestRunHooks
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CommandRunBeforeTestRunHooks.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.actionId = "";
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        object.actionId = message.actionId;
                    return object;
                };

                /**
                 * Converts this CommandRunBeforeTestRunHooks to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.CommandRunBeforeTestRunHooks
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CommandRunBeforeTestRunHooks.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CommandRunBeforeTestRunHooks;
            })();

            messages.CommandRunAfterTestRunHooks = (function() {

                /**
                 * Properties of a CommandRunAfterTestRunHooks.
                 * @memberof io.cucumber.messages
                 * @interface ICommandRunAfterTestRunHooks
                 * @property {string|null} [actionId] CommandRunAfterTestRunHooks actionId
                 */

                /**
                 * Constructs a new CommandRunAfterTestRunHooks.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a CommandRunAfterTestRunHooks.
                 * @implements ICommandRunAfterTestRunHooks
                 * @constructor
                 * @param {io.cucumber.messages.ICommandRunAfterTestRunHooks=} [properties] Properties to set
                 */
                function CommandRunAfterTestRunHooks(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CommandRunAfterTestRunHooks actionId.
                 * @member {string} actionId
                 * @memberof io.cucumber.messages.CommandRunAfterTestRunHooks
                 * @instance
                 */
                CommandRunAfterTestRunHooks.prototype.actionId = "";

                /**
                 * Creates a new CommandRunAfterTestRunHooks instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.CommandRunAfterTestRunHooks
                 * @static
                 * @param {io.cucumber.messages.ICommandRunAfterTestRunHooks=} [properties] Properties to set
                 * @returns {io.cucumber.messages.CommandRunAfterTestRunHooks} CommandRunAfterTestRunHooks instance
                 */
                CommandRunAfterTestRunHooks.create = function create(properties) {
                    return new CommandRunAfterTestRunHooks(properties);
                };

                /**
                 * Encodes the specified CommandRunAfterTestRunHooks message. Does not implicitly {@link io.cucumber.messages.CommandRunAfterTestRunHooks.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.CommandRunAfterTestRunHooks
                 * @static
                 * @param {io.cucumber.messages.ICommandRunAfterTestRunHooks} message CommandRunAfterTestRunHooks message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandRunAfterTestRunHooks.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.actionId);
                    return writer;
                };

                /**
                 * Encodes the specified CommandRunAfterTestRunHooks message, length delimited. Does not implicitly {@link io.cucumber.messages.CommandRunAfterTestRunHooks.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.CommandRunAfterTestRunHooks
                 * @static
                 * @param {io.cucumber.messages.ICommandRunAfterTestRunHooks} message CommandRunAfterTestRunHooks message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandRunAfterTestRunHooks.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CommandRunAfterTestRunHooks message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.CommandRunAfterTestRunHooks
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.CommandRunAfterTestRunHooks} CommandRunAfterTestRunHooks
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandRunAfterTestRunHooks.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.CommandRunAfterTestRunHooks();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.actionId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CommandRunAfterTestRunHooks message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.CommandRunAfterTestRunHooks
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.CommandRunAfterTestRunHooks} CommandRunAfterTestRunHooks
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandRunAfterTestRunHooks.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CommandRunAfterTestRunHooks message.
                 * @function verify
                 * @memberof io.cucumber.messages.CommandRunAfterTestRunHooks
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CommandRunAfterTestRunHooks.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        if (!$util.isString(message.actionId))
                            return "actionId: string expected";
                    return null;
                };

                /**
                 * Creates a CommandRunAfterTestRunHooks message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.CommandRunAfterTestRunHooks
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.CommandRunAfterTestRunHooks} CommandRunAfterTestRunHooks
                 */
                CommandRunAfterTestRunHooks.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.CommandRunAfterTestRunHooks)
                        return object;
                    var message = new $root.io.cucumber.messages.CommandRunAfterTestRunHooks();
                    if (object.actionId != null)
                        message.actionId = String(object.actionId);
                    return message;
                };

                /**
                 * Creates a plain object from a CommandRunAfterTestRunHooks message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.CommandRunAfterTestRunHooks
                 * @static
                 * @param {io.cucumber.messages.CommandRunAfterTestRunHooks} message CommandRunAfterTestRunHooks
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CommandRunAfterTestRunHooks.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.actionId = "";
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        object.actionId = message.actionId;
                    return object;
                };

                /**
                 * Converts this CommandRunAfterTestRunHooks to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.CommandRunAfterTestRunHooks
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CommandRunAfterTestRunHooks.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CommandRunAfterTestRunHooks;
            })();

            messages.CommandInitializeTestCase = (function() {

                /**
                 * Properties of a CommandInitializeTestCase.
                 * @memberof io.cucumber.messages
                 * @interface ICommandInitializeTestCase
                 * @property {string|null} [actionId] CommandInitializeTestCase actionId
                 * @property {io.cucumber.messages.IPickle|null} [pickle] CommandInitializeTestCase pickle
                 */

                /**
                 * Constructs a new CommandInitializeTestCase.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a CommandInitializeTestCase.
                 * @implements ICommandInitializeTestCase
                 * @constructor
                 * @param {io.cucumber.messages.ICommandInitializeTestCase=} [properties] Properties to set
                 */
                function CommandInitializeTestCase(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CommandInitializeTestCase actionId.
                 * @member {string} actionId
                 * @memberof io.cucumber.messages.CommandInitializeTestCase
                 * @instance
                 */
                CommandInitializeTestCase.prototype.actionId = "";

                /**
                 * CommandInitializeTestCase pickle.
                 * @member {io.cucumber.messages.IPickle|null|undefined} pickle
                 * @memberof io.cucumber.messages.CommandInitializeTestCase
                 * @instance
                 */
                CommandInitializeTestCase.prototype.pickle = null;

                /**
                 * Creates a new CommandInitializeTestCase instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.CommandInitializeTestCase
                 * @static
                 * @param {io.cucumber.messages.ICommandInitializeTestCase=} [properties] Properties to set
                 * @returns {io.cucumber.messages.CommandInitializeTestCase} CommandInitializeTestCase instance
                 */
                CommandInitializeTestCase.create = function create(properties) {
                    return new CommandInitializeTestCase(properties);
                };

                /**
                 * Encodes the specified CommandInitializeTestCase message. Does not implicitly {@link io.cucumber.messages.CommandInitializeTestCase.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.CommandInitializeTestCase
                 * @static
                 * @param {io.cucumber.messages.ICommandInitializeTestCase} message CommandInitializeTestCase message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandInitializeTestCase.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.actionId);
                    if (message.pickle != null && message.hasOwnProperty("pickle"))
                        $root.io.cucumber.messages.Pickle.encode(message.pickle, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CommandInitializeTestCase message, length delimited. Does not implicitly {@link io.cucumber.messages.CommandInitializeTestCase.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.CommandInitializeTestCase
                 * @static
                 * @param {io.cucumber.messages.ICommandInitializeTestCase} message CommandInitializeTestCase message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandInitializeTestCase.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CommandInitializeTestCase message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.CommandInitializeTestCase
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.CommandInitializeTestCase} CommandInitializeTestCase
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandInitializeTestCase.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.CommandInitializeTestCase();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.actionId = reader.string();
                            break;
                        case 2:
                            message.pickle = $root.io.cucumber.messages.Pickle.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CommandInitializeTestCase message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.CommandInitializeTestCase
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.CommandInitializeTestCase} CommandInitializeTestCase
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandInitializeTestCase.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CommandInitializeTestCase message.
                 * @function verify
                 * @memberof io.cucumber.messages.CommandInitializeTestCase
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CommandInitializeTestCase.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        if (!$util.isString(message.actionId))
                            return "actionId: string expected";
                    if (message.pickle != null && message.hasOwnProperty("pickle")) {
                        var error = $root.io.cucumber.messages.Pickle.verify(message.pickle);
                        if (error)
                            return "pickle." + error;
                    }
                    return null;
                };

                /**
                 * Creates a CommandInitializeTestCase message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.CommandInitializeTestCase
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.CommandInitializeTestCase} CommandInitializeTestCase
                 */
                CommandInitializeTestCase.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.CommandInitializeTestCase)
                        return object;
                    var message = new $root.io.cucumber.messages.CommandInitializeTestCase();
                    if (object.actionId != null)
                        message.actionId = String(object.actionId);
                    if (object.pickle != null) {
                        if (typeof object.pickle !== "object")
                            throw TypeError(".io.cucumber.messages.CommandInitializeTestCase.pickle: object expected");
                        message.pickle = $root.io.cucumber.messages.Pickle.fromObject(object.pickle);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CommandInitializeTestCase message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.CommandInitializeTestCase
                 * @static
                 * @param {io.cucumber.messages.CommandInitializeTestCase} message CommandInitializeTestCase
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CommandInitializeTestCase.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.actionId = "";
                        object.pickle = null;
                    }
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        object.actionId = message.actionId;
                    if (message.pickle != null && message.hasOwnProperty("pickle"))
                        object.pickle = $root.io.cucumber.messages.Pickle.toObject(message.pickle, options);
                    return object;
                };

                /**
                 * Converts this CommandInitializeTestCase to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.CommandInitializeTestCase
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CommandInitializeTestCase.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CommandInitializeTestCase;
            })();

            messages.CommandRunBeforeTestCaseHook = (function() {

                /**
                 * Properties of a CommandRunBeforeTestCaseHook.
                 * @memberof io.cucumber.messages
                 * @interface ICommandRunBeforeTestCaseHook
                 * @property {string|null} [actionId] CommandRunBeforeTestCaseHook actionId
                 * @property {string|null} [hookId] CommandRunBeforeTestCaseHook hookId
                 * @property {string|null} [testCaseId] CommandRunBeforeTestCaseHook testCaseId
                 */

                /**
                 * Constructs a new CommandRunBeforeTestCaseHook.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a CommandRunBeforeTestCaseHook.
                 * @implements ICommandRunBeforeTestCaseHook
                 * @constructor
                 * @param {io.cucumber.messages.ICommandRunBeforeTestCaseHook=} [properties] Properties to set
                 */
                function CommandRunBeforeTestCaseHook(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CommandRunBeforeTestCaseHook actionId.
                 * @member {string} actionId
                 * @memberof io.cucumber.messages.CommandRunBeforeTestCaseHook
                 * @instance
                 */
                CommandRunBeforeTestCaseHook.prototype.actionId = "";

                /**
                 * CommandRunBeforeTestCaseHook hookId.
                 * @member {string} hookId
                 * @memberof io.cucumber.messages.CommandRunBeforeTestCaseHook
                 * @instance
                 */
                CommandRunBeforeTestCaseHook.prototype.hookId = "";

                /**
                 * CommandRunBeforeTestCaseHook testCaseId.
                 * @member {string} testCaseId
                 * @memberof io.cucumber.messages.CommandRunBeforeTestCaseHook
                 * @instance
                 */
                CommandRunBeforeTestCaseHook.prototype.testCaseId = "";

                /**
                 * Creates a new CommandRunBeforeTestCaseHook instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.CommandRunBeforeTestCaseHook
                 * @static
                 * @param {io.cucumber.messages.ICommandRunBeforeTestCaseHook=} [properties] Properties to set
                 * @returns {io.cucumber.messages.CommandRunBeforeTestCaseHook} CommandRunBeforeTestCaseHook instance
                 */
                CommandRunBeforeTestCaseHook.create = function create(properties) {
                    return new CommandRunBeforeTestCaseHook(properties);
                };

                /**
                 * Encodes the specified CommandRunBeforeTestCaseHook message. Does not implicitly {@link io.cucumber.messages.CommandRunBeforeTestCaseHook.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.CommandRunBeforeTestCaseHook
                 * @static
                 * @param {io.cucumber.messages.ICommandRunBeforeTestCaseHook} message CommandRunBeforeTestCaseHook message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandRunBeforeTestCaseHook.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.actionId);
                    if (message.hookId != null && message.hasOwnProperty("hookId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.hookId);
                    if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.testCaseId);
                    return writer;
                };

                /**
                 * Encodes the specified CommandRunBeforeTestCaseHook message, length delimited. Does not implicitly {@link io.cucumber.messages.CommandRunBeforeTestCaseHook.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.CommandRunBeforeTestCaseHook
                 * @static
                 * @param {io.cucumber.messages.ICommandRunBeforeTestCaseHook} message CommandRunBeforeTestCaseHook message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandRunBeforeTestCaseHook.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CommandRunBeforeTestCaseHook message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.CommandRunBeforeTestCaseHook
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.CommandRunBeforeTestCaseHook} CommandRunBeforeTestCaseHook
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandRunBeforeTestCaseHook.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.CommandRunBeforeTestCaseHook();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.actionId = reader.string();
                            break;
                        case 2:
                            message.hookId = reader.string();
                            break;
                        case 3:
                            message.testCaseId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CommandRunBeforeTestCaseHook message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.CommandRunBeforeTestCaseHook
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.CommandRunBeforeTestCaseHook} CommandRunBeforeTestCaseHook
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandRunBeforeTestCaseHook.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CommandRunBeforeTestCaseHook message.
                 * @function verify
                 * @memberof io.cucumber.messages.CommandRunBeforeTestCaseHook
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CommandRunBeforeTestCaseHook.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        if (!$util.isString(message.actionId))
                            return "actionId: string expected";
                    if (message.hookId != null && message.hasOwnProperty("hookId"))
                        if (!$util.isString(message.hookId))
                            return "hookId: string expected";
                    if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                        if (!$util.isString(message.testCaseId))
                            return "testCaseId: string expected";
                    return null;
                };

                /**
                 * Creates a CommandRunBeforeTestCaseHook message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.CommandRunBeforeTestCaseHook
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.CommandRunBeforeTestCaseHook} CommandRunBeforeTestCaseHook
                 */
                CommandRunBeforeTestCaseHook.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.CommandRunBeforeTestCaseHook)
                        return object;
                    var message = new $root.io.cucumber.messages.CommandRunBeforeTestCaseHook();
                    if (object.actionId != null)
                        message.actionId = String(object.actionId);
                    if (object.hookId != null)
                        message.hookId = String(object.hookId);
                    if (object.testCaseId != null)
                        message.testCaseId = String(object.testCaseId);
                    return message;
                };

                /**
                 * Creates a plain object from a CommandRunBeforeTestCaseHook message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.CommandRunBeforeTestCaseHook
                 * @static
                 * @param {io.cucumber.messages.CommandRunBeforeTestCaseHook} message CommandRunBeforeTestCaseHook
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CommandRunBeforeTestCaseHook.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.actionId = "";
                        object.hookId = "";
                        object.testCaseId = "";
                    }
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        object.actionId = message.actionId;
                    if (message.hookId != null && message.hasOwnProperty("hookId"))
                        object.hookId = message.hookId;
                    if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                        object.testCaseId = message.testCaseId;
                    return object;
                };

                /**
                 * Converts this CommandRunBeforeTestCaseHook to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.CommandRunBeforeTestCaseHook
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CommandRunBeforeTestCaseHook.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CommandRunBeforeTestCaseHook;
            })();

            messages.CommandRunAfterTestCaseHook = (function() {

                /**
                 * Properties of a CommandRunAfterTestCaseHook.
                 * @memberof io.cucumber.messages
                 * @interface ICommandRunAfterTestCaseHook
                 * @property {string|null} [actionId] CommandRunAfterTestCaseHook actionId
                 * @property {string|null} [hookId] CommandRunAfterTestCaseHook hookId
                 * @property {string|null} [testCaseId] CommandRunAfterTestCaseHook testCaseId
                 */

                /**
                 * Constructs a new CommandRunAfterTestCaseHook.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a CommandRunAfterTestCaseHook.
                 * @implements ICommandRunAfterTestCaseHook
                 * @constructor
                 * @param {io.cucumber.messages.ICommandRunAfterTestCaseHook=} [properties] Properties to set
                 */
                function CommandRunAfterTestCaseHook(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CommandRunAfterTestCaseHook actionId.
                 * @member {string} actionId
                 * @memberof io.cucumber.messages.CommandRunAfterTestCaseHook
                 * @instance
                 */
                CommandRunAfterTestCaseHook.prototype.actionId = "";

                /**
                 * CommandRunAfterTestCaseHook hookId.
                 * @member {string} hookId
                 * @memberof io.cucumber.messages.CommandRunAfterTestCaseHook
                 * @instance
                 */
                CommandRunAfterTestCaseHook.prototype.hookId = "";

                /**
                 * CommandRunAfterTestCaseHook testCaseId.
                 * @member {string} testCaseId
                 * @memberof io.cucumber.messages.CommandRunAfterTestCaseHook
                 * @instance
                 */
                CommandRunAfterTestCaseHook.prototype.testCaseId = "";

                /**
                 * Creates a new CommandRunAfterTestCaseHook instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.CommandRunAfterTestCaseHook
                 * @static
                 * @param {io.cucumber.messages.ICommandRunAfterTestCaseHook=} [properties] Properties to set
                 * @returns {io.cucumber.messages.CommandRunAfterTestCaseHook} CommandRunAfterTestCaseHook instance
                 */
                CommandRunAfterTestCaseHook.create = function create(properties) {
                    return new CommandRunAfterTestCaseHook(properties);
                };

                /**
                 * Encodes the specified CommandRunAfterTestCaseHook message. Does not implicitly {@link io.cucumber.messages.CommandRunAfterTestCaseHook.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.CommandRunAfterTestCaseHook
                 * @static
                 * @param {io.cucumber.messages.ICommandRunAfterTestCaseHook} message CommandRunAfterTestCaseHook message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandRunAfterTestCaseHook.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.actionId);
                    if (message.hookId != null && message.hasOwnProperty("hookId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.hookId);
                    if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.testCaseId);
                    return writer;
                };

                /**
                 * Encodes the specified CommandRunAfterTestCaseHook message, length delimited. Does not implicitly {@link io.cucumber.messages.CommandRunAfterTestCaseHook.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.CommandRunAfterTestCaseHook
                 * @static
                 * @param {io.cucumber.messages.ICommandRunAfterTestCaseHook} message CommandRunAfterTestCaseHook message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandRunAfterTestCaseHook.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CommandRunAfterTestCaseHook message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.CommandRunAfterTestCaseHook
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.CommandRunAfterTestCaseHook} CommandRunAfterTestCaseHook
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandRunAfterTestCaseHook.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.CommandRunAfterTestCaseHook();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.actionId = reader.string();
                            break;
                        case 2:
                            message.hookId = reader.string();
                            break;
                        case 3:
                            message.testCaseId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CommandRunAfterTestCaseHook message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.CommandRunAfterTestCaseHook
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.CommandRunAfterTestCaseHook} CommandRunAfterTestCaseHook
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandRunAfterTestCaseHook.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CommandRunAfterTestCaseHook message.
                 * @function verify
                 * @memberof io.cucumber.messages.CommandRunAfterTestCaseHook
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CommandRunAfterTestCaseHook.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        if (!$util.isString(message.actionId))
                            return "actionId: string expected";
                    if (message.hookId != null && message.hasOwnProperty("hookId"))
                        if (!$util.isString(message.hookId))
                            return "hookId: string expected";
                    if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                        if (!$util.isString(message.testCaseId))
                            return "testCaseId: string expected";
                    return null;
                };

                /**
                 * Creates a CommandRunAfterTestCaseHook message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.CommandRunAfterTestCaseHook
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.CommandRunAfterTestCaseHook} CommandRunAfterTestCaseHook
                 */
                CommandRunAfterTestCaseHook.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.CommandRunAfterTestCaseHook)
                        return object;
                    var message = new $root.io.cucumber.messages.CommandRunAfterTestCaseHook();
                    if (object.actionId != null)
                        message.actionId = String(object.actionId);
                    if (object.hookId != null)
                        message.hookId = String(object.hookId);
                    if (object.testCaseId != null)
                        message.testCaseId = String(object.testCaseId);
                    return message;
                };

                /**
                 * Creates a plain object from a CommandRunAfterTestCaseHook message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.CommandRunAfterTestCaseHook
                 * @static
                 * @param {io.cucumber.messages.CommandRunAfterTestCaseHook} message CommandRunAfterTestCaseHook
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CommandRunAfterTestCaseHook.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.actionId = "";
                        object.hookId = "";
                        object.testCaseId = "";
                    }
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        object.actionId = message.actionId;
                    if (message.hookId != null && message.hasOwnProperty("hookId"))
                        object.hookId = message.hookId;
                    if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                        object.testCaseId = message.testCaseId;
                    return object;
                };

                /**
                 * Converts this CommandRunAfterTestCaseHook to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.CommandRunAfterTestCaseHook
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CommandRunAfterTestCaseHook.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CommandRunAfterTestCaseHook;
            })();

            messages.CommandRunTestStep = (function() {

                /**
                 * Properties of a CommandRunTestStep.
                 * @memberof io.cucumber.messages
                 * @interface ICommandRunTestStep
                 * @property {string|null} [actionId] CommandRunTestStep actionId
                 * @property {string|null} [stepDefinitionId] CommandRunTestStep stepDefinitionId
                 * @property {Array.<io.cucumber.messages.IStepMatchArgument>|null} [stepMatchArguments] CommandRunTestStep stepMatchArguments
                 * @property {io.cucumber.messages.IPickleStepArgument|null} [pickleStepArgument] CommandRunTestStep pickleStepArgument
                 * @property {string|null} [testCaseId] CommandRunTestStep testCaseId
                 */

                /**
                 * Constructs a new CommandRunTestStep.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a CommandRunTestStep.
                 * @implements ICommandRunTestStep
                 * @constructor
                 * @param {io.cucumber.messages.ICommandRunTestStep=} [properties] Properties to set
                 */
                function CommandRunTestStep(properties) {
                    this.stepMatchArguments = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CommandRunTestStep actionId.
                 * @member {string} actionId
                 * @memberof io.cucumber.messages.CommandRunTestStep
                 * @instance
                 */
                CommandRunTestStep.prototype.actionId = "";

                /**
                 * CommandRunTestStep stepDefinitionId.
                 * @member {string} stepDefinitionId
                 * @memberof io.cucumber.messages.CommandRunTestStep
                 * @instance
                 */
                CommandRunTestStep.prototype.stepDefinitionId = "";

                /**
                 * CommandRunTestStep stepMatchArguments.
                 * @member {Array.<io.cucumber.messages.IStepMatchArgument>} stepMatchArguments
                 * @memberof io.cucumber.messages.CommandRunTestStep
                 * @instance
                 */
                CommandRunTestStep.prototype.stepMatchArguments = $util.emptyArray;

                /**
                 * CommandRunTestStep pickleStepArgument.
                 * @member {io.cucumber.messages.IPickleStepArgument|null|undefined} pickleStepArgument
                 * @memberof io.cucumber.messages.CommandRunTestStep
                 * @instance
                 */
                CommandRunTestStep.prototype.pickleStepArgument = null;

                /**
                 * CommandRunTestStep testCaseId.
                 * @member {string} testCaseId
                 * @memberof io.cucumber.messages.CommandRunTestStep
                 * @instance
                 */
                CommandRunTestStep.prototype.testCaseId = "";

                /**
                 * Creates a new CommandRunTestStep instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.CommandRunTestStep
                 * @static
                 * @param {io.cucumber.messages.ICommandRunTestStep=} [properties] Properties to set
                 * @returns {io.cucumber.messages.CommandRunTestStep} CommandRunTestStep instance
                 */
                CommandRunTestStep.create = function create(properties) {
                    return new CommandRunTestStep(properties);
                };

                /**
                 * Encodes the specified CommandRunTestStep message. Does not implicitly {@link io.cucumber.messages.CommandRunTestStep.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.CommandRunTestStep
                 * @static
                 * @param {io.cucumber.messages.ICommandRunTestStep} message CommandRunTestStep message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandRunTestStep.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.actionId);
                    if (message.stepDefinitionId != null && message.hasOwnProperty("stepDefinitionId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.stepDefinitionId);
                    if (message.stepMatchArguments != null && message.stepMatchArguments.length)
                        for (var i = 0; i < message.stepMatchArguments.length; ++i)
                            $root.io.cucumber.messages.StepMatchArgument.encode(message.stepMatchArguments[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.pickleStepArgument != null && message.hasOwnProperty("pickleStepArgument"))
                        $root.io.cucumber.messages.PickleStepArgument.encode(message.pickleStepArgument, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.testCaseId);
                    return writer;
                };

                /**
                 * Encodes the specified CommandRunTestStep message, length delimited. Does not implicitly {@link io.cucumber.messages.CommandRunTestStep.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.CommandRunTestStep
                 * @static
                 * @param {io.cucumber.messages.ICommandRunTestStep} message CommandRunTestStep message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandRunTestStep.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CommandRunTestStep message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.CommandRunTestStep
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.CommandRunTestStep} CommandRunTestStep
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandRunTestStep.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.CommandRunTestStep();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.actionId = reader.string();
                            break;
                        case 2:
                            message.stepDefinitionId = reader.string();
                            break;
                        case 3:
                            if (!(message.stepMatchArguments && message.stepMatchArguments.length))
                                message.stepMatchArguments = [];
                            message.stepMatchArguments.push($root.io.cucumber.messages.StepMatchArgument.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            message.pickleStepArgument = $root.io.cucumber.messages.PickleStepArgument.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.testCaseId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CommandRunTestStep message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.CommandRunTestStep
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.CommandRunTestStep} CommandRunTestStep
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandRunTestStep.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CommandRunTestStep message.
                 * @function verify
                 * @memberof io.cucumber.messages.CommandRunTestStep
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CommandRunTestStep.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        if (!$util.isString(message.actionId))
                            return "actionId: string expected";
                    if (message.stepDefinitionId != null && message.hasOwnProperty("stepDefinitionId"))
                        if (!$util.isString(message.stepDefinitionId))
                            return "stepDefinitionId: string expected";
                    if (message.stepMatchArguments != null && message.hasOwnProperty("stepMatchArguments")) {
                        if (!Array.isArray(message.stepMatchArguments))
                            return "stepMatchArguments: array expected";
                        for (var i = 0; i < message.stepMatchArguments.length; ++i) {
                            var error = $root.io.cucumber.messages.StepMatchArgument.verify(message.stepMatchArguments[i]);
                            if (error)
                                return "stepMatchArguments." + error;
                        }
                    }
                    if (message.pickleStepArgument != null && message.hasOwnProperty("pickleStepArgument")) {
                        var error = $root.io.cucumber.messages.PickleStepArgument.verify(message.pickleStepArgument);
                        if (error)
                            return "pickleStepArgument." + error;
                    }
                    if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                        if (!$util.isString(message.testCaseId))
                            return "testCaseId: string expected";
                    return null;
                };

                /**
                 * Creates a CommandRunTestStep message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.CommandRunTestStep
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.CommandRunTestStep} CommandRunTestStep
                 */
                CommandRunTestStep.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.CommandRunTestStep)
                        return object;
                    var message = new $root.io.cucumber.messages.CommandRunTestStep();
                    if (object.actionId != null)
                        message.actionId = String(object.actionId);
                    if (object.stepDefinitionId != null)
                        message.stepDefinitionId = String(object.stepDefinitionId);
                    if (object.stepMatchArguments) {
                        if (!Array.isArray(object.stepMatchArguments))
                            throw TypeError(".io.cucumber.messages.CommandRunTestStep.stepMatchArguments: array expected");
                        message.stepMatchArguments = [];
                        for (var i = 0; i < object.stepMatchArguments.length; ++i) {
                            if (typeof object.stepMatchArguments[i] !== "object")
                                throw TypeError(".io.cucumber.messages.CommandRunTestStep.stepMatchArguments: object expected");
                            message.stepMatchArguments[i] = $root.io.cucumber.messages.StepMatchArgument.fromObject(object.stepMatchArguments[i]);
                        }
                    }
                    if (object.pickleStepArgument != null) {
                        if (typeof object.pickleStepArgument !== "object")
                            throw TypeError(".io.cucumber.messages.CommandRunTestStep.pickleStepArgument: object expected");
                        message.pickleStepArgument = $root.io.cucumber.messages.PickleStepArgument.fromObject(object.pickleStepArgument);
                    }
                    if (object.testCaseId != null)
                        message.testCaseId = String(object.testCaseId);
                    return message;
                };

                /**
                 * Creates a plain object from a CommandRunTestStep message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.CommandRunTestStep
                 * @static
                 * @param {io.cucumber.messages.CommandRunTestStep} message CommandRunTestStep
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CommandRunTestStep.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.stepMatchArguments = [];
                    if (options.defaults) {
                        object.actionId = "";
                        object.stepDefinitionId = "";
                        object.pickleStepArgument = null;
                        object.testCaseId = "";
                    }
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        object.actionId = message.actionId;
                    if (message.stepDefinitionId != null && message.hasOwnProperty("stepDefinitionId"))
                        object.stepDefinitionId = message.stepDefinitionId;
                    if (message.stepMatchArguments && message.stepMatchArguments.length) {
                        object.stepMatchArguments = [];
                        for (var j = 0; j < message.stepMatchArguments.length; ++j)
                            object.stepMatchArguments[j] = $root.io.cucumber.messages.StepMatchArgument.toObject(message.stepMatchArguments[j], options);
                    }
                    if (message.pickleStepArgument != null && message.hasOwnProperty("pickleStepArgument"))
                        object.pickleStepArgument = $root.io.cucumber.messages.PickleStepArgument.toObject(message.pickleStepArgument, options);
                    if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                        object.testCaseId = message.testCaseId;
                    return object;
                };

                /**
                 * Converts this CommandRunTestStep to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.CommandRunTestStep
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CommandRunTestStep.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CommandRunTestStep;
            })();

            messages.StepMatchArgument = (function() {

                /**
                 * Properties of a StepMatchArgument.
                 * @memberof io.cucumber.messages
                 * @interface IStepMatchArgument
                 * @property {string|null} [parameterTypeName] StepMatchArgument parameterTypeName
                 * @property {io.cucumber.messages.StepMatchArgument.IGroup|null} [group] Represents the outermost capture group of an argument. This message closely matches the
                 * `Group` class in the `cucumber-expressions` library.
                 */

                /**
                 * Constructs a new StepMatchArgument.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a single argument extracted from a step match and passed to a step definition.
                 * This is used for the following purposes:
                 * - Construct an argument to pass to a step definition (possibly through a parameter type transform)
                 * - Highlight the matched parameter in rich formatters such as the HTML formatter
                 * 
                 * This message closely matches the `Argument` class in the `cucumber-expressions` library.
                 * @implements IStepMatchArgument
                 * @constructor
                 * @param {io.cucumber.messages.IStepMatchArgument=} [properties] Properties to set
                 */
                function StepMatchArgument(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StepMatchArgument parameterTypeName.
                 * @member {string} parameterTypeName
                 * @memberof io.cucumber.messages.StepMatchArgument
                 * @instance
                 */
                StepMatchArgument.prototype.parameterTypeName = "";

                /**
                 * Represents the outermost capture group of an argument. This message closely matches the
                 * `Group` class in the `cucumber-expressions` library.
                 * @member {io.cucumber.messages.StepMatchArgument.IGroup|null|undefined} group
                 * @memberof io.cucumber.messages.StepMatchArgument
                 * @instance
                 */
                StepMatchArgument.prototype.group = null;

                /**
                 * Creates a new StepMatchArgument instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.StepMatchArgument
                 * @static
                 * @param {io.cucumber.messages.IStepMatchArgument=} [properties] Properties to set
                 * @returns {io.cucumber.messages.StepMatchArgument} StepMatchArgument instance
                 */
                StepMatchArgument.create = function create(properties) {
                    return new StepMatchArgument(properties);
                };

                /**
                 * Encodes the specified StepMatchArgument message. Does not implicitly {@link io.cucumber.messages.StepMatchArgument.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.StepMatchArgument
                 * @static
                 * @param {io.cucumber.messages.IStepMatchArgument} message StepMatchArgument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StepMatchArgument.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.parameterTypeName != null && message.hasOwnProperty("parameterTypeName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.parameterTypeName);
                    if (message.group != null && message.hasOwnProperty("group"))
                        $root.io.cucumber.messages.StepMatchArgument.Group.encode(message.group, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified StepMatchArgument message, length delimited. Does not implicitly {@link io.cucumber.messages.StepMatchArgument.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.StepMatchArgument
                 * @static
                 * @param {io.cucumber.messages.IStepMatchArgument} message StepMatchArgument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StepMatchArgument.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StepMatchArgument message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.StepMatchArgument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.StepMatchArgument} StepMatchArgument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StepMatchArgument.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.StepMatchArgument();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.parameterTypeName = reader.string();
                            break;
                        case 2:
                            message.group = $root.io.cucumber.messages.StepMatchArgument.Group.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StepMatchArgument message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.StepMatchArgument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.StepMatchArgument} StepMatchArgument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StepMatchArgument.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StepMatchArgument message.
                 * @function verify
                 * @memberof io.cucumber.messages.StepMatchArgument
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StepMatchArgument.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.parameterTypeName != null && message.hasOwnProperty("parameterTypeName"))
                        if (!$util.isString(message.parameterTypeName))
                            return "parameterTypeName: string expected";
                    if (message.group != null && message.hasOwnProperty("group")) {
                        var error = $root.io.cucumber.messages.StepMatchArgument.Group.verify(message.group);
                        if (error)
                            return "group." + error;
                    }
                    return null;
                };

                /**
                 * Creates a StepMatchArgument message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.StepMatchArgument
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.StepMatchArgument} StepMatchArgument
                 */
                StepMatchArgument.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.StepMatchArgument)
                        return object;
                    var message = new $root.io.cucumber.messages.StepMatchArgument();
                    if (object.parameterTypeName != null)
                        message.parameterTypeName = String(object.parameterTypeName);
                    if (object.group != null) {
                        if (typeof object.group !== "object")
                            throw TypeError(".io.cucumber.messages.StepMatchArgument.group: object expected");
                        message.group = $root.io.cucumber.messages.StepMatchArgument.Group.fromObject(object.group);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a StepMatchArgument message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.StepMatchArgument
                 * @static
                 * @param {io.cucumber.messages.StepMatchArgument} message StepMatchArgument
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StepMatchArgument.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.parameterTypeName = "";
                        object.group = null;
                    }
                    if (message.parameterTypeName != null && message.hasOwnProperty("parameterTypeName"))
                        object.parameterTypeName = message.parameterTypeName;
                    if (message.group != null && message.hasOwnProperty("group"))
                        object.group = $root.io.cucumber.messages.StepMatchArgument.Group.toObject(message.group, options);
                    return object;
                };

                /**
                 * Converts this StepMatchArgument to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.StepMatchArgument
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StepMatchArgument.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                StepMatchArgument.Group = (function() {

                    /**
                     * Properties of a Group.
                     * @memberof io.cucumber.messages.StepMatchArgument
                     * @interface IGroup
                     * @property {number|null} [start] Group start
                     * @property {string|null} [value] Group value
                     * @property {Array.<io.cucumber.messages.StepMatchArgument.IGroup>|null} [children] Group children
                     */

                    /**
                     * Constructs a new Group.
                     * @memberof io.cucumber.messages.StepMatchArgument
                     * @classdesc Represents a Group.
                     * @implements IGroup
                     * @constructor
                     * @param {io.cucumber.messages.StepMatchArgument.IGroup=} [properties] Properties to set
                     */
                    function Group(properties) {
                        this.children = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Group start.
                     * @member {number} start
                     * @memberof io.cucumber.messages.StepMatchArgument.Group
                     * @instance
                     */
                    Group.prototype.start = 0;

                    /**
                     * Group value.
                     * @member {string} value
                     * @memberof io.cucumber.messages.StepMatchArgument.Group
                     * @instance
                     */
                    Group.prototype.value = "";

                    /**
                     * Group children.
                     * @member {Array.<io.cucumber.messages.StepMatchArgument.IGroup>} children
                     * @memberof io.cucumber.messages.StepMatchArgument.Group
                     * @instance
                     */
                    Group.prototype.children = $util.emptyArray;

                    /**
                     * Creates a new Group instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.StepMatchArgument.Group
                     * @static
                     * @param {io.cucumber.messages.StepMatchArgument.IGroup=} [properties] Properties to set
                     * @returns {io.cucumber.messages.StepMatchArgument.Group} Group instance
                     */
                    Group.create = function create(properties) {
                        return new Group(properties);
                    };

                    /**
                     * Encodes the specified Group message. Does not implicitly {@link io.cucumber.messages.StepMatchArgument.Group.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.StepMatchArgument.Group
                     * @static
                     * @param {io.cucumber.messages.StepMatchArgument.IGroup} message Group message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Group.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && message.hasOwnProperty("start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.start);
                        if (message.value != null && message.hasOwnProperty("value"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                        if (message.children != null && message.children.length)
                            for (var i = 0; i < message.children.length; ++i)
                                $root.io.cucumber.messages.StepMatchArgument.Group.encode(message.children[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Group message, length delimited. Does not implicitly {@link io.cucumber.messages.StepMatchArgument.Group.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.StepMatchArgument.Group
                     * @static
                     * @param {io.cucumber.messages.StepMatchArgument.IGroup} message Group message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Group.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Group message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.StepMatchArgument.Group
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.StepMatchArgument.Group} Group
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Group.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.StepMatchArgument.Group();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.uint32();
                                break;
                            case 2:
                                message.value = reader.string();
                                break;
                            case 3:
                                if (!(message.children && message.children.length))
                                    message.children = [];
                                message.children.push($root.io.cucumber.messages.StepMatchArgument.Group.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Group message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.StepMatchArgument.Group
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.StepMatchArgument.Group} Group
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Group.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Group message.
                     * @function verify
                     * @memberof io.cucumber.messages.StepMatchArgument.Group
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Group.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isString(message.value))
                                return "value: string expected";
                        if (message.children != null && message.hasOwnProperty("children")) {
                            if (!Array.isArray(message.children))
                                return "children: array expected";
                            for (var i = 0; i < message.children.length; ++i) {
                                var error = $root.io.cucumber.messages.StepMatchArgument.Group.verify(message.children[i]);
                                if (error)
                                    return "children." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Group message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.StepMatchArgument.Group
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.StepMatchArgument.Group} Group
                     */
                    Group.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.StepMatchArgument.Group)
                            return object;
                        var message = new $root.io.cucumber.messages.StepMatchArgument.Group();
                        if (object.start != null)
                            message.start = object.start >>> 0;
                        if (object.value != null)
                            message.value = String(object.value);
                        if (object.children) {
                            if (!Array.isArray(object.children))
                                throw TypeError(".io.cucumber.messages.StepMatchArgument.Group.children: array expected");
                            message.children = [];
                            for (var i = 0; i < object.children.length; ++i) {
                                if (typeof object.children[i] !== "object")
                                    throw TypeError(".io.cucumber.messages.StepMatchArgument.Group.children: object expected");
                                message.children[i] = $root.io.cucumber.messages.StepMatchArgument.Group.fromObject(object.children[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Group message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.StepMatchArgument.Group
                     * @static
                     * @param {io.cucumber.messages.StepMatchArgument.Group} message Group
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Group.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.children = [];
                        if (options.defaults) {
                            object.start = 0;
                            object.value = "";
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = message.value;
                        if (message.children && message.children.length) {
                            object.children = [];
                            for (var j = 0; j < message.children.length; ++j)
                                object.children[j] = $root.io.cucumber.messages.StepMatchArgument.Group.toObject(message.children[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Group to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.StepMatchArgument.Group
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Group.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Group;
                })();

                return StepMatchArgument;
            })();

            messages.CommandGenerateSnippet = (function() {

                /**
                 * Properties of a CommandGenerateSnippet.
                 * @memberof io.cucumber.messages
                 * @interface ICommandGenerateSnippet
                 * @property {string|null} [actionId] CommandGenerateSnippet actionId
                 * @property {Array.<io.cucumber.messages.IGeneratedExpression>|null} [generatedExpressions] CommandGenerateSnippet generatedExpressions
                 * @property {io.cucumber.messages.IPickleStepArgument|null} [pickleStepArgument] CommandGenerateSnippet pickleStepArgument
                 */

                /**
                 * Constructs a new CommandGenerateSnippet.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a CommandGenerateSnippet.
                 * @implements ICommandGenerateSnippet
                 * @constructor
                 * @param {io.cucumber.messages.ICommandGenerateSnippet=} [properties] Properties to set
                 */
                function CommandGenerateSnippet(properties) {
                    this.generatedExpressions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CommandGenerateSnippet actionId.
                 * @member {string} actionId
                 * @memberof io.cucumber.messages.CommandGenerateSnippet
                 * @instance
                 */
                CommandGenerateSnippet.prototype.actionId = "";

                /**
                 * CommandGenerateSnippet generatedExpressions.
                 * @member {Array.<io.cucumber.messages.IGeneratedExpression>} generatedExpressions
                 * @memberof io.cucumber.messages.CommandGenerateSnippet
                 * @instance
                 */
                CommandGenerateSnippet.prototype.generatedExpressions = $util.emptyArray;

                /**
                 * CommandGenerateSnippet pickleStepArgument.
                 * @member {io.cucumber.messages.IPickleStepArgument|null|undefined} pickleStepArgument
                 * @memberof io.cucumber.messages.CommandGenerateSnippet
                 * @instance
                 */
                CommandGenerateSnippet.prototype.pickleStepArgument = null;

                /**
                 * Creates a new CommandGenerateSnippet instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.CommandGenerateSnippet
                 * @static
                 * @param {io.cucumber.messages.ICommandGenerateSnippet=} [properties] Properties to set
                 * @returns {io.cucumber.messages.CommandGenerateSnippet} CommandGenerateSnippet instance
                 */
                CommandGenerateSnippet.create = function create(properties) {
                    return new CommandGenerateSnippet(properties);
                };

                /**
                 * Encodes the specified CommandGenerateSnippet message. Does not implicitly {@link io.cucumber.messages.CommandGenerateSnippet.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.CommandGenerateSnippet
                 * @static
                 * @param {io.cucumber.messages.ICommandGenerateSnippet} message CommandGenerateSnippet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandGenerateSnippet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.actionId);
                    if (message.generatedExpressions != null && message.generatedExpressions.length)
                        for (var i = 0; i < message.generatedExpressions.length; ++i)
                            $root.io.cucumber.messages.GeneratedExpression.encode(message.generatedExpressions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.pickleStepArgument != null && message.hasOwnProperty("pickleStepArgument"))
                        $root.io.cucumber.messages.PickleStepArgument.encode(message.pickleStepArgument, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CommandGenerateSnippet message, length delimited. Does not implicitly {@link io.cucumber.messages.CommandGenerateSnippet.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.CommandGenerateSnippet
                 * @static
                 * @param {io.cucumber.messages.ICommandGenerateSnippet} message CommandGenerateSnippet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandGenerateSnippet.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CommandGenerateSnippet message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.CommandGenerateSnippet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.CommandGenerateSnippet} CommandGenerateSnippet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandGenerateSnippet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.CommandGenerateSnippet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.actionId = reader.string();
                            break;
                        case 2:
                            if (!(message.generatedExpressions && message.generatedExpressions.length))
                                message.generatedExpressions = [];
                            message.generatedExpressions.push($root.io.cucumber.messages.GeneratedExpression.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.pickleStepArgument = $root.io.cucumber.messages.PickleStepArgument.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CommandGenerateSnippet message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.CommandGenerateSnippet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.CommandGenerateSnippet} CommandGenerateSnippet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandGenerateSnippet.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CommandGenerateSnippet message.
                 * @function verify
                 * @memberof io.cucumber.messages.CommandGenerateSnippet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CommandGenerateSnippet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        if (!$util.isString(message.actionId))
                            return "actionId: string expected";
                    if (message.generatedExpressions != null && message.hasOwnProperty("generatedExpressions")) {
                        if (!Array.isArray(message.generatedExpressions))
                            return "generatedExpressions: array expected";
                        for (var i = 0; i < message.generatedExpressions.length; ++i) {
                            var error = $root.io.cucumber.messages.GeneratedExpression.verify(message.generatedExpressions[i]);
                            if (error)
                                return "generatedExpressions." + error;
                        }
                    }
                    if (message.pickleStepArgument != null && message.hasOwnProperty("pickleStepArgument")) {
                        var error = $root.io.cucumber.messages.PickleStepArgument.verify(message.pickleStepArgument);
                        if (error)
                            return "pickleStepArgument." + error;
                    }
                    return null;
                };

                /**
                 * Creates a CommandGenerateSnippet message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.CommandGenerateSnippet
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.CommandGenerateSnippet} CommandGenerateSnippet
                 */
                CommandGenerateSnippet.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.CommandGenerateSnippet)
                        return object;
                    var message = new $root.io.cucumber.messages.CommandGenerateSnippet();
                    if (object.actionId != null)
                        message.actionId = String(object.actionId);
                    if (object.generatedExpressions) {
                        if (!Array.isArray(object.generatedExpressions))
                            throw TypeError(".io.cucumber.messages.CommandGenerateSnippet.generatedExpressions: array expected");
                        message.generatedExpressions = [];
                        for (var i = 0; i < object.generatedExpressions.length; ++i) {
                            if (typeof object.generatedExpressions[i] !== "object")
                                throw TypeError(".io.cucumber.messages.CommandGenerateSnippet.generatedExpressions: object expected");
                            message.generatedExpressions[i] = $root.io.cucumber.messages.GeneratedExpression.fromObject(object.generatedExpressions[i]);
                        }
                    }
                    if (object.pickleStepArgument != null) {
                        if (typeof object.pickleStepArgument !== "object")
                            throw TypeError(".io.cucumber.messages.CommandGenerateSnippet.pickleStepArgument: object expected");
                        message.pickleStepArgument = $root.io.cucumber.messages.PickleStepArgument.fromObject(object.pickleStepArgument);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CommandGenerateSnippet message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.CommandGenerateSnippet
                 * @static
                 * @param {io.cucumber.messages.CommandGenerateSnippet} message CommandGenerateSnippet
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CommandGenerateSnippet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.generatedExpressions = [];
                    if (options.defaults) {
                        object.actionId = "";
                        object.pickleStepArgument = null;
                    }
                    if (message.actionId != null && message.hasOwnProperty("actionId"))
                        object.actionId = message.actionId;
                    if (message.generatedExpressions && message.generatedExpressions.length) {
                        object.generatedExpressions = [];
                        for (var j = 0; j < message.generatedExpressions.length; ++j)
                            object.generatedExpressions[j] = $root.io.cucumber.messages.GeneratedExpression.toObject(message.generatedExpressions[j], options);
                    }
                    if (message.pickleStepArgument != null && message.hasOwnProperty("pickleStepArgument"))
                        object.pickleStepArgument = $root.io.cucumber.messages.PickleStepArgument.toObject(message.pickleStepArgument, options);
                    return object;
                };

                /**
                 * Converts this CommandGenerateSnippet to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.CommandGenerateSnippet
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CommandGenerateSnippet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CommandGenerateSnippet;
            })();

            messages.GeneratedExpression = (function() {

                /**
                 * Properties of a GeneratedExpression.
                 * @memberof io.cucumber.messages
                 * @interface IGeneratedExpression
                 * @property {string|null} [text] GeneratedExpression text
                 * @property {Array.<string>|null} [parameterTypeNames] GeneratedExpression parameterTypeNames
                 */

                /**
                 * Constructs a new GeneratedExpression.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a GeneratedExpression.
                 * @implements IGeneratedExpression
                 * @constructor
                 * @param {io.cucumber.messages.IGeneratedExpression=} [properties] Properties to set
                 */
                function GeneratedExpression(properties) {
                    this.parameterTypeNames = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GeneratedExpression text.
                 * @member {string} text
                 * @memberof io.cucumber.messages.GeneratedExpression
                 * @instance
                 */
                GeneratedExpression.prototype.text = "";

                /**
                 * GeneratedExpression parameterTypeNames.
                 * @member {Array.<string>} parameterTypeNames
                 * @memberof io.cucumber.messages.GeneratedExpression
                 * @instance
                 */
                GeneratedExpression.prototype.parameterTypeNames = $util.emptyArray;

                /**
                 * Creates a new GeneratedExpression instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.GeneratedExpression
                 * @static
                 * @param {io.cucumber.messages.IGeneratedExpression=} [properties] Properties to set
                 * @returns {io.cucumber.messages.GeneratedExpression} GeneratedExpression instance
                 */
                GeneratedExpression.create = function create(properties) {
                    return new GeneratedExpression(properties);
                };

                /**
                 * Encodes the specified GeneratedExpression message. Does not implicitly {@link io.cucumber.messages.GeneratedExpression.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.GeneratedExpression
                 * @static
                 * @param {io.cucumber.messages.IGeneratedExpression} message GeneratedExpression message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeneratedExpression.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.text != null && message.hasOwnProperty("text"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                    if (message.parameterTypeNames != null && message.parameterTypeNames.length)
                        for (var i = 0; i < message.parameterTypeNames.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.parameterTypeNames[i]);
                    return writer;
                };

                /**
                 * Encodes the specified GeneratedExpression message, length delimited. Does not implicitly {@link io.cucumber.messages.GeneratedExpression.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.GeneratedExpression
                 * @static
                 * @param {io.cucumber.messages.IGeneratedExpression} message GeneratedExpression message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeneratedExpression.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GeneratedExpression message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.GeneratedExpression
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.GeneratedExpression} GeneratedExpression
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeneratedExpression.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GeneratedExpression();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.text = reader.string();
                            break;
                        case 2:
                            if (!(message.parameterTypeNames && message.parameterTypeNames.length))
                                message.parameterTypeNames = [];
                            message.parameterTypeNames.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GeneratedExpression message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.GeneratedExpression
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.GeneratedExpression} GeneratedExpression
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeneratedExpression.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GeneratedExpression message.
                 * @function verify
                 * @memberof io.cucumber.messages.GeneratedExpression
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GeneratedExpression.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.text != null && message.hasOwnProperty("text"))
                        if (!$util.isString(message.text))
                            return "text: string expected";
                    if (message.parameterTypeNames != null && message.hasOwnProperty("parameterTypeNames")) {
                        if (!Array.isArray(message.parameterTypeNames))
                            return "parameterTypeNames: array expected";
                        for (var i = 0; i < message.parameterTypeNames.length; ++i)
                            if (!$util.isString(message.parameterTypeNames[i]))
                                return "parameterTypeNames: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a GeneratedExpression message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.GeneratedExpression
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.GeneratedExpression} GeneratedExpression
                 */
                GeneratedExpression.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.GeneratedExpression)
                        return object;
                    var message = new $root.io.cucumber.messages.GeneratedExpression();
                    if (object.text != null)
                        message.text = String(object.text);
                    if (object.parameterTypeNames) {
                        if (!Array.isArray(object.parameterTypeNames))
                            throw TypeError(".io.cucumber.messages.GeneratedExpression.parameterTypeNames: array expected");
                        message.parameterTypeNames = [];
                        for (var i = 0; i < object.parameterTypeNames.length; ++i)
                            message.parameterTypeNames[i] = String(object.parameterTypeNames[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GeneratedExpression message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.GeneratedExpression
                 * @static
                 * @param {io.cucumber.messages.GeneratedExpression} message GeneratedExpression
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GeneratedExpression.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.parameterTypeNames = [];
                    if (options.defaults)
                        object.text = "";
                    if (message.text != null && message.hasOwnProperty("text"))
                        object.text = message.text;
                    if (message.parameterTypeNames && message.parameterTypeNames.length) {
                        object.parameterTypeNames = [];
                        for (var j = 0; j < message.parameterTypeNames.length; ++j)
                            object.parameterTypeNames[j] = message.parameterTypeNames[j];
                    }
                    return object;
                };

                /**
                 * Converts this GeneratedExpression to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.GeneratedExpression
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GeneratedExpression.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GeneratedExpression;
            })();

            return messages;
        })();

        return cucumber;
    })();

    return io;
})();

module.exports = $root;


/***/ }),

/***/ 6106:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var MessageToBinaryStream_1 = __importDefault(__webpack_require__(1592));
exports.MessageToBinaryStream = MessageToBinaryStream_1.default;
var MessageToNdjsonStream_1 = __importDefault(__webpack_require__(4620));
exports.MessageToNdjsonStream = MessageToNdjsonStream_1.default;
var BinaryToMessageStream_1 = __importDefault(__webpack_require__(4615));
exports.BinaryToMessageStream = BinaryToMessageStream_1.default;
var NdjsonToMessageStream_1 = __importDefault(__webpack_require__(5734));
exports.NdjsonToMessageStream = NdjsonToMessageStream_1.default;
var TimeConversion = __importStar(__webpack_require__(4321));
exports.TimeConversion = TimeConversion;
var IdGenerator = __importStar(__webpack_require__(9145));
exports.IdGenerator = IdGenerator;
var cucumber_messages_1 = __webpack_require__(2364);
var messages = cucumber_messages_1.io.cucumber.messages;
exports.messages = messages;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8932:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class Deprecation extends Error {
  constructor(message) {
    super(message); // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    this.name = 'Deprecation';
  }

}

exports.Deprecation = Deprecation;


/***/ }),

/***/ 8171:
/***/ ((module) => {

"use strict";


var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

module.exports = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};


/***/ }),

/***/ 7335:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formatter = __webpack_require__(7852)

var fault = create(Error)

module.exports = fault

fault.eval = create(EvalError)
fault.range = create(RangeError)
fault.reference = create(ReferenceError)
fault.syntax = create(SyntaxError)
fault.type = create(TypeError)
fault.uri = create(URIError)

fault.create = create

// Create a new `EConstructor`, with the formatted `format` as a first argument.
function create(EConstructor) {
  FormattedError.displayName = EConstructor.displayName || EConstructor.name

  return FormattedError

  function FormattedError(format) {
    if (format) {
      format = formatter.apply(null, arguments)
    }

    return new EConstructor(format)
  }
}


/***/ }),

/***/ 7852:
/***/ ((module) => {

//
// format - printf-like string formatting for JavaScript
// github.com/samsonjs/format
// @_sjs
//
// Copyright 2010 - 2013 Sami Samhuri <sami@samhuri.net>
//
// MIT License
// http://sjs.mit-license.org
//

;(function() {

  //// Export the API
  var namespace;

  // CommonJS / Node module
  if (true) {
    namespace = module.exports = format;
  }

  // Browsers and other environments
  else {}

  namespace.format = format;
  namespace.vsprintf = vsprintf;

  if (typeof console !== 'undefined' && typeof console.log === 'function') {
    namespace.printf = printf;
  }

  function printf(/* ... */) {
    console.log(format.apply(null, arguments));
  }

  function vsprintf(fmt, replacements) {
    return format.apply(null, [fmt].concat(replacements));
  }

  function format(fmt) {
    var argIndex = 1 // skip initial format argument
      , args = [].slice.call(arguments)
      , i = 0
      , n = fmt.length
      , result = ''
      , c
      , escaped = false
      , arg
      , tmp
      , leadingZero = false
      , precision
      , nextArg = function() { return args[argIndex++]; }
      , slurpNumber = function() {
          var digits = '';
          while (/\d/.test(fmt[i])) {
            digits += fmt[i++];
            c = fmt[i];
          }
          return digits.length > 0 ? parseInt(digits) : null;
        }
      ;
    for (; i < n; ++i) {
      c = fmt[i];
      if (escaped) {
        escaped = false;
        if (c == '.') {
          leadingZero = false;
          c = fmt[++i];
        }
        else if (c == '0' && fmt[i + 1] == '.') {
          leadingZero = true;
          i += 2;
          c = fmt[i];
        }
        else {
          leadingZero = true;
        }
        precision = slurpNumber();
        switch (c) {
        case 'b': // number in binary
          result += parseInt(nextArg(), 10).toString(2);
          break;
        case 'c': // character
          arg = nextArg();
          if (typeof arg === 'string' || arg instanceof String)
            result += arg;
          else
            result += String.fromCharCode(parseInt(arg, 10));
          break;
        case 'd': // number in decimal
          result += parseInt(nextArg(), 10);
          break;
        case 'f': // floating point number
          tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
          result += leadingZero ? tmp : tmp.replace(/^0/, '');
          break;
        case 'j': // JSON
          result += JSON.stringify(nextArg());
          break;
        case 'o': // number in octal
          result += '0' + parseInt(nextArg(), 10).toString(8);
          break;
        case 's': // string
          result += nextArg();
          break;
        case 'x': // lowercase hexadecimal
          result += '0x' + parseInt(nextArg(), 10).toString(16);
          break;
        case 'X': // uppercase hexadecimal
          result += '0x' + parseInt(nextArg(), 10).toString(16).toUpperCase();
          break;
        default:
          result += c;
          break;
        }
      } else if (c === '%') {
        escaped = true;
      } else {
        result += c;
      }
    }
    return result;
  }

}());


/***/ }),

/***/ 6863:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = realpath
realpath.realpath = realpath
realpath.sync = realpathSync
realpath.realpathSync = realpathSync
realpath.monkeypatch = monkeypatch
realpath.unmonkeypatch = unmonkeypatch

var fs = __webpack_require__(5747)
var origRealpath = fs.realpath
var origRealpathSync = fs.realpathSync

var version = process.version
var ok = /^v[0-5]\./.test(version)
var old = __webpack_require__(1734)

function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache
    cache = null
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb)
    } else {
      cb(er, result)
    }
  })
}

function realpathSync (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs.realpath = realpath
  fs.realpathSync = realpathSync
}

function unmonkeypatch () {
  fs.realpath = origRealpath
  fs.realpathSync = origRealpathSync
}


/***/ }),

/***/ 1734:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var pathModule = __webpack_require__(5622);
var isWindows = process.platform === 'win32';
var fs = __webpack_require__(5747);

// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = pathModule.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};


/***/ }),

/***/ 6431:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var AstNode_1 = __importDefault(__webpack_require__(6901));
var cucumber_messages_1 = __webpack_require__(6106);
var Parser_1 = __webpack_require__(3332);
var Errors_1 = __webpack_require__(9259);
var createLocation_1 = __importDefault(__webpack_require__(7134));
var AstBuilder = /** @class */ (function () {
    function AstBuilder(newId) {
        this.newId = newId;
        if (!newId) {
            throw new Error('No newId');
        }
        this.reset();
    }
    AstBuilder.prototype.reset = function () {
        this.stack = [new AstNode_1.default(Parser_1.RuleType.None)];
        this.comments = [];
    };
    AstBuilder.prototype.startRule = function (ruleType) {
        this.stack.push(new AstNode_1.default(ruleType));
    };
    AstBuilder.prototype.endRule = function (ruleType) {
        var node = this.stack.pop();
        var transformedNode = this.transformNode(node);
        this.currentNode().add(node.ruleType, transformedNode);
    };
    AstBuilder.prototype.build = function (token) {
        if (token.matchedType === Parser_1.TokenType.Comment) {
            this.comments.push(cucumber_messages_1.messages.GherkinDocument.Comment.create({
                location: this.getLocation(token),
                text: token.matchedText,
            }));
        }
        else {
            this.currentNode().add(token.matchedType, token);
        }
    };
    AstBuilder.prototype.getResult = function () {
        return this.currentNode().getSingle(Parser_1.RuleType.GherkinDocument);
    };
    AstBuilder.prototype.currentNode = function () {
        return this.stack[this.stack.length - 1];
    };
    AstBuilder.prototype.getLocation = function (token, column) {
        return !column
            ? token.location
            : createLocation_1.default({ line: token.location.line, column: column });
    };
    AstBuilder.prototype.getTags = function (node) {
        var e_1, _a, e_2, _b;
        var tags = [];
        var tagsNode = node.getSingle(Parser_1.RuleType.Tags);
        if (!tagsNode) {
            return tags;
        }
        var tokens = tagsNode.getTokens(Parser_1.TokenType.TagLine);
        try {
            for (var tokens_1 = __values(tokens), tokens_1_1 = tokens_1.next(); !tokens_1_1.done; tokens_1_1 = tokens_1.next()) {
                var token = tokens_1_1.value;
                try {
                    for (var _c = (e_2 = void 0, __values(token.matchedItems)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var tagItem = _d.value;
                        tags.push(cucumber_messages_1.messages.GherkinDocument.Feature.Tag.create({
                            location: this.getLocation(token, tagItem.column),
                            name: tagItem.text,
                            id: this.newId(),
                        }));
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (tokens_1_1 && !tokens_1_1.done && (_a = tokens_1.return)) _a.call(tokens_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return tags;
    };
    AstBuilder.prototype.getCells = function (tableRowToken) {
        var _this = this;
        return tableRowToken.matchedItems.map(function (cellItem) {
            return cucumber_messages_1.messages.GherkinDocument.Feature.TableRow.TableCell.create({
                location: _this.getLocation(tableRowToken, cellItem.column),
                value: cellItem.text,
            });
        });
    };
    AstBuilder.prototype.getDescription = function (node) {
        return node.getSingle(Parser_1.RuleType.Description);
    };
    AstBuilder.prototype.getSteps = function (node) {
        return node.getItems(Parser_1.RuleType.Step);
    };
    AstBuilder.prototype.getTableRows = function (node) {
        var _this = this;
        var rows = node.getTokens(Parser_1.TokenType.TableRow).map(function (token) {
            return cucumber_messages_1.messages.GherkinDocument.Feature.TableRow.create({
                id: _this.newId(),
                location: _this.getLocation(token),
                cells: _this.getCells(token),
            });
        });
        this.ensureCellCount(rows);
        return rows;
    };
    AstBuilder.prototype.ensureCellCount = function (rows) {
        if (rows.length === 0) {
            return;
        }
        var cellCount = rows[0].cells.length;
        rows.forEach(function (row) {
            if (row.cells.length !== cellCount) {
                throw Errors_1.AstBuilderException.create('inconsistent cell count within the table', row.location);
            }
        });
    };
    AstBuilder.prototype.transformNode = function (node) {
        var e_3, _a, e_4, _b, e_5, _c;
        switch (node.ruleType) {
            case Parser_1.RuleType.Step: {
                var stepLine = node.getToken(Parser_1.TokenType.StepLine);
                var dataTable = node.getSingle(Parser_1.RuleType.DataTable);
                var docString = node.getSingle(Parser_1.RuleType.DocString);
                return cucumber_messages_1.messages.GherkinDocument.Feature.Step.create({
                    id: this.newId(),
                    location: this.getLocation(stepLine),
                    keyword: stepLine.matchedKeyword,
                    text: stepLine.matchedText,
                    dataTable: dataTable,
                    docString: docString,
                });
            }
            case Parser_1.RuleType.DocString: {
                var separatorToken = node.getTokens(Parser_1.TokenType.DocStringSeparator)[0];
                var contentType = separatorToken.matchedText.length > 0
                    ? separatorToken.matchedText
                    : undefined;
                var lineTokens = node.getTokens(Parser_1.TokenType.Other);
                var content = lineTokens.map(function (t) { return t.matchedText; }).join('\n');
                var result = cucumber_messages_1.messages.GherkinDocument.Feature.Step.DocString.create({
                    location: this.getLocation(separatorToken),
                    content: content,
                    delimiter: separatorToken.line.trimmedLineText.substring(0, 3),
                });
                // conditionally add this like this (needed to make tests pass on node 0.10 as well as 4.0)
                if (contentType) {
                    result.contentType = contentType;
                }
                return result;
            }
            case Parser_1.RuleType.DataTable: {
                var rows = this.getTableRows(node);
                return cucumber_messages_1.messages.GherkinDocument.Feature.Step.DataTable.create({
                    location: rows[0].location,
                    rows: rows,
                });
            }
            case Parser_1.RuleType.Background: {
                var backgroundLine = node.getToken(Parser_1.TokenType.BackgroundLine);
                var description = this.getDescription(node);
                var steps = this.getSteps(node);
                return cucumber_messages_1.messages.GherkinDocument.Feature.Background.create({
                    location: this.getLocation(backgroundLine),
                    keyword: backgroundLine.matchedKeyword,
                    name: backgroundLine.matchedText,
                    description: description,
                    steps: steps,
                });
            }
            case Parser_1.RuleType.ScenarioDefinition: {
                var tags = this.getTags(node);
                var scenarioNode = node.getSingle(Parser_1.RuleType.Scenario);
                var scenarioLine = scenarioNode.getToken(Parser_1.TokenType.ScenarioLine);
                var description = this.getDescription(scenarioNode);
                var steps = this.getSteps(scenarioNode);
                var examples = scenarioNode.getItems(Parser_1.RuleType.ExamplesDefinition);
                return cucumber_messages_1.messages.GherkinDocument.Feature.Scenario.create({
                    id: this.newId(),
                    tags: tags,
                    location: this.getLocation(scenarioLine),
                    keyword: scenarioLine.matchedKeyword,
                    name: scenarioLine.matchedText,
                    description: description,
                    steps: steps,
                    examples: examples,
                });
            }
            case Parser_1.RuleType.ExamplesDefinition: {
                var tags = this.getTags(node);
                var examplesNode = node.getSingle(Parser_1.RuleType.Examples);
                var examplesLine = examplesNode.getToken(Parser_1.TokenType.ExamplesLine);
                var description = this.getDescription(examplesNode);
                var exampleTable = examplesNode.getSingle(Parser_1.RuleType.ExamplesTable);
                return cucumber_messages_1.messages.GherkinDocument.Feature.Scenario.Examples.create({
                    tags: tags,
                    location: this.getLocation(examplesLine),
                    keyword: examplesLine.matchedKeyword,
                    name: examplesLine.matchedText,
                    description: description,
                    tableHeader: exampleTable !== undefined ? exampleTable[0] : undefined,
                    tableBody: exampleTable !== undefined ? exampleTable.slice(1) : undefined,
                });
            }
            case Parser_1.RuleType.ExamplesTable: {
                return this.getTableRows(node);
            }
            case Parser_1.RuleType.Description: {
                var lineTokens = node.getTokens(Parser_1.TokenType.Other);
                // Trim trailing empty lines
                var end = lineTokens.length;
                while (end > 0 && lineTokens[end - 1].line.trimmedLineText === '') {
                    end--;
                }
                lineTokens = lineTokens.slice(0, end);
                return lineTokens.map(function (token) { return token.matchedText; }).join('\n');
            }
            case Parser_1.RuleType.Feature: {
                var header = node.getSingle(Parser_1.RuleType.FeatureHeader);
                if (!header) {
                    return null;
                }
                var tags = this.getTags(header);
                var featureLine = header.getToken(Parser_1.TokenType.FeatureLine);
                if (!featureLine) {
                    return null;
                }
                var children = [];
                var background = node.getSingle(Parser_1.RuleType.Background);
                if (background) {
                    children.push(cucumber_messages_1.messages.GherkinDocument.Feature.FeatureChild.create({
                        background: background,
                    }));
                }
                try {
                    for (var _d = __values(node.getItems(Parser_1.RuleType.ScenarioDefinition)), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var scenario = _e.value;
                        children.push(cucumber_messages_1.messages.GherkinDocument.Feature.FeatureChild.create({
                            scenario: scenario,
                        }));
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                try {
                    for (var _f = __values(node.getItems(Parser_1.RuleType.Rule)), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var rule = _g.value;
                        children.push(cucumber_messages_1.messages.GherkinDocument.Feature.FeatureChild.create({
                            rule: rule,
                        }));
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
                var description = this.getDescription(header);
                var language = featureLine.matchedGherkinDialect;
                return cucumber_messages_1.messages.GherkinDocument.Feature.create({
                    tags: tags,
                    location: this.getLocation(featureLine),
                    language: language,
                    keyword: featureLine.matchedKeyword,
                    name: featureLine.matchedText,
                    description: description,
                    children: children,
                });
            }
            case Parser_1.RuleType.Rule: {
                var header = node.getSingle(Parser_1.RuleType.RuleHeader);
                if (!header) {
                    return null;
                }
                var ruleLine = header.getToken(Parser_1.TokenType.RuleLine);
                if (!ruleLine) {
                    return null;
                }
                var children = [];
                var background = node.getSingle(Parser_1.RuleType.Background);
                if (background) {
                    children.push(cucumber_messages_1.messages.GherkinDocument.Feature.FeatureChild.create({
                        background: background,
                    }));
                }
                try {
                    for (var _h = __values(node.getItems(Parser_1.RuleType.ScenarioDefinition)), _j = _h.next(); !_j.done; _j = _h.next()) {
                        var scenario = _j.value;
                        children.push(cucumber_messages_1.messages.GherkinDocument.Feature.FeatureChild.create({
                            scenario: scenario,
                        }));
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                var description = this.getDescription(header);
                return cucumber_messages_1.messages.GherkinDocument.Feature.FeatureChild.Rule.create({
                    location: this.getLocation(ruleLine),
                    keyword: ruleLine.matchedKeyword,
                    name: ruleLine.matchedText,
                    description: description,
                    children: children,
                });
            }
            case Parser_1.RuleType.GherkinDocument: {
                var feature = node.getSingle(Parser_1.RuleType.Feature);
                return cucumber_messages_1.messages.GherkinDocument.create({
                    feature: feature,
                    comments: this.comments,
                });
            }
            default:
                return node;
        }
    };
    return AstBuilder;
}());
exports.default = AstBuilder;
//# sourceMappingURL=AstBuilder.js.map

/***/ }),

/***/ 6901:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var AstNode = /** @class */ (function () {
    function AstNode(ruleType) {
        this.ruleType = ruleType;
        this.subItems = new Map();
    }
    AstNode.prototype.add = function (type, obj) {
        var items = this.subItems.get(type);
        if (items === undefined) {
            items = [];
            this.subItems.set(type, items);
        }
        items.push(obj);
    };
    AstNode.prototype.getSingle = function (ruleType) {
        return (this.subItems.get(ruleType) || [])[0];
    };
    AstNode.prototype.getItems = function (ruleType) {
        return this.subItems.get(ruleType) || [];
    };
    AstNode.prototype.getToken = function (tokenType) {
        return (this.subItems.get(tokenType) || [])[0];
    };
    AstNode.prototype.getTokens = function (tokenType) {
        return this.subItems.get(tokenType) || [];
    };
    return AstNode;
}());
exports.default = AstNode;
//# sourceMappingURL=AstNode.js.map

/***/ }),

/***/ 9259:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var createLocation_1 = __importDefault(__webpack_require__(7134));
var GherkinException = /** @class */ (function (_super) {
    __extends(GherkinException, _super);
    function GherkinException(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        var actualProto = _newTarget.prototype;
        // https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(_this, actualProto);
        }
        else {
            // @ts-ignore
            _this.__proto__ = actualProto;
        }
        return _this;
    }
    GherkinException._create = function (location, message) {
        var column = location.column || 0;
        var m = "(" + location.line + ":" + column + "): " + message;
        var err = new this(m);
        err.location = location;
        return err;
    };
    return GherkinException;
}(Error));
var ParserException = /** @class */ (function (_super) {
    __extends(ParserException, _super);
    function ParserException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ParserException;
}(GherkinException));
exports.ParserException = ParserException;
var CompositeParserException = /** @class */ (function (_super) {
    __extends(CompositeParserException, _super);
    function CompositeParserException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CompositeParserException.create = function (errors) {
        var message = 'Parser errors:\n' + errors.map(function (e) { return e.message; }).join('\n');
        var err = new this(message);
        err.errors = errors;
        return err;
    };
    return CompositeParserException;
}(GherkinException));
exports.CompositeParserException = CompositeParserException;
var UnexpectedTokenException = /** @class */ (function (_super) {
    __extends(UnexpectedTokenException, _super);
    function UnexpectedTokenException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UnexpectedTokenException.create = function (token, expectedTokenTypes, stateComment) {
        var message = "expected: " + expectedTokenTypes.join(', ') + ", got '" + token.getTokenValue().trim() + "'";
        var location = tokenLocation(token);
        return this._create(location, message);
    };
    return UnexpectedTokenException;
}(GherkinException));
exports.UnexpectedTokenException = UnexpectedTokenException;
var UnexpectedEOFException = /** @class */ (function (_super) {
    __extends(UnexpectedEOFException, _super);
    function UnexpectedEOFException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UnexpectedEOFException.create = function (token, expectedTokenTypes, stateComment) {
        var message = "unexpected end of file, expected: " + expectedTokenTypes.join(', ');
        var location = tokenLocation(token);
        return this._create(location, message);
    };
    return UnexpectedEOFException;
}(GherkinException));
exports.UnexpectedEOFException = UnexpectedEOFException;
var AstBuilderException = /** @class */ (function (_super) {
    __extends(AstBuilderException, _super);
    function AstBuilderException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AstBuilderException.create = function (message, location) {
        return this._create(location, message);
    };
    return AstBuilderException;
}(GherkinException));
exports.AstBuilderException = AstBuilderException;
var NoSuchLanguageException = /** @class */ (function (_super) {
    __extends(NoSuchLanguageException, _super);
    function NoSuchLanguageException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoSuchLanguageException.create = function (language, location) {
        var message = 'Language not supported: ' + language;
        return this._create(location, message);
    };
    return NoSuchLanguageException;
}(GherkinException));
exports.NoSuchLanguageException = NoSuchLanguageException;
function tokenLocation(token) {
    return token.location &&
        token.location.line &&
        token.line &&
        token.line.indent !== undefined
        ? createLocation_1.default({
            line: token.location.line,
            column: token.line.indent + 1,
        })
        : token.location;
}
//# sourceMappingURL=Errors.js.map

/***/ }),

/***/ 8215:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var stream_1 = __webpack_require__(2413);
var cucumber_messages_1 = __webpack_require__(6106);
var ParserMessageStream_1 = __importDefault(__webpack_require__(2369));
var GherkinExe_1 = __importDefault(__webpack_require__(3495));
var fs_1 = __importDefault(__webpack_require__(5747));
var SourceMessageStream_1 = __importDefault(__webpack_require__(1682));
var gherkin_languages_json_1 = __importDefault(__webpack_require__(1608));
var makeGherkinOptions_1 = __importDefault(__webpack_require__(761));
function fromStream(stream, options) {
    if (options === void 0) { options = {}; }
    return stream_1.pipeline(stream, new cucumber_messages_1.BinaryToMessageStream(cucumber_messages_1.messages.Envelope.decodeDelimited), new ParserMessageStream_1.default(options));
}
function fromPaths(paths, options) {
    if (options === void 0) { options = {}; }
    options = makeGherkinOptions_1.default(options);
    if (process.env.GHERKIN_EXECUTABLE) {
        return new GherkinExe_1.default(process.env.GHERKIN_EXECUTABLE, paths, [], options).messageStream();
    }
    var combinedMessageStream = new stream_1.PassThrough({
        writableObjectMode: true,
        readableObjectMode: true,
    });
    function pipeSequentially() {
        var path = paths.shift();
        if (path !== undefined) {
            var parserMessageStream = new ParserMessageStream_1.default(options);
            parserMessageStream.on('end', function () {
                pipeSequentially();
            });
            var end = paths.length === 0;
            fs_1.default.createReadStream(path, { encoding: 'utf-8' })
                .pipe(new SourceMessageStream_1.default(path))
                .pipe(parserMessageStream)
                .pipe(combinedMessageStream, { end: end });
        }
    }
    pipeSequentially();
    return combinedMessageStream;
}
function fromSources(envelopes, options) {
    if (options === void 0) { options = {}; }
    options = makeGherkinOptions_1.default(options);
    if (process.env.GHERKIN_EXECUTABLE) {
        return new GherkinExe_1.default(process.env.GHERKIN_EXECUTABLE, [], envelopes, options).messageStream();
    }
    var combinedMessageStream = new stream_1.PassThrough({ objectMode: true });
    function pipeSequentially() {
        var envelope = envelopes.shift();
        if (envelope !== undefined && envelope.source) {
            var parserMessageStream = new ParserMessageStream_1.default(options);
            parserMessageStream.pipe(combinedMessageStream, {
                end: envelopes.length === 0,
            });
            parserMessageStream.on('end', pipeSequentially);
            parserMessageStream.end(envelope);
        }
    }
    pipeSequentially();
    return combinedMessageStream;
}
function dialects() {
    return gherkin_languages_json_1.default;
}
exports.default = {
    fromPaths: fromPaths,
    fromStream: fromStream,
    fromSources: fromSources,
    dialects: dialects,
};
//# sourceMappingURL=Gherkin.js.map

/***/ }),

/***/ 3715:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var countSymbols_1 = __importDefault(__webpack_require__(8462));
var GherkinLine = /** @class */ (function () {
    function GherkinLine(lineText, lineNumber) {
        this.lineText = lineText;
        this.lineNumber = lineNumber;
        this.trimmedLineText = lineText.replace(/^\s+/g, ''); // ltrim
        this.isEmpty = this.trimmedLineText.length === 0;
        this.indent = countSymbols_1.default(lineText) - countSymbols_1.default(this.trimmedLineText);
    }
    GherkinLine.prototype.startsWith = function (prefix) {
        return this.trimmedLineText.indexOf(prefix) === 0;
    };
    GherkinLine.prototype.startsWithTitleKeyword = function (keyword) {
        return this.startsWith(keyword + ':'); // The C# impl is more complicated. Find out why.
    };
    GherkinLine.prototype.getLineText = function (indentToRemove) {
        if (indentToRemove < 0 || indentToRemove > this.indent) {
            return this.trimmedLineText;
        }
        else {
            return this.lineText.substring(indentToRemove);
        }
    };
    GherkinLine.prototype.getRestTrimmed = function (length) {
        return this.trimmedLineText.substring(length).trim();
    };
    GherkinLine.prototype.getTableCells = function () {
        var cells = [];
        var col = 0;
        var startCol = col + 1;
        var cell = '';
        var firstCell = true;
        while (col < this.trimmedLineText.length) {
            var chr = this.trimmedLineText[col];
            col++;
            if (chr === '|') {
                if (firstCell) {
                    // First cell (content before the first |) is skipped
                    firstCell = false;
                }
                else {
                    var cellIndent = cell.length - cell.replace(/^\s+/g, '').length;
                    var span = {
                        column: this.indent + startCol + cellIndent,
                        text: cell.trim(),
                    };
                    cells.push(span);
                }
                cell = '';
                startCol = col + 1;
            }
            else if (chr === '\\') {
                chr = this.trimmedLineText[col];
                col += 1;
                if (chr === 'n') {
                    cell += '\n';
                }
                else {
                    if (chr !== '|' && chr !== '\\') {
                        cell += '\\';
                    }
                    cell += chr;
                }
            }
            else {
                cell += chr;
            }
        }
        return cells;
    };
    GherkinLine.prototype.getTags = function () {
        var column = this.indent + 1;
        var items = this.trimmedLineText.trim().split('@');
        items.shift();
        return items.map(function (item) {
            var length = item.length;
            var span = { column: column, text: '@' + item.trim() };
            column += length + 1;
            return span;
        });
    };
    return GherkinLine;
}());
exports.default = GherkinLine;
module.exports = GherkinLine;
//# sourceMappingURL=GherkinLine.js.map

/***/ }),

/***/ 3332:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// This file is generated. Do not edit! Edit gherkin-javascript.razor instead.
var Errors_1 = __webpack_require__(9259);
var TokenScanner_1 = __importDefault(__webpack_require__(976));
var TokenMatcher_1 = __importDefault(__webpack_require__(2402));
var TokenType;
(function (TokenType) {
    TokenType[TokenType["None"] = 0] = "None";
    TokenType[TokenType["EOF"] = 1] = "EOF";
    TokenType[TokenType["Empty"] = 2] = "Empty";
    TokenType[TokenType["Comment"] = 3] = "Comment";
    TokenType[TokenType["TagLine"] = 4] = "TagLine";
    TokenType[TokenType["FeatureLine"] = 5] = "FeatureLine";
    TokenType[TokenType["RuleLine"] = 6] = "RuleLine";
    TokenType[TokenType["BackgroundLine"] = 7] = "BackgroundLine";
    TokenType[TokenType["ScenarioLine"] = 8] = "ScenarioLine";
    TokenType[TokenType["ExamplesLine"] = 9] = "ExamplesLine";
    TokenType[TokenType["StepLine"] = 10] = "StepLine";
    TokenType[TokenType["DocStringSeparator"] = 11] = "DocStringSeparator";
    TokenType[TokenType["TableRow"] = 12] = "TableRow";
    TokenType[TokenType["Language"] = 13] = "Language";
    TokenType[TokenType["Other"] = 14] = "Other";
})(TokenType = exports.TokenType || (exports.TokenType = {}));
var RuleType;
(function (RuleType) {
    RuleType[RuleType["None"] = 0] = "None";
    RuleType[RuleType["_EOF"] = 1] = "_EOF";
    RuleType[RuleType["_Empty"] = 2] = "_Empty";
    RuleType[RuleType["_Comment"] = 3] = "_Comment";
    RuleType[RuleType["_TagLine"] = 4] = "_TagLine";
    RuleType[RuleType["_FeatureLine"] = 5] = "_FeatureLine";
    RuleType[RuleType["_RuleLine"] = 6] = "_RuleLine";
    RuleType[RuleType["_BackgroundLine"] = 7] = "_BackgroundLine";
    RuleType[RuleType["_ScenarioLine"] = 8] = "_ScenarioLine";
    RuleType[RuleType["_ExamplesLine"] = 9] = "_ExamplesLine";
    RuleType[RuleType["_StepLine"] = 10] = "_StepLine";
    RuleType[RuleType["_DocStringSeparator"] = 11] = "_DocStringSeparator";
    RuleType[RuleType["_TableRow"] = 12] = "_TableRow";
    RuleType[RuleType["_Language"] = 13] = "_Language";
    RuleType[RuleType["_Other"] = 14] = "_Other";
    RuleType[RuleType["GherkinDocument"] = 15] = "GherkinDocument";
    RuleType[RuleType["Feature"] = 16] = "Feature";
    RuleType[RuleType["FeatureHeader"] = 17] = "FeatureHeader";
    RuleType[RuleType["Rule"] = 18] = "Rule";
    RuleType[RuleType["RuleHeader"] = 19] = "RuleHeader";
    RuleType[RuleType["Background"] = 20] = "Background";
    RuleType[RuleType["ScenarioDefinition"] = 21] = "ScenarioDefinition";
    RuleType[RuleType["Scenario"] = 22] = "Scenario";
    RuleType[RuleType["ExamplesDefinition"] = 23] = "ExamplesDefinition";
    RuleType[RuleType["Examples"] = 24] = "Examples";
    RuleType[RuleType["ExamplesTable"] = 25] = "ExamplesTable";
    RuleType[RuleType["Step"] = 26] = "Step";
    RuleType[RuleType["StepArg"] = 27] = "StepArg";
    RuleType[RuleType["DataTable"] = 28] = "DataTable";
    RuleType[RuleType["DocString"] = 29] = "DocString";
    RuleType[RuleType["Tags"] = 30] = "Tags";
    RuleType[RuleType["DescriptionHelper"] = 31] = "DescriptionHelper";
    RuleType[RuleType["Description"] = 32] = "Description";
})(RuleType = exports.RuleType || (exports.RuleType = {}));
var Parser = /** @class */ (function () {
    function Parser(builder) {
        this.builder = builder;
        this.stopAtFirstError = false;
    }
    Parser.prototype.parse = function (tokenScanner, tokenMatcher) {
        if (tokenMatcher === void 0) { tokenMatcher = new TokenMatcher_1.default(); }
        if (typeof tokenScanner === 'string') {
            tokenScanner = new TokenScanner_1.default(tokenScanner);
        }
        this.builder.reset();
        tokenMatcher.reset();
        this.context = {
            tokenScanner: tokenScanner,
            tokenMatcher: tokenMatcher,
            tokenQueue: [],
            errors: [],
        };
        this.startRule(this.context, RuleType.GherkinDocument);
        var state = 0;
        var token = null;
        while (true) {
            token = this.readToken(this.context);
            state = this.matchToken(state, token, this.context);
            if (token.isEof) {
                break;
            }
        }
        this.endRule(this.context, RuleType.GherkinDocument);
        if (this.context.errors.length > 0) {
            throw Errors_1.CompositeParserException.create(this.context.errors);
        }
        return this.getResult();
    };
    Parser.prototype.addError = function (context, error) {
        context.errors.push(error);
        if (context.errors.length > 10) {
            throw Errors_1.CompositeParserException.create(context.errors);
        }
    };
    Parser.prototype.startRule = function (context, ruleType) {
        var _this = this;
        this.handleAstError(context, function () { return _this.builder.startRule(ruleType); });
    };
    Parser.prototype.endRule = function (context, ruleType) {
        var _this = this;
        this.handleAstError(context, function () { return _this.builder.endRule(ruleType); });
    };
    Parser.prototype.build = function (context, token) {
        var _this = this;
        this.handleAstError(context, function () { return _this.builder.build(token); });
    };
    Parser.prototype.getResult = function () {
        return this.builder.getResult();
    };
    Parser.prototype.handleAstError = function (context, action) {
        this.handleExternalError(context, true, action);
    };
    Parser.prototype.handleExternalError = function (context, defaultValue, action) {
        var _this = this;
        if (this.stopAtFirstError) {
            return action();
        }
        try {
            return action();
        }
        catch (e) {
            if (e instanceof Errors_1.CompositeParserException) {
                e.errors.forEach(function (error) { return _this.addError(context, error); });
            }
            else if (e instanceof Errors_1.ParserException ||
                e instanceof Errors_1.AstBuilderException ||
                e instanceof Errors_1.UnexpectedTokenException ||
                e instanceof Errors_1.NoSuchLanguageException) {
                this.addError(context, e);
            }
            else {
                throw e;
            }
        }
        return defaultValue;
    };
    Parser.prototype.readToken = function (context) {
        return context.tokenQueue.length > 0
            ? context.tokenQueue.shift()
            : context.tokenScanner.read();
    };
    Parser.prototype.matchToken = function (state, token, context) {
        switch (state) {
            case 0:
                return this.matchTokenAt_0(token, context);
            case 1:
                return this.matchTokenAt_1(token, context);
            case 2:
                return this.matchTokenAt_2(token, context);
            case 3:
                return this.matchTokenAt_3(token, context);
            case 4:
                return this.matchTokenAt_4(token, context);
            case 5:
                return this.matchTokenAt_5(token, context);
            case 6:
                return this.matchTokenAt_6(token, context);
            case 7:
                return this.matchTokenAt_7(token, context);
            case 8:
                return this.matchTokenAt_8(token, context);
            case 9:
                return this.matchTokenAt_9(token, context);
            case 10:
                return this.matchTokenAt_10(token, context);
            case 11:
                return this.matchTokenAt_11(token, context);
            case 12:
                return this.matchTokenAt_12(token, context);
            case 13:
                return this.matchTokenAt_13(token, context);
            case 14:
                return this.matchTokenAt_14(token, context);
            case 15:
                return this.matchTokenAt_15(token, context);
            case 16:
                return this.matchTokenAt_16(token, context);
            case 17:
                return this.matchTokenAt_17(token, context);
            case 18:
                return this.matchTokenAt_18(token, context);
            case 19:
                return this.matchTokenAt_19(token, context);
            case 20:
                return this.matchTokenAt_20(token, context);
            case 21:
                return this.matchTokenAt_21(token, context);
            case 22:
                return this.matchTokenAt_22(token, context);
            case 23:
                return this.matchTokenAt_23(token, context);
            case 24:
                return this.matchTokenAt_24(token, context);
            case 25:
                return this.matchTokenAt_25(token, context);
            case 26:
                return this.matchTokenAt_26(token, context);
            case 27:
                return this.matchTokenAt_27(token, context);
            case 28:
                return this.matchTokenAt_28(token, context);
            case 29:
                return this.matchTokenAt_29(token, context);
            case 30:
                return this.matchTokenAt_30(token, context);
            case 31:
                return this.matchTokenAt_31(token, context);
            case 32:
                return this.matchTokenAt_32(token, context);
            case 33:
                return this.matchTokenAt_33(token, context);
            case 34:
                return this.matchTokenAt_34(token, context);
            case 35:
                return this.matchTokenAt_35(token, context);
            case 36:
                return this.matchTokenAt_36(token, context);
            case 37:
                return this.matchTokenAt_37(token, context);
            case 38:
                return this.matchTokenAt_38(token, context);
            case 39:
                return this.matchTokenAt_39(token, context);
            case 40:
                return this.matchTokenAt_40(token, context);
            case 42:
                return this.matchTokenAt_42(token, context);
            case 43:
                return this.matchTokenAt_43(token, context);
            case 44:
                return this.matchTokenAt_44(token, context);
            case 45:
                return this.matchTokenAt_45(token, context);
            case 46:
                return this.matchTokenAt_46(token, context);
            case 47:
                return this.matchTokenAt_47(token, context);
            case 48:
                return this.matchTokenAt_48(token, context);
            case 49:
                return this.matchTokenAt_49(token, context);
            default:
                throw new Error('Unknown state: ' + state);
        }
    };
    // Start
    Parser.prototype.matchTokenAt_0 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.build(context, token);
            return 41;
        }
        if (this.match_Language(context, token)) {
            this.startRule(context, RuleType.Feature);
            this.startRule(context, RuleType.FeatureHeader);
            this.build(context, token);
            return 1;
        }
        if (this.match_TagLine(context, token)) {
            this.startRule(context, RuleType.Feature);
            this.startRule(context, RuleType.FeatureHeader);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 2;
        }
        if (this.match_FeatureLine(context, token)) {
            this.startRule(context, RuleType.Feature);
            this.startRule(context, RuleType.FeatureHeader);
            this.build(context, token);
            return 3;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 0;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 0;
        }
        var stateComment = 'State: 0 - Start';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Language',
            '#TagLine',
            '#FeatureLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 0;
    };
    // GherkinDocument:0>Feature:0>FeatureHeader:0>#Language:0
    Parser.prototype.matchTokenAt_1 = function (token, context) {
        if (this.match_TagLine(context, token)) {
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 2;
        }
        if (this.match_FeatureLine(context, token)) {
            this.build(context, token);
            return 3;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 1;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 1;
        }
        var stateComment = 'State: 1 - GherkinDocument:0>Feature:0>FeatureHeader:0>#Language:0';
        token.detach();
        var expectedTokens = ['#TagLine', '#FeatureLine', '#Comment', '#Empty'];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 1;
    };
    // GherkinDocument:0>Feature:0>FeatureHeader:1>Tags:0>#TagLine:0
    Parser.prototype.matchTokenAt_2 = function (token, context) {
        if (this.match_TagLine(context, token)) {
            this.build(context, token);
            return 2;
        }
        if (this.match_FeatureLine(context, token)) {
            this.endRule(context, RuleType.Tags);
            this.build(context, token);
            return 3;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 2;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 2;
        }
        var stateComment = 'State: 2 - GherkinDocument:0>Feature:0>FeatureHeader:1>Tags:0>#TagLine:0';
        token.detach();
        var expectedTokens = ['#TagLine', '#FeatureLine', '#Comment', '#Empty'];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 2;
    };
    // GherkinDocument:0>Feature:0>FeatureHeader:2>#FeatureLine:0
    Parser.prototype.matchTokenAt_3 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.FeatureHeader);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 3;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 5;
        }
        if (this.match_BackgroundLine(context, token)) {
            this.endRule(context, RuleType.FeatureHeader);
            this.startRule(context, RuleType.Background);
            this.build(context, token);
            return 6;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.FeatureHeader);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.FeatureHeader);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.FeatureHeader);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.startRule(context, RuleType.Description);
            this.build(context, token);
            return 4;
        }
        var stateComment = 'State: 3 - GherkinDocument:0>Feature:0>FeatureHeader:2>#FeatureLine:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Empty',
            '#Comment',
            '#BackgroundLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 3;
    };
    // GherkinDocument:0>Feature:0>FeatureHeader:3>DescriptionHelper:1>Description:0>#Other:0
    Parser.prototype.matchTokenAt_4 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.FeatureHeader);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.endRule(context, RuleType.Description);
            this.build(context, token);
            return 5;
        }
        if (this.match_BackgroundLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.FeatureHeader);
            this.startRule(context, RuleType.Background);
            this.build(context, token);
            return 6;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.FeatureHeader);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.FeatureHeader);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.FeatureHeader);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.build(context, token);
            return 4;
        }
        var stateComment = 'State: 4 - GherkinDocument:0>Feature:0>FeatureHeader:3>DescriptionHelper:1>Description:0>#Other:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#BackgroundLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 4;
    };
    // GherkinDocument:0>Feature:0>FeatureHeader:3>DescriptionHelper:2>#Comment:0
    Parser.prototype.matchTokenAt_5 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.FeatureHeader);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 5;
        }
        if (this.match_BackgroundLine(context, token)) {
            this.endRule(context, RuleType.FeatureHeader);
            this.startRule(context, RuleType.Background);
            this.build(context, token);
            return 6;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.FeatureHeader);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.FeatureHeader);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.FeatureHeader);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 5;
        }
        var stateComment = 'State: 5 - GherkinDocument:0>Feature:0>FeatureHeader:3>DescriptionHelper:2>#Comment:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#BackgroundLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 5;
    };
    // GherkinDocument:0>Feature:1>Background:0>#BackgroundLine:0
    Parser.prototype.matchTokenAt_6 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 6;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 8;
        }
        if (this.match_StepLine(context, token)) {
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 9;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.startRule(context, RuleType.Description);
            this.build(context, token);
            return 7;
        }
        var stateComment = 'State: 6 - GherkinDocument:0>Feature:1>Background:0>#BackgroundLine:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Empty',
            '#Comment',
            '#StepLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 6;
    };
    // GherkinDocument:0>Feature:1>Background:1>DescriptionHelper:1>Description:0>#Other:0
    Parser.prototype.matchTokenAt_7 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.endRule(context, RuleType.Description);
            this.build(context, token);
            return 8;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 9;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.build(context, token);
            return 7;
        }
        var stateComment = 'State: 7 - GherkinDocument:0>Feature:1>Background:1>DescriptionHelper:1>Description:0>#Other:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#StepLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 7;
    };
    // GherkinDocument:0>Feature:1>Background:1>DescriptionHelper:2>#Comment:0
    Parser.prototype.matchTokenAt_8 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 8;
        }
        if (this.match_StepLine(context, token)) {
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 9;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 8;
        }
        var stateComment = 'State: 8 - GherkinDocument:0>Feature:1>Background:1>DescriptionHelper:2>#Comment:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#StepLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 8;
    };
    // GherkinDocument:0>Feature:1>Background:2>Step:0>#StepLine:0
    Parser.prototype.matchTokenAt_9 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_TableRow(context, token)) {
            this.startRule(context, RuleType.DataTable);
            this.build(context, token);
            return 10;
        }
        if (this.match_DocStringSeparator(context, token)) {
            this.startRule(context, RuleType.DocString);
            this.build(context, token);
            return 48;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 9;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 9;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 9;
        }
        var stateComment = 'State: 9 - GherkinDocument:0>Feature:1>Background:2>Step:0>#StepLine:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#TableRow',
            '#DocStringSeparator',
            '#StepLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 9;
    };
    // GherkinDocument:0>Feature:1>Background:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0
    Parser.prototype.matchTokenAt_10 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_TableRow(context, token)) {
            this.build(context, token);
            return 10;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 9;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 10;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 10;
        }
        var stateComment = 'State: 10 - GherkinDocument:0>Feature:1>Background:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#TableRow',
            '#StepLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 10;
    };
    // GherkinDocument:0>Feature:2>ScenarioDefinition:0>Tags:0>#TagLine:0
    Parser.prototype.matchTokenAt_11 = function (token, context) {
        if (this.match_TagLine(context, token)) {
            this.build(context, token);
            return 11;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Tags);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 11;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 11;
        }
        var stateComment = 'State: 11 - GherkinDocument:0>Feature:2>ScenarioDefinition:0>Tags:0>#TagLine:0';
        token.detach();
        var expectedTokens = ['#TagLine', '#ScenarioLine', '#Comment', '#Empty'];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 11;
    };
    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:0>#ScenarioLine:0
    Parser.prototype.matchTokenAt_12 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 12;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 14;
        }
        if (this.match_StepLine(context, token)) {
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 15;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 17;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.startRule(context, RuleType.Description);
            this.build(context, token);
            return 13;
        }
        var stateComment = 'State: 12 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:0>#ScenarioLine:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Empty',
            '#Comment',
            '#StepLine',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 12;
    };
    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:1>Description:0>#Other:0
    Parser.prototype.matchTokenAt_13 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.endRule(context, RuleType.Description);
            this.build(context, token);
            return 14;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 15;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.Description);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 17;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.build(context, token);
            return 13;
        }
        var stateComment = 'State: 13 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:1>Description:0>#Other:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#StepLine',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 13;
    };
    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:2>#Comment:0
    Parser.prototype.matchTokenAt_14 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 14;
        }
        if (this.match_StepLine(context, token)) {
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 15;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 17;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 14;
        }
        var stateComment = 'State: 14 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:2>#Comment:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#StepLine',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 14;
    };
    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:0>#StepLine:0
    Parser.prototype.matchTokenAt_15 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_TableRow(context, token)) {
            this.startRule(context, RuleType.DataTable);
            this.build(context, token);
            return 16;
        }
        if (this.match_DocStringSeparator(context, token)) {
            this.startRule(context, RuleType.DocString);
            this.build(context, token);
            return 46;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 15;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.Step);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 17;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 15;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 15;
        }
        var stateComment = 'State: 15 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:0>#StepLine:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#TableRow',
            '#DocStringSeparator',
            '#StepLine',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 15;
    };
    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0
    Parser.prototype.matchTokenAt_16 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_TableRow(context, token)) {
            this.build(context, token);
            return 16;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 15;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.DataTable);
                this.endRule(context, RuleType.Step);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 17;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 16;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 16;
        }
        var stateComment = 'State: 16 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#TableRow',
            '#StepLine',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 16;
    };
    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:0>Tags:0>#TagLine:0
    Parser.prototype.matchTokenAt_17 = function (token, context) {
        if (this.match_TagLine(context, token)) {
            this.build(context, token);
            return 17;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.Tags);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 18;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 17;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 17;
        }
        var stateComment = 'State: 17 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:0>Tags:0>#TagLine:0';
        token.detach();
        var expectedTokens = ['#TagLine', '#ExamplesLine', '#Comment', '#Empty'];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 17;
    };
    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:0>#ExamplesLine:0
    Parser.prototype.matchTokenAt_18 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 18;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 20;
        }
        if (this.match_TableRow(context, token)) {
            this.startRule(context, RuleType.ExamplesTable);
            this.build(context, token);
            return 21;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.Examples);
                this.endRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 17;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.startRule(context, RuleType.Description);
            this.build(context, token);
            return 19;
        }
        var stateComment = 'State: 18 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:0>#ExamplesLine:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Empty',
            '#Comment',
            '#TableRow',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 18;
    };
    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:1>Description:0>#Other:0
    Parser.prototype.matchTokenAt_19 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.endRule(context, RuleType.Description);
            this.build(context, token);
            return 20;
        }
        if (this.match_TableRow(context, token)) {
            this.endRule(context, RuleType.Description);
            this.startRule(context, RuleType.ExamplesTable);
            this.build(context, token);
            return 21;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.Description);
                this.endRule(context, RuleType.Examples);
                this.endRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 17;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.build(context, token);
            return 19;
        }
        var stateComment = 'State: 19 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:1>Description:0>#Other:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#TableRow',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 19;
    };
    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:2>#Comment:0
    Parser.prototype.matchTokenAt_20 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 20;
        }
        if (this.match_TableRow(context, token)) {
            this.startRule(context, RuleType.ExamplesTable);
            this.build(context, token);
            return 21;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.Examples);
                this.endRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 17;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 20;
        }
        var stateComment = 'State: 20 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:2>#Comment:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#TableRow',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 20;
    };
    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:2>ExamplesTable:0>#TableRow:0
    Parser.prototype.matchTokenAt_21 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.ExamplesTable);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_TableRow(context, token)) {
            this.build(context, token);
            return 21;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.ExamplesTable);
                this.endRule(context, RuleType.Examples);
                this.endRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 17;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.ExamplesTable);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.ExamplesTable);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.ExamplesTable);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.ExamplesTable);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 21;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 21;
        }
        var stateComment = 'State: 21 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:2>ExamplesTable:0>#TableRow:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#TableRow',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 21;
    };
    // GherkinDocument:0>Feature:3>Rule:0>RuleHeader:0>#RuleLine:0
    Parser.prototype.matchTokenAt_22 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.RuleHeader);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 24;
        }
        if (this.match_BackgroundLine(context, token)) {
            this.endRule(context, RuleType.RuleHeader);
            this.startRule(context, RuleType.Background);
            this.build(context, token);
            return 25;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.RuleHeader);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.RuleHeader);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.RuleHeader);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.startRule(context, RuleType.Description);
            this.build(context, token);
            return 23;
        }
        var stateComment = 'State: 22 - GherkinDocument:0>Feature:3>Rule:0>RuleHeader:0>#RuleLine:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Empty',
            '#Comment',
            '#BackgroundLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 22;
    };
    // GherkinDocument:0>Feature:3>Rule:0>RuleHeader:1>DescriptionHelper:1>Description:0>#Other:0
    Parser.prototype.matchTokenAt_23 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.RuleHeader);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.endRule(context, RuleType.Description);
            this.build(context, token);
            return 24;
        }
        if (this.match_BackgroundLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.RuleHeader);
            this.startRule(context, RuleType.Background);
            this.build(context, token);
            return 25;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.RuleHeader);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.RuleHeader);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.RuleHeader);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.build(context, token);
            return 23;
        }
        var stateComment = 'State: 23 - GherkinDocument:0>Feature:3>Rule:0>RuleHeader:1>DescriptionHelper:1>Description:0>#Other:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#BackgroundLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 23;
    };
    // GherkinDocument:0>Feature:3>Rule:0>RuleHeader:1>DescriptionHelper:2>#Comment:0
    Parser.prototype.matchTokenAt_24 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.RuleHeader);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 24;
        }
        if (this.match_BackgroundLine(context, token)) {
            this.endRule(context, RuleType.RuleHeader);
            this.startRule(context, RuleType.Background);
            this.build(context, token);
            return 25;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.RuleHeader);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.RuleHeader);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.RuleHeader);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 24;
        }
        var stateComment = 'State: 24 - GherkinDocument:0>Feature:3>Rule:0>RuleHeader:1>DescriptionHelper:2>#Comment:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#BackgroundLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 24;
    };
    // GherkinDocument:0>Feature:3>Rule:1>Background:0>#BackgroundLine:0
    Parser.prototype.matchTokenAt_25 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 25;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 27;
        }
        if (this.match_StepLine(context, token)) {
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 28;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.startRule(context, RuleType.Description);
            this.build(context, token);
            return 26;
        }
        var stateComment = 'State: 25 - GherkinDocument:0>Feature:3>Rule:1>Background:0>#BackgroundLine:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Empty',
            '#Comment',
            '#StepLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 25;
    };
    // GherkinDocument:0>Feature:3>Rule:1>Background:1>DescriptionHelper:1>Description:0>#Other:0
    Parser.prototype.matchTokenAt_26 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.endRule(context, RuleType.Description);
            this.build(context, token);
            return 27;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 28;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.build(context, token);
            return 26;
        }
        var stateComment = 'State: 26 - GherkinDocument:0>Feature:3>Rule:1>Background:1>DescriptionHelper:1>Description:0>#Other:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#StepLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 26;
    };
    // GherkinDocument:0>Feature:3>Rule:1>Background:1>DescriptionHelper:2>#Comment:0
    Parser.prototype.matchTokenAt_27 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 27;
        }
        if (this.match_StepLine(context, token)) {
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 28;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 27;
        }
        var stateComment = 'State: 27 - GherkinDocument:0>Feature:3>Rule:1>Background:1>DescriptionHelper:2>#Comment:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#StepLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 27;
    };
    // GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:0>#StepLine:0
    Parser.prototype.matchTokenAt_28 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_TableRow(context, token)) {
            this.startRule(context, RuleType.DataTable);
            this.build(context, token);
            return 29;
        }
        if (this.match_DocStringSeparator(context, token)) {
            this.startRule(context, RuleType.DocString);
            this.build(context, token);
            return 44;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 28;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 28;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 28;
        }
        var stateComment = 'State: 28 - GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:0>#StepLine:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#TableRow',
            '#DocStringSeparator',
            '#StepLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 28;
    };
    // GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0
    Parser.prototype.matchTokenAt_29 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_TableRow(context, token)) {
            this.build(context, token);
            return 29;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 28;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 29;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 29;
        }
        var stateComment = 'State: 29 - GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#TableRow',
            '#StepLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 29;
    };
    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:0>Tags:0>#TagLine:0
    Parser.prototype.matchTokenAt_30 = function (token, context) {
        if (this.match_TagLine(context, token)) {
            this.build(context, token);
            return 30;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Tags);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 30;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 30;
        }
        var stateComment = 'State: 30 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:0>Tags:0>#TagLine:0';
        token.detach();
        var expectedTokens = ['#TagLine', '#ScenarioLine', '#Comment', '#Empty'];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 30;
    };
    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:0>#ScenarioLine:0
    Parser.prototype.matchTokenAt_31 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 31;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 33;
        }
        if (this.match_StepLine(context, token)) {
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 34;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 36;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 37;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.startRule(context, RuleType.Description);
            this.build(context, token);
            return 32;
        }
        var stateComment = 'State: 31 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:0>#ScenarioLine:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Empty',
            '#Comment',
            '#StepLine',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 31;
    };
    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:1>Description:0>#Other:0
    Parser.prototype.matchTokenAt_32 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.endRule(context, RuleType.Description);
            this.build(context, token);
            return 33;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 34;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.Description);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 36;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 37;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.build(context, token);
            return 32;
        }
        var stateComment = 'State: 32 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:1>Description:0>#Other:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#StepLine',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 32;
    };
    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:2>#Comment:0
    Parser.prototype.matchTokenAt_33 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 33;
        }
        if (this.match_StepLine(context, token)) {
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 34;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 36;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 37;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 33;
        }
        var stateComment = 'State: 33 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:2>#Comment:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#StepLine',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 33;
    };
    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:0>#StepLine:0
    Parser.prototype.matchTokenAt_34 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_TableRow(context, token)) {
            this.startRule(context, RuleType.DataTable);
            this.build(context, token);
            return 35;
        }
        if (this.match_DocStringSeparator(context, token)) {
            this.startRule(context, RuleType.DocString);
            this.build(context, token);
            return 42;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 34;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.Step);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 36;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 37;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 34;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 34;
        }
        var stateComment = 'State: 34 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:0>#StepLine:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#TableRow',
            '#DocStringSeparator',
            '#StepLine',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 34;
    };
    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0
    Parser.prototype.matchTokenAt_35 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_TableRow(context, token)) {
            this.build(context, token);
            return 35;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 34;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.DataTable);
                this.endRule(context, RuleType.Step);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 36;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 37;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.DataTable);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 35;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 35;
        }
        var stateComment = 'State: 35 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#TableRow',
            '#StepLine',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 35;
    };
    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:0>Tags:0>#TagLine:0
    Parser.prototype.matchTokenAt_36 = function (token, context) {
        if (this.match_TagLine(context, token)) {
            this.build(context, token);
            return 36;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.Tags);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 37;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 36;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 36;
        }
        var stateComment = 'State: 36 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:0>Tags:0>#TagLine:0';
        token.detach();
        var expectedTokens = ['#TagLine', '#ExamplesLine', '#Comment', '#Empty'];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 36;
    };
    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:0>#ExamplesLine:0
    Parser.prototype.matchTokenAt_37 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 37;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 39;
        }
        if (this.match_TableRow(context, token)) {
            this.startRule(context, RuleType.ExamplesTable);
            this.build(context, token);
            return 40;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.Examples);
                this.endRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 36;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 37;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.startRule(context, RuleType.Description);
            this.build(context, token);
            return 38;
        }
        var stateComment = 'State: 37 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:0>#ExamplesLine:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Empty',
            '#Comment',
            '#TableRow',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 37;
    };
    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:1>Description:0>#Other:0
    Parser.prototype.matchTokenAt_38 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.endRule(context, RuleType.Description);
            this.build(context, token);
            return 39;
        }
        if (this.match_TableRow(context, token)) {
            this.endRule(context, RuleType.Description);
            this.startRule(context, RuleType.ExamplesTable);
            this.build(context, token);
            return 40;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.Description);
                this.endRule(context, RuleType.Examples);
                this.endRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 36;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 37;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Description);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Other(context, token)) {
            this.build(context, token);
            return 38;
        }
        var stateComment = 'State: 38 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:1>Description:0>#Other:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#TableRow',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Other',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 38;
    };
    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:2>#Comment:0
    Parser.prototype.matchTokenAt_39 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 39;
        }
        if (this.match_TableRow(context, token)) {
            this.startRule(context, RuleType.ExamplesTable);
            this.build(context, token);
            return 40;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.Examples);
                this.endRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 36;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 37;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 39;
        }
        var stateComment = 'State: 39 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:2>#Comment:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#Comment',
            '#TableRow',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 39;
    };
    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:2>ExamplesTable:0>#TableRow:0
    Parser.prototype.matchTokenAt_40 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.ExamplesTable);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_TableRow(context, token)) {
            this.build(context, token);
            return 40;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.ExamplesTable);
                this.endRule(context, RuleType.Examples);
                this.endRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 36;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.ExamplesTable);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.ExamplesTable);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 37;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.ExamplesTable);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.ExamplesTable);
            this.endRule(context, RuleType.Examples);
            this.endRule(context, RuleType.ExamplesDefinition);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 40;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 40;
        }
        var stateComment = 'State: 40 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:2>ExamplesTable:0>#TableRow:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#TableRow',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 40;
    };
    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0
    Parser.prototype.matchTokenAt_42 = function (token, context) {
        if (this.match_DocStringSeparator(context, token)) {
            this.build(context, token);
            return 43;
        }
        if (this.match_Other(context, token)) {
            this.build(context, token);
            return 42;
        }
        var stateComment = 'State: 42 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0';
        token.detach();
        var expectedTokens = ['#DocStringSeparator', '#Other'];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 42;
    };
    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0
    Parser.prototype.matchTokenAt_43 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 34;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.DocString);
                this.endRule(context, RuleType.Step);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 36;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 37;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 43;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 43;
        }
        var stateComment = 'State: 43 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#StepLine',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 43;
    };
    // GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0
    Parser.prototype.matchTokenAt_44 = function (token, context) {
        if (this.match_DocStringSeparator(context, token)) {
            this.build(context, token);
            return 45;
        }
        if (this.match_Other(context, token)) {
            this.build(context, token);
            return 44;
        }
        var stateComment = 'State: 44 - GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0';
        token.detach();
        var expectedTokens = ['#DocStringSeparator', '#Other'];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 44;
    };
    // GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0
    Parser.prototype.matchTokenAt_45 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Rule);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 28;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 30;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 31;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Rule);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 45;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 45;
        }
        var stateComment = 'State: 45 - GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#StepLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 45;
    };
    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0
    Parser.prototype.matchTokenAt_46 = function (token, context) {
        if (this.match_DocStringSeparator(context, token)) {
            this.build(context, token);
            return 47;
        }
        if (this.match_Other(context, token)) {
            this.build(context, token);
            return 46;
        }
        var stateComment = 'State: 46 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0';
        token.detach();
        var expectedTokens = ['#DocStringSeparator', '#Other'];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 46;
    };
    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0
    Parser.prototype.matchTokenAt_47 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 15;
        }
        if (this.match_TagLine(context, token)) {
            if (this.lookahead_0(context, token)) {
                this.endRule(context, RuleType.DocString);
                this.endRule(context, RuleType.Step);
                this.startRule(context, RuleType.ExamplesDefinition);
                this.startRule(context, RuleType.Tags);
                this.build(context, token);
                return 17;
            }
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ExamplesLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Examples);
            this.build(context, token);
            return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Scenario);
            this.endRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 47;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 47;
        }
        var stateComment = 'State: 47 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#StepLine',
            '#TagLine',
            '#ExamplesLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 47;
    };
    // GherkinDocument:0>Feature:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0
    Parser.prototype.matchTokenAt_48 = function (token, context) {
        if (this.match_DocStringSeparator(context, token)) {
            this.build(context, token);
            return 49;
        }
        if (this.match_Other(context, token)) {
            this.build(context, token);
            return 48;
        }
        var stateComment = 'State: 48 - GherkinDocument:0>Feature:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0';
        token.detach();
        var expectedTokens = ['#DocStringSeparator', '#Other'];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 48;
    };
    // GherkinDocument:0>Feature:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0
    Parser.prototype.matchTokenAt_49 = function (token, context) {
        if (this.match_EOF(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.endRule(context, RuleType.Feature);
            this.build(context, token);
            return 41;
        }
        if (this.match_StepLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.startRule(context, RuleType.Step);
            this.build(context, token);
            return 9;
        }
        if (this.match_TagLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
        }
        if (this.match_ScenarioLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Scenario);
            this.build(context, token);
            return 12;
        }
        if (this.match_RuleLine(context, token)) {
            this.endRule(context, RuleType.DocString);
            this.endRule(context, RuleType.Step);
            this.endRule(context, RuleType.Background);
            this.startRule(context, RuleType.Rule);
            this.startRule(context, RuleType.RuleHeader);
            this.build(context, token);
            return 22;
        }
        if (this.match_Comment(context, token)) {
            this.build(context, token);
            return 49;
        }
        if (this.match_Empty(context, token)) {
            this.build(context, token);
            return 49;
        }
        var stateComment = 'State: 49 - GherkinDocument:0>Feature:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0';
        token.detach();
        var expectedTokens = [
            '#EOF',
            '#StepLine',
            '#TagLine',
            '#ScenarioLine',
            '#RuleLine',
            '#Comment',
            '#Empty',
        ];
        var error = token.isEof
            ? Errors_1.UnexpectedEOFException.create(token, expectedTokens, stateComment)
            : Errors_1.UnexpectedTokenException.create(token, expectedTokens, stateComment);
        if (this.stopAtFirstError) {
            throw error;
        }
        this.addError(context, error);
        return 49;
    };
    Parser.prototype.match_EOF = function (context, token) {
        return this.handleExternalError(context, false, function () {
            return context.tokenMatcher.match_EOF(token);
        });
    };
    Parser.prototype.match_Empty = function (context, token) {
        if (token.isEof) {
            return false;
        }
        return this.handleExternalError(context, false, function () {
            return context.tokenMatcher.match_Empty(token);
        });
    };
    Parser.prototype.match_Comment = function (context, token) {
        if (token.isEof) {
            return false;
        }
        return this.handleExternalError(context, false, function () {
            return context.tokenMatcher.match_Comment(token);
        });
    };
    Parser.prototype.match_TagLine = function (context, token) {
        if (token.isEof) {
            return false;
        }
        return this.handleExternalError(context, false, function () {
            return context.tokenMatcher.match_TagLine(token);
        });
    };
    Parser.prototype.match_FeatureLine = function (context, token) {
        if (token.isEof) {
            return false;
        }
        return this.handleExternalError(context, false, function () {
            return context.tokenMatcher.match_FeatureLine(token);
        });
    };
    Parser.prototype.match_RuleLine = function (context, token) {
        if (token.isEof) {
            return false;
        }
        return this.handleExternalError(context, false, function () {
            return context.tokenMatcher.match_RuleLine(token);
        });
    };
    Parser.prototype.match_BackgroundLine = function (context, token) {
        if (token.isEof) {
            return false;
        }
        return this.handleExternalError(context, false, function () {
            return context.tokenMatcher.match_BackgroundLine(token);
        });
    };
    Parser.prototype.match_ScenarioLine = function (context, token) {
        if (token.isEof) {
            return false;
        }
        return this.handleExternalError(context, false, function () {
            return context.tokenMatcher.match_ScenarioLine(token);
        });
    };
    Parser.prototype.match_ExamplesLine = function (context, token) {
        if (token.isEof) {
            return false;
        }
        return this.handleExternalError(context, false, function () {
            return context.tokenMatcher.match_ExamplesLine(token);
        });
    };
    Parser.prototype.match_StepLine = function (context, token) {
        if (token.isEof) {
            return false;
        }
        return this.handleExternalError(context, false, function () {
            return context.tokenMatcher.match_StepLine(token);
        });
    };
    Parser.prototype.match_DocStringSeparator = function (context, token) {
        if (token.isEof) {
            return false;
        }
        return this.handleExternalError(context, false, function () {
            return context.tokenMatcher.match_DocStringSeparator(token);
        });
    };
    Parser.prototype.match_TableRow = function (context, token) {
        if (token.isEof) {
            return false;
        }
        return this.handleExternalError(context, false, function () {
            return context.tokenMatcher.match_TableRow(token);
        });
    };
    Parser.prototype.match_Language = function (context, token) {
        if (token.isEof) {
            return false;
        }
        return this.handleExternalError(context, false, function () {
            return context.tokenMatcher.match_Language(token);
        });
    };
    Parser.prototype.match_Other = function (context, token) {
        if (token.isEof) {
            return false;
        }
        return this.handleExternalError(context, false, function () {
            return context.tokenMatcher.match_Other(token);
        });
    };
    Parser.prototype.lookahead_0 = function (context, currentToken) {
        currentToken.detach();
        var token;
        var queue = [];
        var match = false;
        do {
            token = this.readToken(this.context);
            token.detach();
            queue.push(token);
            if ( false || this.match_ExamplesLine(context, token)) {
                match = true;
                break;
            }
        } while ( false ||
            this.match_Empty(context, token) ||
            this.match_Comment(context, token) ||
            this.match_TagLine(context, token));
        context.tokenQueue = context.tokenQueue.concat(queue);
        return match;
    };
    return Parser;
}());
exports.default = Parser;
//# sourceMappingURL=Parser.js.map

/***/ }),

/***/ 2554:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Token = /** @class */ (function () {
    function Token(line, location) {
        this.line = line;
        this.location = location;
        this.isEof = line == null;
    }
    Token.prototype.getTokenValue = function () {
        return this.isEof ? 'EOF' : this.line.getLineText(-1);
    };
    Token.prototype.detach = function () {
        // TODO: Detach line, but is this really needed?
    };
    return Token;
}());
exports.default = Token;
//# sourceMappingURL=Token.js.map

/***/ }),

/***/ 2402:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var gherkin_languages_json_1 = __importDefault(__webpack_require__(1608));
var Errors_1 = __webpack_require__(9259);
var Parser_1 = __webpack_require__(3332);
var DIALECT_DICT = gherkin_languages_json_1.default;
var LANGUAGE_PATTERN = /^\s*#\s*language\s*:\s*([a-zA-Z\-_]+)\s*$/;
var TokenMatcher = /** @class */ (function () {
    function TokenMatcher(defaultDialectName) {
        if (defaultDialectName === void 0) { defaultDialectName = 'en'; }
        this.defaultDialectName = defaultDialectName;
        this.reset();
    }
    TokenMatcher.prototype.changeDialect = function (newDialectName, location) {
        var newDialect = DIALECT_DICT[newDialectName];
        if (!newDialect) {
            throw Errors_1.NoSuchLanguageException.create(newDialectName, location);
        }
        this.dialectName = newDialectName;
        this.dialect = newDialect;
    };
    TokenMatcher.prototype.reset = function () {
        if (this.dialectName !== this.defaultDialectName) {
            this.changeDialect(this.defaultDialectName);
        }
        this.activeDocStringSeparator = null;
        this.indentToRemove = 0;
    };
    TokenMatcher.prototype.match_TagLine = function (token) {
        if (token.line.startsWith('@')) {
            this.setTokenMatched(token, Parser_1.TokenType.TagLine, null, null, null, token.line.getTags());
            return true;
        }
        return false;
    };
    TokenMatcher.prototype.match_FeatureLine = function (token) {
        return this.matchTitleLine(token, Parser_1.TokenType.FeatureLine, this.dialect.feature);
    };
    TokenMatcher.prototype.match_ScenarioLine = function (token) {
        return (this.matchTitleLine(token, Parser_1.TokenType.ScenarioLine, this.dialect.scenario) ||
            this.matchTitleLine(token, Parser_1.TokenType.ScenarioLine, this.dialect.scenarioOutline));
    };
    TokenMatcher.prototype.match_BackgroundLine = function (token) {
        return this.matchTitleLine(token, Parser_1.TokenType.BackgroundLine, this.dialect.background);
    };
    TokenMatcher.prototype.match_ExamplesLine = function (token) {
        return this.matchTitleLine(token, Parser_1.TokenType.ExamplesLine, this.dialect.examples);
    };
    TokenMatcher.prototype.match_RuleLine = function (token) {
        return this.matchTitleLine(token, Parser_1.TokenType.RuleLine, this.dialect.rule);
    };
    TokenMatcher.prototype.match_TableRow = function (token) {
        if (token.line.startsWith('|')) {
            // TODO: indent
            this.setTokenMatched(token, Parser_1.TokenType.TableRow, null, null, null, token.line.getTableCells());
            return true;
        }
        return false;
    };
    TokenMatcher.prototype.match_Empty = function (token) {
        if (token.line.isEmpty) {
            this.setTokenMatched(token, Parser_1.TokenType.Empty, null, null, 0);
            return true;
        }
        return false;
    };
    TokenMatcher.prototype.match_Comment = function (token) {
        if (token.line.startsWith('#')) {
            var text = token.line.getLineText(0); // take the entire line, including leading space
            this.setTokenMatched(token, Parser_1.TokenType.Comment, text, null, 0);
            return true;
        }
        return false;
    };
    TokenMatcher.prototype.match_Language = function (token) {
        var match = token.line.trimmedLineText.match(LANGUAGE_PATTERN);
        if (match) {
            var newDialectName = match[1];
            this.setTokenMatched(token, Parser_1.TokenType.Language, newDialectName);
            this.changeDialect(newDialectName, token.location);
            return true;
        }
        return false;
    };
    TokenMatcher.prototype.match_DocStringSeparator = function (token) {
        return this.activeDocStringSeparator == null
            ? // open
                this._match_DocStringSeparator(token, '"""', true) ||
                    this._match_DocStringSeparator(token, '```', true)
            : // close
                this._match_DocStringSeparator(token, this.activeDocStringSeparator, false);
    };
    TokenMatcher.prototype._match_DocStringSeparator = function (token, separator, isOpen) {
        if (token.line.startsWith(separator)) {
            var contentType = null;
            if (isOpen) {
                contentType = token.line.getRestTrimmed(separator.length);
                this.activeDocStringSeparator = separator;
                this.indentToRemove = token.line.indent;
            }
            else {
                this.activeDocStringSeparator = null;
                this.indentToRemove = 0;
            }
            // TODO: Use the separator as keyword. That's needed for pretty printing.
            this.setTokenMatched(token, Parser_1.TokenType.DocStringSeparator, contentType);
            return true;
        }
        return false;
    };
    TokenMatcher.prototype.match_EOF = function (token) {
        if (token.isEof) {
            this.setTokenMatched(token, Parser_1.TokenType.EOF);
            return true;
        }
        return false;
    };
    TokenMatcher.prototype.match_StepLine = function (token) {
        var e_1, _a;
        var keywords = []
            .concat(this.dialect.given)
            .concat(this.dialect.when)
            .concat(this.dialect.then)
            .concat(this.dialect.and)
            .concat(this.dialect.but);
        try {
            for (var keywords_1 = __values(keywords), keywords_1_1 = keywords_1.next(); !keywords_1_1.done; keywords_1_1 = keywords_1.next()) {
                var keyword = keywords_1_1.value;
                if (token.line.startsWith(keyword)) {
                    var title = token.line.getRestTrimmed(keyword.length);
                    this.setTokenMatched(token, Parser_1.TokenType.StepLine, title, keyword);
                    return true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (keywords_1_1 && !keywords_1_1.done && (_a = keywords_1.return)) _a.call(keywords_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    };
    TokenMatcher.prototype.match_Other = function (token) {
        var text = token.line.getLineText(this.indentToRemove); // take the entire line, except removing DocString indents
        this.setTokenMatched(token, Parser_1.TokenType.Other, this.unescapeDocString(text), null, 0);
        return true;
    };
    TokenMatcher.prototype.matchTitleLine = function (token, tokenType, keywords) {
        var e_2, _a;
        try {
            for (var keywords_2 = __values(keywords), keywords_2_1 = keywords_2.next(); !keywords_2_1.done; keywords_2_1 = keywords_2.next()) {
                var keyword = keywords_2_1.value;
                if (token.line.startsWithTitleKeyword(keyword)) {
                    var title = token.line.getRestTrimmed(keyword.length + ':'.length);
                    this.setTokenMatched(token, tokenType, title, keyword);
                    return true;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (keywords_2_1 && !keywords_2_1.done && (_a = keywords_2.return)) _a.call(keywords_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return false;
    };
    TokenMatcher.prototype.setTokenMatched = function (token, matchedType, text, keyword, indent, items) {
        token.matchedType = matchedType;
        token.matchedText = text;
        token.matchedKeyword = keyword;
        token.matchedIndent =
            typeof indent === 'number'
                ? indent
                : token.line == null
                    ? 0
                    : token.line.indent;
        token.matchedItems = items || [];
        token.location.column = token.matchedIndent + 1;
        token.matchedGherkinDialect = this.dialectName;
    };
    TokenMatcher.prototype.unescapeDocString = function (text) {
        return this.activeDocStringSeparator != null
            ? text.replace('\\"\\"\\"', '"""')
            : text;
    };
    return TokenMatcher;
}());
exports.default = TokenMatcher;
//# sourceMappingURL=TokenMatcher.js.map

/***/ }),

/***/ 976:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Token_1 = __importDefault(__webpack_require__(2554));
var GherkinLine_1 = __importDefault(__webpack_require__(3715));
var createLocation_1 = __importDefault(__webpack_require__(7134));
/**
 * The scanner reads a gherkin doc (typically read from a .feature file) and creates a token for each line.
 * The tokens are passed to the parser, which outputs an AST (Abstract Syntax Tree).
 *
 * If the scanner sees a `#` language header, it will reconfigure itself dynamically to look for
 * Gherkin keywords for the associated language. The keywords are defined in gherkin-languages.json.
 */
var TokenScanner = /** @class */ (function () {
    function TokenScanner(source) {
        this.lineNumber = 0;
        this.lines = source.split(/\r?\n/);
        if (this.lines.length > 0 &&
            this.lines[this.lines.length - 1].trim() === '') {
            this.lines.pop();
        }
    }
    TokenScanner.prototype.read = function () {
        var line = this.lines[this.lineNumber++];
        var location = createLocation_1.default({
            line: this.lineNumber,
        });
        location.column = undefined;
        return line == null
            ? new Token_1.default(null, location)
            : new Token_1.default(new GherkinLine_1.default(line, this.lineNumber), location);
    };
    return TokenScanner;
}());
exports.default = TokenScanner;
//# sourceMappingURL=TokenScanner.js.map

/***/ }),

/***/ 7134:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var cucumber_messages_1 = __webpack_require__(6106);
function createLocation(props) {
    var location = cucumber_messages_1.messages.Location.create(props);
    if (location.line === 0) {
        location.line = undefined;
    }
    if (location.column === 0) {
        location.column = undefined;
    }
    return location;
}
exports.default = createLocation;
//# sourceMappingURL=createLocation.js.map

/***/ }),

/***/ 8462:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// https://mathiasbynens.be/notes/javascript-unicode
var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
function countSymbols(s) {
    return s.replace(regexAstralSymbols, '_').length;
}
exports.default = countSymbols;
//# sourceMappingURL=countSymbols.js.map

/***/ }),

/***/ 3495:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var child_process_1 = __webpack_require__(3129);
var cucumber_messages_1 = __webpack_require__(6106);
var GherkinExe = /** @class */ (function () {
    function GherkinExe(gherkinExe, paths, envelopes, options) {
        this.gherkinExe = gherkinExe;
        this.paths = paths;
        this.envelopes = envelopes;
        this.options = options;
    }
    GherkinExe.prototype.dialects = function () {
        var result = child_process_1.spawnSync(this.gherkinExe, ['--dialects']);
        return JSON.parse(result.stdout);
    };
    GherkinExe.prototype.messageStream = function () {
        var e_1, _a;
        var options = ['--default-dialect', this.options.defaultDialect];
        if (!this.options.includeSource) {
            options.push('--no-source');
        }
        if (!this.options.includeGherkinDocument) {
            options.push('--no-ast');
        }
        if (!this.options.includePickles) {
            options.push('--no-pickles');
        }
        var args = options.concat(this.paths);
        var gherkin = child_process_1.spawn(this.gherkinExe, args, {
            stdio: ['pipe', 'pipe', 'inherit'],
        });
        var toMessageStream = new cucumber_messages_1.BinaryToMessageStream(cucumber_messages_1.messages.Envelope.decodeDelimited.bind(cucumber_messages_1.messages.Envelope));
        gherkin.on('error', function (err) { return toMessageStream.emit('error', err); });
        gherkin.stdout.pipe(toMessageStream);
        try {
            for (var _b = __values(this.envelopes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var envelope = _c.value;
                gherkin.stdin.write(cucumber_messages_1.messages.Envelope.encodeDelimited(envelope).finish());
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        gherkin.stdin.end();
        return toMessageStream;
    };
    return GherkinExe;
}());
exports.default = GherkinExe;
//# sourceMappingURL=GherkinExe.js.map

/***/ }),

/***/ 4832:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Gherkin_1 = __importDefault(__webpack_require__(8215));
exports.default = Gherkin_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 761:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var cucumber_messages_1 = __webpack_require__(6106);
var defaultOptions = {
    defaultDialect: 'en',
    includeSource: true,
    includeGherkinDocument: true,
    includePickles: true,
    newId: cucumber_messages_1.IdGenerator.uuid(),
};
function gherkinOptions(options) {
    return __assign(__assign({}, defaultOptions), options);
}
exports.default = gherkinOptions;
//# sourceMappingURL=makeGherkinOptions.js.map

/***/ }),

/***/ 4258:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var cucumber_messages_1 = __webpack_require__(6106);
function compile(gherkinDocument, uri, newId) {
    var pickles = [];
    if (gherkinDocument.feature == null) {
        return pickles;
    }
    var feature = gherkinDocument.feature;
    var language = feature.language;
    var featureTags = feature.tags;
    var featureBackgroundSteps = [];
    feature.children.forEach(function (stepsContainer) {
        if (stepsContainer.background) {
            featureBackgroundSteps = [].concat(stepsContainer.background.steps);
        }
        else if (stepsContainer.rule) {
            compileRule(featureTags, featureBackgroundSteps, stepsContainer.rule, language, pickles, uri, newId);
        }
        else if (stepsContainer.scenario.examples.length === 0) {
            compileScenario(featureTags, featureBackgroundSteps, stepsContainer.scenario, language, pickles, uri, newId);
        }
        else {
            compileScenarioOutline(featureTags, featureBackgroundSteps, stepsContainer.scenario, language, pickles, uri, newId);
        }
    });
    return pickles;
}
exports.default = compile;
function compileRule(featureTags, featureBackgroundSteps, rule, language, pickles, uri, newId) {
    var ruleBackgroundSteps = [].concat(featureBackgroundSteps);
    rule.children.forEach(function (stepsContainer) {
        if (stepsContainer.background) {
            ruleBackgroundSteps = ruleBackgroundSteps.concat(stepsContainer.background.steps);
        }
        else if (stepsContainer.scenario.examples.length === 0) {
            compileScenario(featureTags, ruleBackgroundSteps, stepsContainer.scenario, language, pickles, uri, newId);
        }
        else {
            compileScenarioOutline(featureTags, ruleBackgroundSteps, stepsContainer.scenario, language, pickles, uri, newId);
        }
    });
}
function compileScenario(featureTags, backgroundSteps, scenario, language, pickles, uri, newId) {
    var steps = scenario.steps.length === 0
        ? []
        : backgroundSteps.map(function (step) { return pickleStep(step, [], null, newId); });
    var tags = [].concat(featureTags).concat(scenario.tags);
    scenario.steps.forEach(function (step) { return steps.push(pickleStep(step, [], null, newId)); });
    var pickle = cucumber_messages_1.messages.Pickle.create({
        id: newId(),
        uri: uri,
        astNodeIds: [scenario.id],
        tags: pickleTags(tags),
        name: scenario.name,
        language: language,
        steps: steps,
    });
    pickles.push(pickle);
}
function compileScenarioOutline(featureTags, backgroundSteps, scenario, language, pickles, uri, newId) {
    scenario.examples
        .filter(function (e) { return e.tableHeader !== null; })
        .forEach(function (examples) {
        var variableCells = examples.tableHeader.cells;
        examples.tableBody.forEach(function (valuesRow) {
            var steps = scenario.steps.length === 0
                ? []
                : backgroundSteps.map(function (step) { return pickleStep(step, [], null, newId); });
            var tags = []
                .concat(featureTags)
                .concat(scenario.tags)
                .concat(examples.tags);
            scenario.steps.forEach(function (scenarioOutlineStep) {
                var step = pickleStep(scenarioOutlineStep, variableCells, valuesRow, newId);
                steps.push(step);
            });
            pickles.push(cucumber_messages_1.messages.Pickle.create({
                id: newId(),
                uri: uri,
                astNodeIds: [scenario.id, valuesRow.id],
                name: interpolate(scenario.name, variableCells, valuesRow.cells),
                language: language,
                steps: steps,
                tags: pickleTags(tags),
            }));
        });
    });
}
function createPickleArguments(step, variableCells, valueCells) {
    if (step.dataTable) {
        var argument = step.dataTable;
        var table = {
            rows: argument.rows.map(function (row) {
                return {
                    cells: row.cells.map(function (cell) {
                        return {
                            location: cell.location,
                            value: interpolate(cell.value, variableCells, valueCells),
                        };
                    }),
                };
            }),
        };
        return {
            dataTable: table,
        };
    }
    else if (step.docString) {
        var argument = step.docString;
        var docString = cucumber_messages_1.messages.PickleStepArgument.PickleDocString.create({
            content: interpolate(argument.content, variableCells, valueCells),
        });
        if (argument.contentType) {
            docString.contentType = interpolate(argument.contentType, variableCells, valueCells);
        }
        return {
            docString: docString,
        };
    }
}
function interpolate(name, variableCells, valueCells) {
    variableCells.forEach(function (variableCell, n) {
        var valueCell = valueCells[n];
        var search = new RegExp('<' + variableCell.value + '>', 'g');
        // JS Specific - dollar sign needs to be escaped with another dollar sign
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter
        var replacement = valueCell.value.replace(new RegExp('\\$', 'g'), '$$$$');
        name = name.replace(search, replacement);
    });
    return name;
}
function pickleSteps(scenario, variableCells, valuesRow, newId) {
    return scenario.steps.map(function (s) { return pickleStep(s, variableCells, valuesRow, newId); });
}
function pickleStep(step, variableCells, valuesRow, newId) {
    var astNodeIds = [step.id];
    if (valuesRow) {
        astNodeIds.push(valuesRow.id);
    }
    var valueCells = valuesRow ? valuesRow.cells : [];
    return cucumber_messages_1.messages.Pickle.PickleStep.create({
        id: newId(),
        text: interpolate(step.text, variableCells, valueCells),
        argument: createPickleArguments(step, variableCells, valueCells),
        astNodeIds: astNodeIds,
    });
}
function pickleTags(tags) {
    return tags.map(pickleTag);
}
function pickleTag(tag) {
    return cucumber_messages_1.messages.Pickle.PickleTag.create({
        name: tag.name,
        astNodeId: tag.id,
    });
}
//# sourceMappingURL=compile.js.map

/***/ }),

/***/ 2369:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var generateMessages_1 = __importDefault(__webpack_require__(4177));
var stream_1 = __webpack_require__(2413);
/**
 * Stream that reads Source messages and writes GherkinDocument and Pickle messages.
 */
var ParserMessageStream = /** @class */ (function (_super) {
    __extends(ParserMessageStream, _super);
    function ParserMessageStream(options) {
        var _this = _super.call(this, { writableObjectMode: true, readableObjectMode: true }) || this;
        _this.options = options;
        return _this;
    }
    ParserMessageStream.prototype._transform = function (envelope, encoding, callback) {
        var e_1, _a;
        if (envelope.source) {
            var messageList = generateMessages_1.default(envelope.source.data, envelope.source.uri, this.options);
            try {
                for (var messageList_1 = __values(messageList), messageList_1_1 = messageList_1.next(); !messageList_1_1.done; messageList_1_1 = messageList_1.next()) {
                    var message = messageList_1_1.value;
                    this.push(message);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (messageList_1_1 && !messageList_1_1.done && (_a = messageList_1.return)) _a.call(messageList_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        callback();
    };
    return ParserMessageStream;
}(stream_1.Transform));
exports.default = ParserMessageStream;
module.exports = ParserMessageStream;
//# sourceMappingURL=ParserMessageStream.js.map

/***/ }),

/***/ 1682:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var stream_1 = __webpack_require__(2413);
var makeSourceEnvelope_1 = __importDefault(__webpack_require__(9800));
/**
 * Stream that reads a string and writes a single Source message.
 */
var SourceMessageStream = /** @class */ (function (_super) {
    __extends(SourceMessageStream, _super);
    function SourceMessageStream(uri) {
        var _this = _super.call(this, { readableObjectMode: true, writableObjectMode: false }) || this;
        _this.uri = uri;
        _this.buffer = Buffer.alloc(0);
        return _this;
    }
    SourceMessageStream.prototype._transform = function (chunk, encoding, callback) {
        this.buffer = Buffer.concat([this.buffer, chunk]);
        callback();
    };
    SourceMessageStream.prototype._flush = function (callback) {
        var data = this.buffer.toString('UTF-8');
        var chunk = makeSourceEnvelope_1.default(data, this.uri);
        this.push(chunk);
        callback();
    };
    return SourceMessageStream;
}(stream_1.Transform));
exports.default = SourceMessageStream;
//# sourceMappingURL=SourceMessageStream.js.map

/***/ }),

/***/ 4177:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Parser_1 = __importDefault(__webpack_require__(3332));
var TokenMatcher_1 = __importDefault(__webpack_require__(2402));
var cucumber_messages_1 = __webpack_require__(6106);
var compile_1 = __importDefault(__webpack_require__(4258));
var AstBuilder_1 = __importDefault(__webpack_require__(6431));
function generateMessages(data, uri, options) {
    var e_1, _a, e_2, _b;
    var result = [];
    try {
        if (options.includeSource) {
            result.push(new cucumber_messages_1.messages.Envelope({
                source: {
                    uri: uri,
                    data: data,
                    media: {
                        encoding: cucumber_messages_1.messages.Media.Encoding.UTF8,
                        contentType: 'text/x.cucumber.gherkin+plain',
                    },
                },
            }));
        }
        if (!options.includeGherkinDocument && !options.includePickles) {
            return result;
        }
        var parser = new Parser_1.default(new AstBuilder_1.default(options.newId));
        parser.stopAtFirstError = false;
        var gherkinDocument = parser.parse(data, new TokenMatcher_1.default(options.defaultDialect));
        if (options.includeGherkinDocument) {
            result.push(cucumber_messages_1.messages.Envelope.create({
                gherkinDocument: __assign(__assign({}, gherkinDocument), { uri: uri }),
            }));
        }
        if (options.includePickles) {
            var pickles = compile_1.default(gherkinDocument, uri, options.newId);
            try {
                for (var pickles_1 = __values(pickles), pickles_1_1 = pickles_1.next(); !pickles_1_1.done; pickles_1_1 = pickles_1.next()) {
                    var pickle = pickles_1_1.value;
                    result.push(cucumber_messages_1.messages.Envelope.create({
                        pickle: pickle,
                    }));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (pickles_1_1 && !pickles_1_1.done && (_a = pickles_1.return)) _a.call(pickles_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    }
    catch (err) {
        var errors = err.errors || [err];
        try {
            for (var errors_1 = __values(errors), errors_1_1 = errors_1.next(); !errors_1_1.done; errors_1_1 = errors_1.next()) {
                var error = errors_1_1.value;
                if (!error.location) {
                    // It wasn't a parser error - throw it (this is unexpected)
                    throw error;
                }
                result.push(cucumber_messages_1.messages.Envelope.create({
                    attachment: {
                        source: {
                            uri: uri,
                            location: {
                                line: error.location.line,
                                column: error.location.column,
                            },
                        },
                        data: error.message,
                    },
                }));
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (errors_1_1 && !errors_1_1.done && (_b = errors_1.return)) _b.call(errors_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    return result;
}
exports.default = generateMessages;
//# sourceMappingURL=generateMessages.js.map

/***/ }),

/***/ 9800:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var cucumber_messages_1 = __webpack_require__(6106);
function makeSourceEnvelope(data, uri) {
    return new cucumber_messages_1.messages.Envelope({
        source: new cucumber_messages_1.messages.Source({
            data: data,
            uri: uri,
            media: new cucumber_messages_1.messages.Media({
                encoding: cucumber_messages_1.messages.Media.Encoding.UTF8,
                contentType: 'text/x.cucumber.gherkin+plain',
            }),
        }),
    });
}
exports.default = makeSourceEnvelope;
//# sourceMappingURL=makeSourceEnvelope.js.map

/***/ }),

/***/ 7625:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.alphasort = alphasort
exports.alphasorti = alphasorti
exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path = __webpack_require__(5622)
var minimatch = __webpack_require__(3973)
var isAbsolute = __webpack_require__(8714)
var Minimatch = minimatch.Minimatch

function alphasorti (a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort (a, b) {
  return a.localeCompare(b)
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess
  self.absolute = !!options.absolute

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(self.nocase ? alphasorti : alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e))
        var c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/')

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}


/***/ }),

/***/ 1717:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var fs = __webpack_require__(5747)
var rp = __webpack_require__(6863)
var minimatch = __webpack_require__(3973)
var Minimatch = minimatch.Minimatch
var inherits = __webpack_require__(4124)
var EE = __webpack_require__(8614).EventEmitter
var path = __webpack_require__(5622)
var assert = __webpack_require__(2357)
var isAbsolute = __webpack_require__(8714)
var globSync = __webpack_require__(9010)
var common = __webpack_require__(7625)
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = __webpack_require__(2492)
var util = __webpack_require__(1669)
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = __webpack_require__(1223)

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute)
    e = abs

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
}


/***/ }),

/***/ 9010:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = globSync
globSync.GlobSync = GlobSync

var fs = __webpack_require__(5747)
var rp = __webpack_require__(6863)
var minimatch = __webpack_require__(3973)
var Minimatch = minimatch.Minimatch
var Glob = __webpack_require__(1717).Glob
var util = __webpack_require__(1669)
var path = __webpack_require__(5622)
var assert = __webpack_require__(2357)
var isAbsolute = __webpack_require__(8714)
var common = __webpack_require__(7625)
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = rp.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored(this, e))
    return

  var abs = this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute) {
    e = abs
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = fs.lstatSync(abs)
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = fs.lstatSync(abs)
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'

  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}


/***/ }),

/***/ 2492:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(2940)
var reqs = Object.create(null)
var once = __webpack_require__(1223)

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args)
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len)
        process.nextTick(function () {
          RES.apply(null, args)
        })
      } else {
        delete reqs[key]
      }
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}


/***/ }),

/***/ 4124:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__(1669);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__(8544);
}


/***/ }),

/***/ 8544:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 864:
/***/ ((module) => {

"use strict";


module.exports = value => {
	if (Object.prototype.toString.call(value) !== '[object Object]') {
		return false;
	}

	const prototype = Object.getPrototypeOf(value);
	return prototype === null || prototype === Object.prototype;
};


/***/ }),

/***/ 8119:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.autoBindSteps = void 0;
var step_definition_validation_1 = __webpack_require__(8317);
var feature_definition_creation_1 = __webpack_require__(2388);
var step_generation_1 = __webpack_require__(720);
var globalSteps = [];
var registerStep = function (stepMatcher, stepFunction) {
    globalSteps.push({ stepMatcher: stepMatcher, stepFunction: stepFunction });
};
exports.autoBindSteps = function (features, stepDefinitions) {
    stepDefinitions.forEach(function (stepDefinitionCallback) {
        stepDefinitionCallback({
            defineStep: registerStep,
            given: registerStep,
            when: registerStep,
            then: registerStep,
            and: registerStep,
            but: registerStep,
            pending: function () {
                // Nothing to do
            },
        });
    });
    var errors = [];
    features.forEach(function (feature) {
        feature_definition_creation_1.defineFeature(feature, function (test) {
            var scenarioOutlineScenarios = feature.scenarioOutlines
                .map(function (scenarioOutline) { return scenarioOutline.scenarios[0]; });
            var scenarios = __spreadArrays(feature.scenarios, scenarioOutlineScenarios);
            scenarios.forEach(function (scenario) {
                test(scenario.title, function (options) {
                    scenario.steps.forEach(function (step, stepIndex) {
                        var matches = globalSteps
                            .filter(function (globalStep) { return step_definition_validation_1.matchSteps(step.stepText, globalStep.stepMatcher); });
                        if (matches.length === 1) {
                            var match = matches[0];
                            options.defineStep(match.stepMatcher, match.stepFunction);
                        }
                        else if (matches.length === 0) {
                            var stepCode = step_generation_1.generateStepCode(scenario.steps, stepIndex, false);
                            // tslint:disable-next-line:max-line-length
                            errors.push("No matching step found for step \"" + step.stepText + "\" in scenario \"" + scenario.title + "\" in feature \"" + feature.title + "\". Please add the following step code: \n\n" + stepCode);
                        }
                        else {
                            var matchingCode = matches.map(function (match) { return match.stepMatcher.toString() + "\n\n" + match.stepFunction.toString(); });
                            errors.push(matches.length + " step definition matches were found for step \"" + step.stepText + "\" in scenario \"" + scenario.title + "\" in feature \"" + feature.title + "\". Each step can only have one matching step definition. The following step definition matches were found:\n\n" + matchingCode.join('\n\n'));
                        }
                    });
                });
            });
        });
    });
    if (errors.length) {
        throw new Error(errors.join('\n\n'));
    }
};
//# sourceMappingURL=automatic-step-binding.js.map

/***/ }),

/***/ 5601:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateCodeWithSeparateFunctionsFromFeature = exports.generateCodeFromFeature = exports.ObjectTypeEnum = void 0;
var scenario_generation_1 = __webpack_require__(4192);
var step_generation_1 = __webpack_require__(720);
var ObjectTypeEnum;
(function (ObjectTypeEnum) {
    ObjectTypeEnum[ObjectTypeEnum["scenario"] = 0] = "scenario";
    ObjectTypeEnum[ObjectTypeEnum["scenarioOutline"] = 1] = "scenarioOutline";
    ObjectTypeEnum[ObjectTypeEnum["step"] = 2] = "step";
})(ObjectTypeEnum = exports.ObjectTypeEnum || (exports.ObjectTypeEnum = {}));
var findObjectByLineNumber = function (feature, lineNumber) {
    var found = null;
    var type = ObjectTypeEnum.scenario;
    feature.scenarioOutlines.forEach(function (scenarioOutline) {
        if (scenarioOutline.lineNumber === lineNumber) {
            found = scenarioOutline;
            type = ObjectTypeEnum.scenarioOutline;
        }
        scenarioOutline.steps.forEach(function (step, index) {
            if (step.lineNumber === lineNumber) {
                found = { steps: scenarioOutline.steps, index: index };
                type = ObjectTypeEnum.step;
            }
        });
    });
    feature.scenarios.forEach(function (scenario) {
        if (scenario.lineNumber === lineNumber) {
            found = scenario;
            type = ObjectTypeEnum.scenario;
        }
        scenario.steps.forEach(function (step, index) {
            if (step.lineNumber === lineNumber) {
                found = { steps: scenario.steps, index: index };
                type = ObjectTypeEnum.step;
            }
        });
    });
    return found ? { object: found, type: type } : null;
};
exports.generateCodeFromFeature = function (feature, lineNumber) {
    var objectAtLine = findObjectByLineNumber(feature, lineNumber);
    if (objectAtLine === null) {
        return null;
    }
    else {
        switch (objectAtLine.type) {
            case ObjectTypeEnum.scenario:
            case ObjectTypeEnum.scenarioOutline:
                return scenario_generation_1.generateScenarioCode(objectAtLine.object);
            case ObjectTypeEnum.step:
                return step_generation_1.generateStepCode(objectAtLine.object.steps, objectAtLine.object.index, false);
        }
    }
};
exports.generateCodeWithSeparateFunctionsFromFeature = function (feature, lineNumber) {
    var objectAtLine = findObjectByLineNumber(feature, lineNumber);
    if (objectAtLine === null) {
        return null;
    }
    else {
        switch (objectAtLine.type) {
            case ObjectTypeEnum.scenario:
            case ObjectTypeEnum.scenarioOutline:
                return scenario_generation_1.generateScenarioCodeWithSeparateStepFunctions(objectAtLine.object);
            case ObjectTypeEnum.step:
                return step_generation_1.generateStepCode(objectAtLine.object.steps, objectAtLine.object.index, true);
        }
    }
};
//# sourceMappingURL=generate-code-by-line-number.js.map

/***/ }),

/***/ 4192:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateScenarioCodeWithSeparateStepFunctions = exports.generateScenarioCode = void 0;
var step_generation_1 = __webpack_require__(720);
var utils_1 = __webpack_require__(9495);
var scenarioTemplate = function (scenarioTitle, steps, stepKeywords) {
    // tslint:disable-next-line:max-line-length
    return "test('" + scenarioTitle.replace(/'+/g, "\\'") + "', ({ " + stepKeywords.join(', ') + " }) => {\n" + utils_1.indent(steps, 1).slice(0, -1) + "\n});";
};
var getStepKeywords = function (scenario) {
    var stepKeywords = [];
    scenario.steps.forEach(function (step) {
        if (stepKeywords.indexOf(step.keyword) === -1) {
            stepKeywords.push(step.keyword);
        }
    });
    return stepKeywords;
};
exports.generateScenarioCode = function (scenario) {
    var stepsCode = scenario.steps.map(function (step, index) { return step_generation_1.generateStepCode(scenario.steps, index); });
    var stepKeywords = getStepKeywords(scenario);
    return scenarioTemplate(scenario.title, stepsCode.join('\n\n'), stepKeywords);
};
exports.generateScenarioCodeWithSeparateStepFunctions = function (scenario) {
    var stepFunctionCode = scenario.steps.map(function (step, index) { return step_generation_1.generateStepCode(scenario.steps, index, true); });
    var stepFunctionCalls = scenario.steps.map(function (step, index) { return step_generation_1.generateStepFunctionCall(scenario.steps, index); });
    var stepKeywords = getStepKeywords(scenario);
    // tslint:disable-next-line:max-line-length
    return stepFunctionCode.join('\n\n') + "\n\n" + scenarioTemplate(scenario.title, stepFunctionCalls.join('\n'), stepKeywords);
};
//# sourceMappingURL=scenario-generation.js.map

/***/ }),

/***/ 720:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateStepFunctionCall = exports.generateStepCode = exports.getStepKeyword = void 0;
var utils_1 = __webpack_require__(9495);
var stepTemplate = function (stepKeyword, stepMatcher, stepArgumentVariables) {
    return stepKeyword + "(" + stepMatcher + ", (" + stepArgumentVariables.join(', ') + ") => {\n\n});";
};
var getStepFunctionWrapperName = function (stepKeyword, stepText) {
    // tslint:disable-next-line:max-line-length
    return stepKeyword + "_" + stepText.replace(stepTextArgumentRegex, 'X').replace(/\s/g, '_').replace(/[^A-Za-z0-9_]/g, '');
};
var stepWrapperFunctionTemplate = function (stepKeyword, stepText, stepMatcher, stepArgumentVariables) {
    // tslint:disable-next-line:max-line-length
    return "export const " + getStepFunctionWrapperName(stepKeyword, stepText) + " = (" + stepKeyword + ") => {\n" + utils_1.indent(stepTemplate(stepKeyword, stepMatcher, stepArgumentVariables), 1).slice(0, -1) + "\n}";
};
var stepWrapperFunctionCallTemplate = function (stepText, stepKeyword) {
    return getStepFunctionWrapperName(stepKeyword, stepText) + "(" + stepKeyword + ")";
};
var stepTextArgumentRegex = /([-+]?[0-9]*\.?[0-9]+)|\"([^"<]+)\"|\"?\<([^"<]*)\>\"?/g;
var escapeRegexCharacters = function (text) {
    return text
        .replace(/\$/g, '\\$')
        .replace(/\(/g, '\\(')
        .replace(/\)/g, '\\)');
};
var convertStepTextToRegex = function (step) {
    var stepText = escapeRegexCharacters(step.stepText);
    var matches;
    var finalStepText = stepText;
    while (matches = stepTextArgumentRegex.exec(stepText)) {
        var fullMatch = matches[0], numberMatch = matches[1], stringMatch = matches[2];
        if (numberMatch) {
            finalStepText = finalStepText.replace(numberMatch, '(\\d+)');
        }
        else if (stringMatch) {
            finalStepText = finalStepText.replace(stringMatch, '(.*)');
        }
        else {
            finalStepText = finalStepText.replace(fullMatch, '(.*)');
        }
    }
    return "/^" + finalStepText + "$/";
};
var getStepArguments = function (step) {
    var stepArgumentVariables = [];
    var match;
    var index = 0;
    while (match = stepTextArgumentRegex.exec(step.stepText)) {
        stepArgumentVariables.push("arg" + index);
        index++;
    }
    if (step.stepArgument) {
        if (typeof step.stepArgument === 'string') {
            stepArgumentVariables.push('docString');
        }
        else {
            stepArgumentVariables.push('table');
        }
    }
    return stepArgumentVariables;
};
var getStepMatcher = function (step) {
    var stepMatcher = '';
    if (step.stepText.match(stepTextArgumentRegex)) {
        stepMatcher = convertStepTextToRegex(step);
    }
    else {
        stepMatcher = "'" + step.stepText.replace(/'+/g, "\\'") + "'";
    }
    return stepMatcher;
};
exports.getStepKeyword = function (steps, stepPosition) {
    return steps[stepPosition].keyword;
};
exports.generateStepCode = function (steps, stepPosition, generateWrapperFunction) {
    if (generateWrapperFunction === void 0) { generateWrapperFunction = false; }
    var step = steps[stepPosition];
    var stepKeyword = exports.getStepKeyword(steps, stepPosition);
    var stepMatcher = getStepMatcher(step);
    var stepArguments = getStepArguments(step);
    if (generateWrapperFunction) {
        return stepWrapperFunctionTemplate(stepKeyword, step.stepText, stepMatcher, stepArguments);
    }
    else {
        return stepTemplate(stepKeyword, stepMatcher, stepArguments);
    }
};
exports.generateStepFunctionCall = function (steps, stepPosition) {
    var step = steps[stepPosition];
    var stepKeyword = exports.getStepKeyword(steps, stepPosition);
    return stepWrapperFunctionCallTemplate(step.stepText, stepKeyword);
};
//# sourceMappingURL=step-generation.js.map

/***/ }),

/***/ 9495:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.indent = void 0;
exports.indent = function (stringToIndent, tabsToIndent) {
    var tabs = '';
    for (var i = 0; i < tabsToIndent; i++) {
        tabs = tabs + '\t';
    }
    return stringToIndent.split('\n').map(function (line) {
        if (line !== '') {
            return "" + tabs + line + "\n";
        }
        else {
            return '\n';
        }
    }).join('');
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 3279:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setJestCucumberConfiguration = exports.getJestCucumberConfiguration = void 0;
var defaultErrorSettings = {
    missingScenarioInStepDefinitions: true,
    missingStepInStepDefinitions: true,
    missingScenarioInFeature: true,
    missingStepInFeature: true,
};
var defaultConfiguration = {
    tagFilter: undefined,
    scenarioNameTemplate: undefined,
    errors: defaultErrorSettings,
};
var globalConfiguration = {};
exports.getJestCucumberConfiguration = function (options) {
    var mergedOptions = __assign(__assign(__assign({}, defaultConfiguration), globalConfiguration), options || {});
    if (mergedOptions.errors === true) {
        mergedOptions.errors = defaultErrorSettings;
    }
    return mergedOptions;
};
exports.setJestCucumberConfiguration = function (options) {
    globalConfiguration = options;
};
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ 2388:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineFeature = void 0;
var scenario_validation_1 = __webpack_require__(5176);
var step_definition_validation_1 = __webpack_require__(8317);
var tag_filtering_1 = __webpack_require__(6157);
var processScenarioTitleTemplate = function (scenarioTitle, parsedFeature, options, parsedScenario, parsedScenarioOutline) {
    if (options && options.scenarioNameTemplate) {
        try {
            return options && options.scenarioNameTemplate({
                featureTitle: parsedFeature.title,
                scenarioTitle: scenarioTitle.toString(),
                featureTags: parsedFeature.tags,
                scenarioTags: (parsedScenario || parsedScenarioOutline).tags,
            });
        }
        catch (err) {
            throw new Error(
            // tslint:disable-next-line:max-line-length
            "An error occurred while executing a scenario name template. \nTemplate:\n" + options.scenarioNameTemplate + "\nError:" + err.message);
        }
    }
    return scenarioTitle;
};
var checkForPendingSteps = function (scenarioFromStepDefinitions) {
    var scenarioPending = false;
    scenarioFromStepDefinitions.steps.forEach(function (step) {
        try {
            if (step.stepFunction.toString().indexOf('pending()') !== -1) {
                var pendingTest = new Function("\n                    let isPending = false;\n\n                    const pending = function () {\n                        isPending = true;\n                    };\n\n                    (" + step.stepFunction + ")();\n\n                    return isPending;\n                ");
                scenarioPending = pendingTest();
            }
        }
        catch (err) {
            // Ignore
        }
    });
    return scenarioPending;
};
var getTestFunction = function (skippedViaTagFilter, only, skip, concurrent) {
    if (skip || skippedViaTagFilter) {
        return test.skip;
    }
    else if (only) {
        return test.only;
    }
    else if (concurrent) {
        return test.concurrent;
    }
    else {
        return test;
    }
};
var defineScenario = function (scenarioTitle, scenarioFromStepDefinitions, parsedScenario, only, skip, concurrent, timeout) {
    if (only === void 0) { only = false; }
    if (skip === void 0) { skip = false; }
    if (concurrent === void 0) { concurrent = false; }
    if (timeout === void 0) { timeout = undefined; }
    var testFunction = getTestFunction(parsedScenario.skippedViaTagFilter, only, skip, concurrent);
    testFunction(scenarioTitle, function () {
        return scenarioFromStepDefinitions.steps.reduce(function (promiseChain, nextStep, index) {
            var stepArgument = parsedScenario.steps[index].stepArgument;
            var matches = step_definition_validation_1.matchSteps(parsedScenario.steps[index].stepText, scenarioFromStepDefinitions.steps[index].stepMatcher);
            var matchArgs = [];
            if (matches && matches.length) {
                matchArgs = matches.slice(1);
            }
            var args = __spreadArrays(matchArgs, [stepArgument]);
            return promiseChain.then(function () { return nextStep.stepFunction.apply(nextStep, args); });
        }, Promise.resolve());
    }, timeout);
};
var createDefineScenarioFunction = function (featureFromStepDefinitions, parsedFeature, only, skip, concurrent) {
    if (only === void 0) { only = false; }
    if (skip === void 0) { skip = false; }
    if (concurrent === void 0) { concurrent = false; }
    var defineScenarioFunction = function (scenarioTitle, stepsDefinitionFunctionCallback, timeout) {
        var scenarioFromStepDefinitions = {
            title: scenarioTitle,
            steps: [],
        };
        featureFromStepDefinitions.scenarios.push(scenarioFromStepDefinitions);
        stepsDefinitionFunctionCallback({
            defineStep: createDefineStepFunction(scenarioFromStepDefinitions),
            given: createDefineStepFunction(scenarioFromStepDefinitions),
            when: createDefineStepFunction(scenarioFromStepDefinitions),
            then: createDefineStepFunction(scenarioFromStepDefinitions),
            and: createDefineStepFunction(scenarioFromStepDefinitions),
            but: createDefineStepFunction(scenarioFromStepDefinitions),
            pending: function () {
                // Nothing to do
            },
        });
        var parsedScenario = parsedFeature.scenarios
            .filter(function (s) { return s.title.toLowerCase() === scenarioTitle.toLowerCase(); })[0];
        var parsedScenarioOutline = parsedFeature.scenarioOutlines
            .filter(function (s) { return s.title.toLowerCase() === scenarioTitle.toLowerCase(); })[0];
        var options = parsedFeature.options;
        scenarioTitle = processScenarioTitleTemplate(scenarioTitle, parsedFeature, options, parsedScenario, parsedScenarioOutline);
        step_definition_validation_1.ensureFeatureFileAndStepDefinitionScenarioHaveSameSteps(options, parsedScenario || parsedScenarioOutline, scenarioFromStepDefinitions);
        if (checkForPendingSteps(scenarioFromStepDefinitions)) {
            xtest(scenarioTitle, function () {
                // Nothing to do
            }, undefined);
        }
        else if (parsedScenario) {
            defineScenario(scenarioTitle, scenarioFromStepDefinitions, parsedScenario, only, skip, concurrent, timeout);
        }
        else if (parsedScenarioOutline) {
            parsedScenarioOutline.scenarios.forEach(function (scenario) {
                defineScenario((scenario.title || scenarioTitle), scenarioFromStepDefinitions, scenario, only, skip, concurrent, timeout);
            });
        }
    };
    return defineScenarioFunction;
};
var createDefineScenarioFunctionWithAliases = function (featureFromStepDefinitions, parsedFeature) {
    var defineScenarioFunctionWithAliases = createDefineScenarioFunction(featureFromStepDefinitions, parsedFeature);
    defineScenarioFunctionWithAliases.only = createDefineScenarioFunction(featureFromStepDefinitions, parsedFeature, true, false, false);
    defineScenarioFunctionWithAliases.skip = createDefineScenarioFunction(featureFromStepDefinitions, parsedFeature, false, true, false);
    defineScenarioFunctionWithAliases.concurrent = createDefineScenarioFunction(featureFromStepDefinitions, parsedFeature, false, false, true);
    return defineScenarioFunctionWithAliases;
};
var createDefineStepFunction = function (scenarioFromStepDefinitions) {
    return function (stepMatcher, stepFunction) {
        var stepDefinition = {
            stepMatcher: stepMatcher,
            stepFunction: stepFunction,
        };
        scenarioFromStepDefinitions.steps.push(stepDefinition);
    };
};
function defineFeature(featureFromFile, scenariosDefinitionCallback) {
    var featureFromDefinedSteps = {
        title: featureFromFile.title,
        scenarios: [],
    };
    var parsedFeatureWithTagFiltersApplied = tag_filtering_1.applyTagFilters(featureFromFile);
    if (parsedFeatureWithTagFiltersApplied.scenarios.length === 0
        && parsedFeatureWithTagFiltersApplied.scenarioOutlines.length === 0) {
        return;
    }
    describe(featureFromFile.title, function () {
        scenariosDefinitionCallback(createDefineScenarioFunctionWithAliases(featureFromDefinedSteps, parsedFeatureWithTagFiltersApplied));
        scenario_validation_1.checkThatFeatureFileAndStepDefinitionsHaveSameScenarios(parsedFeatureWithTagFiltersApplied, featureFromDefinedSteps);
    });
}
exports.defineFeature = defineFeature;
//# sourceMappingURL=feature-definition-creation.js.map

/***/ }),

/***/ 5550:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var parsed_feature_loading_1 = __webpack_require__(1186);
Object.defineProperty(exports, "loadFeature", ({ enumerable: true, get: function () { return parsed_feature_loading_1.loadFeature; } }));
Object.defineProperty(exports, "loadFeatures", ({ enumerable: true, get: function () { return parsed_feature_loading_1.loadFeatures; } }));
Object.defineProperty(exports, "parseFeature", ({ enumerable: true, get: function () { return parsed_feature_loading_1.parseFeature; } }));
var feature_definition_creation_1 = __webpack_require__(2388);
Object.defineProperty(exports, "defineFeature", ({ enumerable: true, get: function () { return feature_definition_creation_1.defineFeature; } }));
var configuration_1 = __webpack_require__(3279);
Object.defineProperty(exports, "setJestCucumberConfiguration", ({ enumerable: true, get: function () { return configuration_1.setJestCucumberConfiguration; } }));
var generate_code_by_line_number_1 = __webpack_require__(5601);
Object.defineProperty(exports, "generateCodeFromFeature", ({ enumerable: true, get: function () { return generate_code_by_line_number_1.generateCodeFromFeature; } }));
Object.defineProperty(exports, "generateCodeWithSeparateFunctionsFromFeature", ({ enumerable: true, get: function () { return generate_code_by_line_number_1.generateCodeWithSeparateFunctionsFromFeature; } }));
var automatic_step_binding_1 = __webpack_require__(8119);
Object.defineProperty(exports, "autoBindSteps", ({ enumerable: true, get: function () { return automatic_step_binding_1.autoBindSteps; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1186:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadFeatures = exports.loadFeature = exports.parseFeature = void 0;
var fs_1 = __webpack_require__(5747);
var glob_1 = __webpack_require__(1717);
var path_1 = __webpack_require__(5622);
var callsites_1 = __webpack_require__(5018);
var Parser_1 = __webpack_require__(3332);
var gherkin_1 = __webpack_require__(4832);
var AstBuilder_1 = __webpack_require__(6431);
var uuid_1 = __webpack_require__(25);
var configuration_1 = __webpack_require__(3279);
var parseDataTableRow = function (astDataTableRow) {
    return astDataTableRow.cells.map(function (col) { return col.value; });
};
var parseDataTable = function (astDataTable, astDataTableHeader) {
    var headerRow;
    var bodyRows;
    if (astDataTableHeader) {
        headerRow = parseDataTableRow(astDataTableHeader);
        bodyRows = astDataTable;
    }
    else {
        headerRow = parseDataTableRow(astDataTable.rows[0]);
        bodyRows = astDataTable && astDataTable.rows && astDataTable.rows.length && astDataTable.rows.slice(1);
    }
    if (bodyRows && bodyRows.length > 0) {
        return bodyRows.map(function (nextRow) {
            var parsedRow = parseDataTableRow(nextRow);
            return parsedRow.reduce(function (rowObj, nextCol, index) {
                var _a;
                return __assign(__assign({}, rowObj), (_a = {}, _a[headerRow[index]] = nextCol, _a));
            }, {});
        });
    }
    else {
        return [];
    }
};
var parseStepArgument = function (astStep) {
    if (astStep) {
        switch (astStep.argument) {
            case 'dataTable':
                return parseDataTable(astStep.dataTable);
            case 'docString':
                return astStep.docString.content;
            default:
                return null;
        }
    }
    else {
        return null;
    }
};
var parseStep = function (astStep) {
    return {
        stepText: astStep.text,
        keyword: (astStep.keyword).trim().toLowerCase(),
        stepArgument: parseStepArgument(astStep),
        lineNumber: astStep.location.line,
    };
};
var parseSteps = function (astScenario) {
    return astScenario.steps.map(function (astStep) { return parseStep(astStep); });
};
var parseTags = function (ast) {
    if (!ast.tags) {
        return [];
    }
    else {
        return ast.tags.map(function (tag) { return tag.name.toLowerCase(); });
    }
};
var parseScenario = function (astScenario) {
    return {
        title: astScenario.name,
        steps: parseSteps(astScenario),
        tags: parseTags(astScenario),
        lineNumber: astScenario.location.line,
    };
};
var parseScenarioOutlineExampleSteps = function (exampleTableRow, scenarioSteps) {
    return scenarioSteps.map(function (scenarioStep) {
        var stepText = Object.keys(exampleTableRow).reduce(function (processedStepText, nextTableColumn) {
            return processedStepText.replace(new RegExp("<" + nextTableColumn + ">", 'g'), exampleTableRow[nextTableColumn]);
        }, scenarioStep.stepText);
        var stepArgument = '';
        if (scenarioStep.stepArgument) {
            if (Array.isArray(scenarioStep.stepArgument)) {
                stepArgument = scenarioStep.stepArgument.map(function (stepArgumentRow) {
                    var modifiedStepArgumentRow = __assign({}, stepArgumentRow);
                    Object.keys(exampleTableRow).forEach(function (nextTableColumn) {
                        Object.keys(modifiedStepArgumentRow).forEach(function (prop) {
                            modifiedStepArgumentRow[prop] =
                                modifiedStepArgumentRow[prop].replace(new RegExp("<" + nextTableColumn + ">", 'g'), exampleTableRow[nextTableColumn]);
                        });
                    });
                    return modifiedStepArgumentRow;
                });
            }
            else {
                stepArgument = scenarioStep.stepArgument;
                if (typeof scenarioStep.stepArgument === 'string' ||
                    scenarioStep.stepArgument instanceof String) {
                    Object.keys(exampleTableRow).forEach(function (nextTableColumn) {
                        stepArgument = stepArgument.replace(new RegExp("<" + nextTableColumn + ">", 'g'), exampleTableRow[nextTableColumn]);
                    });
                }
            }
        }
        return __assign(__assign({}, scenarioStep), { stepText: stepText,
            stepArgument: stepArgument });
    });
};
var getOutlineDynamicTitle = function (exampleTableRow, title) {
    return title.replace(/<(\S*)>/g, function (_, firstMatch) {
        return exampleTableRow[firstMatch || ''];
    });
};
var parseScenarioOutlineExample = function (exampleTableRow, outlineScenario, exampleSetTags) {
    return {
        title: getOutlineDynamicTitle(exampleTableRow, outlineScenario.title),
        steps: parseScenarioOutlineExampleSteps(exampleTableRow, outlineScenario.steps),
        tags: Array.from(new Set(__spreadArrays(outlineScenario.tags, exampleSetTags))),
    };
};
var parseScenarioOutlineExampleSet = function (astExampleSet, outlineScenario) {
    var exampleTable = parseDataTable(astExampleSet.tableBody, astExampleSet.tableHeader);
    return exampleTable.map(function (tableRow) { return parseScenarioOutlineExample(tableRow, outlineScenario, parseTags(astExampleSet)); });
};
var parseScenarioOutlineExampleSets = function (astExampleSets, outlineScenario) {
    var exampleSets = astExampleSets.map(function (astExampleSet) {
        return parseScenarioOutlineExampleSet(astExampleSet, outlineScenario);
    });
    return exampleSets.reduce(function (scenarios, nextExampleSet) {
        return __spreadArrays(scenarios, nextExampleSet);
    }, []);
};
var parseScenarioOutline = function (astScenarioOutline) {
    var outlineScenario = parseScenario(astScenarioOutline.scenario);
    return {
        title: outlineScenario.title,
        scenarios: parseScenarioOutlineExampleSets(astScenarioOutline.scenario.examples, outlineScenario),
        tags: outlineScenario.tags,
        steps: outlineScenario.steps,
        lineNumber: astScenarioOutline.scenario.location.line,
    };
};
var parseScenarios = function (astFeature) {
    return astFeature.children
        .filter(function (child) {
        var keywords = ['Scenario Outline', 'Scenario Template'];
        return child.scenario && keywords.indexOf(child.scenario.keyword) === -1;
    })
        .map(function (astScenario) { return parseScenario(astScenario.scenario); });
};
var parseScenarioOutlines = function (astFeature) {
    return astFeature.children
        .filter(function (child) {
        var keywords = ['Scenario Outline', 'Scenario Template'];
        return child.scenario && keywords.indexOf(child.scenario.keyword) !== -1;
    })
        .map(function (astScenarioOutline) { return parseScenarioOutline(astScenarioOutline); });
};
var collapseBackgrounds = function (astChildren, backgrounds) {
    var backgroundSteps = backgrounds
        .reduce(function (allBackgroundSteps, nextBackground) {
        return __spreadArrays(allBackgroundSteps, nextBackground.steps);
    }, []);
    astChildren.forEach(function (child) {
        if (child.scenario) {
            child.scenario.steps = __spreadArrays(backgroundSteps, child.scenario.steps);
        }
    });
    return astChildren;
};
var parseBackgrounds = function (ast) {
    return ast.children
        .filter(function (child) { return child.background; })
        .map(function (child) { return child.background; });
};
var collapseRulesAndBackgrounds = function (astFeature) {
    var featureBackgrounds = parseBackgrounds(astFeature);
    var children = collapseBackgrounds(astFeature.children, featureBackgrounds)
        .reduce(function (newChildren, nextChild) {
        if (nextChild.rule) {
            var rule = nextChild.rule;
            var ruleBackgrounds = parseBackgrounds(rule);
            return __spreadArrays(newChildren, collapseBackgrounds(rule.children, __spreadArrays(featureBackgrounds, ruleBackgrounds)));
        }
        else {
            return __spreadArrays(newChildren, [nextChild]);
        }
    }, []);
    return __assign(__assign({}, astFeature), { children: children });
};
var translateKeywords = function (astFeature) {
    var languageDialect = gherkin_1.default.dialects()[astFeature.language];
    var translationMap = createTranslationMap(languageDialect);
    astFeature.language = 'en';
    astFeature.keyword = translationMap[astFeature.keyword] || astFeature.keyword;
    for (var _i = 0, _a = astFeature.children; _i < _a.length; _i++) {
        var child = _a[_i];
        if (child.background) {
            child.background.keyword = translationMap[child.background.keyword] || child.background.keyword;
        }
        if (child.scenario) {
            child.scenario.keyword = translationMap[child.scenario.keyword] || child.scenario.keyword;
            for (var _b = 0, _c = child.scenario.steps; _b < _c.length; _b++) {
                var step = _c[_b];
                step.keyword = translationMap[step.keyword] || step.keyword;
            }
            for (var _d = 0, _e = child.scenario.examples; _d < _e.length; _d++) {
                var example = _e[_d];
                example.keyword = translationMap[example.keyword] || example.keyword;
            }
        }
    }
    return astFeature;
};
var createTranslationMap = function (translateDialect) {
    var englishDialect = gherkin_1.default.dialects().en;
    var translationMap = {};
    var props = [
        'and',
        'background',
        'but',
        'examples',
        'feature',
        'given',
        'scenario',
        'scenarioOutline',
        'then',
        'when',
        'rule',
    ];
    for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
        var prop = props_1[_i];
        var dialectWords = translateDialect[prop];
        var translationWords = englishDialect[prop];
        var index = 0;
        for (var _a = 0, dialectWords_1 = dialectWords; _a < dialectWords_1.length; _a++) {
            var dialectWord = dialectWords_1[_a];
            if (dialectWord.indexOf('*') !== 0) {
                translationMap[dialectWord] = translationWords[index];
            }
            index++;
        }
    }
    return translationMap;
};
exports.parseFeature = function (featureText, options) {
    var ast;
    try {
        var builder = new AstBuilder_1.default(uuid_1.v4);
        ast = new Parser_1.default(builder).parse(featureText);
    }
    catch (err) {
        throw new Error("Error parsing feature Gherkin: " + err.message);
    }
    var astFeature = collapseRulesAndBackgrounds(ast.feature);
    if (astFeature.language !== 'en') {
        astFeature = translateKeywords(astFeature);
    }
    return {
        title: astFeature.name,
        scenarios: parseScenarios(astFeature),
        scenarioOutlines: parseScenarioOutlines(astFeature),
        tags: parseTags(astFeature),
        options: options,
    };
};
exports.loadFeature = function (featureFilePath, options) {
    options = configuration_1.getJestCucumberConfiguration(options);
    var callSite = callsites_1.default()[1];
    var fileOfCaller = callSite && callSite.getFileName() || '';
    var dirOfCaller = path_1.dirname(fileOfCaller);
    var absoluteFeatureFilePath = path_1.resolve(options.loadRelativePath ? dirOfCaller : '', featureFilePath);
    try {
        var featureText = fs_1.readFileSync(absoluteFeatureFilePath, 'utf8');
        return exports.parseFeature(featureText, options);
    }
    catch (err) {
        if (err.code === 'ENOENT') {
            throw new Error("Feature file not found (" + absoluteFeatureFilePath + ")");
        }
        throw err;
    }
};
exports.loadFeatures = function (globPattern, options) {
    var featureFiles = glob_1.sync(globPattern);
    return featureFiles.map(function (featureFilePath) { return exports.loadFeature(featureFilePath, options); });
};
//# sourceMappingURL=parsed-feature-loading.js.map

/***/ }),

/***/ 6157:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.applyTagFilters = void 0;
var cachedTagFilterFunctions = {};
var convertTagFilterExpressionToFunction = function (tagFilterExpression) {
    var tagRegex = /(\@[A-Za-z-_0-9]+)/g;
    var tags = [];
    var match = null;
    var newTagFilterExpression = tagFilterExpression + '';
    do {
        match = tagRegex.exec(tagFilterExpression);
        if (match) {
            // tslint:disable-next-line:max-line-length
            newTagFilterExpression = newTagFilterExpression.replace(match[1], "(tags.indexOf(\"" + match[1].toLowerCase() + "\")!==-1)");
            if (tags.indexOf(match[1]) !== -1) {
                tags.push(match[1]);
            }
        }
    } while (match);
    newTagFilterExpression = newTagFilterExpression.replace(/(\s+not|not\s+|\s+not\s+)/g, ' ! ');
    newTagFilterExpression = newTagFilterExpression.replace(/(\s+or|or\s+|\s+or\s+)/g, ' || ');
    newTagFilterExpression = newTagFilterExpression.replace(/(\s+and|and\s+|\s+and\s+)/g, ' && ');
    newTagFilterExpression = newTagFilterExpression.replace(/[ \t\n\r]+/g, '');
    var tagFilterFunction;
    try {
        tagFilterFunction = new Function('tags', "return " + newTagFilterExpression + ";");
        tagFilterFunction([]);
    }
    catch (error) {
        throw new Error("Could not parse tag filter \"" + tagFilterExpression + "\"");
    }
    return tagFilterFunction;
};
var checkIfScenarioMatchesTagFilter = function (tagFilterExpression, feature, scenario) {
    var featureAndScenarioTags = __spreadArrays(scenario.tags.map(function (tag) { return tag.toLowerCase(); }), feature.tags.map(function (tag) { return tag.toLowerCase(); }));
    var tagFilterFunction = cachedTagFilterFunctions[tagFilterExpression];
    if (!tagFilterFunction) {
        tagFilterFunction = convertTagFilterExpressionToFunction(tagFilterExpression);
        cachedTagFilterFunctions[tagFilterExpression] = tagFilterFunction;
    }
    return tagFilterFunction(featureAndScenarioTags);
};
var setScenarioSkipped = function (parsedFeature, scenario) {
    var skippedViaTagFilter = !checkIfScenarioMatchesTagFilter(parsedFeature.options.tagFilter, parsedFeature, scenario);
    return __assign(__assign({}, scenario), { skippedViaTagFilter: skippedViaTagFilter });
};
exports.applyTagFilters = function (parsedFeature) {
    if (parsedFeature.options.tagFilter === undefined) {
        return parsedFeature;
    }
    var scenarios = parsedFeature.scenarios.map(function (scenario) { return setScenarioSkipped(parsedFeature, scenario); });
    var scenarioOutlines = parsedFeature.scenarioOutlines
        .map(function (scenarioOutline) {
        return __assign(__assign({}, setScenarioSkipped(parsedFeature, scenarioOutline)), { scenarios: scenarioOutline.scenarios.map(function (scenario) { return setScenarioSkipped(parsedFeature, scenario); }) });
    });
    return __assign(__assign({}, parsedFeature), { scenarios: scenarios,
        scenarioOutlines: scenarioOutlines });
};
//# sourceMappingURL=tag-filtering.js.map

/***/ }),

/***/ 5176:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkThatFeatureFileAndStepDefinitionsHaveSameScenarios = void 0;
var scenario_generation_1 = __webpack_require__(4192);
var findScenarioFromParsedFeature = function (errors, parsedScenarios, scenarioTitle, errorOptions) {
    var matchingScenarios = [];
    if (parsedScenarios) {
        matchingScenarios = parsedScenarios
            .filter(function (parsedScenario) { return parsedScenario.title.toLowerCase() === scenarioTitle.toLowerCase(); });
    }
    if (matchingScenarios.length === 0 && errorOptions.missingScenarioInFeature) {
        errors.push("No scenarios found in feature file that match scenario title \"" + scenarioTitle + ".\"");
        return null;
    }
    else if (matchingScenarios.length > 1 && errorOptions.missingStepInFeature) {
        errors.push("More than one scenario found in feature file that match scenario title \"" + scenarioTitle + "\"");
        return null;
    }
    return matchingScenarios[0];
};
var findScenarioFromStepDefinitions = function (errors, scenariosFromStepDefinitions, scenario, errorOptions) {
    var scenarioTitle = scenario.title;
    var matchingScenarios = scenariosFromStepDefinitions
        .filter(function (scenarioFromStepDefinitions) {
        return scenarioFromStepDefinitions.title.toLocaleLowerCase() === scenarioTitle.toLocaleLowerCase();
    });
    if (matchingScenarios.length === 0 && errorOptions.missingScenarioInStepDefinitions) {
        // tslint:disable-next-line:max-line-length
        errors.push("Feature file has a scenario titled \"" + scenarioTitle + "\", but no match found in step definitions. Try adding the following code:\n\n" + scenario_generation_1.generateScenarioCode(scenario));
        return null;
    }
    else if (matchingScenarios.length > 1 && errorOptions.missingScenarioInStepDefinitions) {
        errors.push("More than one scenario found in step definitions matching scenario title \"" + scenarioTitle + "\"");
        return null;
    }
    return matchingScenarios[0];
};
exports.checkThatFeatureFileAndStepDefinitionsHaveSameScenarios = function (parsedFeature, featureFromStepDefinitions) {
    var errors = [];
    var parsedScenarios = [];
    if (parsedFeature && parsedFeature.scenarios && parsedFeature.scenarios.length) {
        parsedScenarios = parsedScenarios.concat(parsedFeature.scenarios);
    }
    if (parsedFeature && parsedFeature.scenarioOutlines && parsedFeature.scenarioOutlines.length) {
        parsedScenarios = parsedScenarios.concat(parsedFeature.scenarioOutlines);
    }
    if (parsedFeature.options && parsedFeature.options.errors === false) {
        return;
    }
    if (featureFromStepDefinitions
        && featureFromStepDefinitions.scenarios
        && featureFromStepDefinitions.scenarios.length) {
        featureFromStepDefinitions.scenarios.forEach(function (scenarioFromStepDefinitions) {
            findScenarioFromParsedFeature(errors, parsedScenarios, scenarioFromStepDefinitions.title, parsedFeature.options.errors);
        });
    }
    parsedScenarios = parsedScenarios.filter(function (scenario) { return !scenario.skippedViaTagFilter; });
    if (parsedScenarios && parsedScenarios.length) {
        parsedScenarios.forEach(function (parsedScenario) {
            findScenarioFromStepDefinitions(errors, featureFromStepDefinitions && featureFromStepDefinitions.scenarios, parsedScenario, parsedFeature.options.errors);
        });
    }
    if (errors.length) {
        throw new Error(errors.join('\n\n'));
    }
};
//# sourceMappingURL=scenario-validation.js.map

/***/ }),

/***/ 8317:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ensureFeatureFileAndStepDefinitionScenarioHaveSameSteps = exports.matchSteps = void 0;
var scenario_generation_1 = __webpack_require__(4192);
var step_generation_1 = __webpack_require__(720);
exports.matchSteps = function (stepFromFeatureFile, stepMatcher) {
    if (typeof stepMatcher === 'string') {
        return stepFromFeatureFile.toLocaleLowerCase() === stepMatcher.toLocaleLowerCase();
    }
    else if (stepMatcher instanceof RegExp) {
        return stepFromFeatureFile.match(stepMatcher);
    }
    else {
        return false;
    }
};
exports.ensureFeatureFileAndStepDefinitionScenarioHaveSameSteps = function (options, parsedScenario, scenarioFromStepDefinitions) {
    if (options && options.errors === false) {
        return;
    }
    if (!parsedScenario) {
        return;
    }
    var errors = [];
    var parsedScenarioSteps = [];
    if (parsedScenario.scenarios) {
        var parsedScenarioOutlineScenarios = parsedScenario.scenarios;
        if (parsedScenarioOutlineScenarios && parsedScenarioOutlineScenarios.length) {
            parsedScenarioSteps = parsedScenarioOutlineScenarios[0].steps;
        }
        else {
            parsedScenarioSteps = [];
        }
    }
    else if (parsedScenario.steps) {
        parsedScenarioSteps = parsedScenario.steps;
    }
    var parsedStepCount = parsedScenarioSteps.length;
    var stepDefinitionCount = scenarioFromStepDefinitions.steps.length;
    if (parsedStepCount !== stepDefinitionCount && options.errors) {
        // tslint:disable-next-line:max-line-length
        errors.push("Scenario \"" + parsedScenario.title + "\" has " + parsedStepCount + " step(s) in the feature file, but " + stepDefinitionCount + " step definition(s) defined. Try adding the following code:\n\n" + scenario_generation_1.generateScenarioCode(parsedScenario));
    }
    parsedScenarioSteps.forEach(function (parsedStep, index) {
        var stepFromStepDefinitions = scenarioFromStepDefinitions.steps[index];
        if (!stepFromStepDefinitions || !exports.matchSteps(parsedStep.stepText, stepFromStepDefinitions.stepMatcher)) {
            // tslint:disable-next-line:max-line-length
            errors.push("Expected step #" + (index + 1) + " in scenario \"" + parsedScenario.title + "\" to match \"" + parsedStep.stepText + "\". Try adding the following code:\n\n" + step_generation_1.generateStepCode(parsedScenario.steps, index));
        }
    });
    if (errors.length) {
        throw new Error(errors.join('\n\n'));
    }
};
//# sourceMappingURL=step-definition-validation.js.map

/***/ }),

/***/ 25:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "NIL": () => /* reexport */ nil,
  "parse": () => /* reexport */ esm_node_parse,
  "stringify": () => /* reexport */ esm_node_stringify,
  "v1": () => /* reexport */ esm_node_v1,
  "v3": () => /* reexport */ esm_node_v3,
  "v4": () => /* reexport */ esm_node_v4,
  "v5": () => /* reexport */ esm_node_v5,
  "validate": () => /* reexport */ esm_node_validate,
  "version": () => /* reexport */ esm_node_version
});

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6417);
var external_crypto_default = /*#__PURE__*/__webpack_require__.n(external_crypto_);

// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/rng.js

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    external_crypto_default().randomFillSync(rnds8Pool);
    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/regex.js
/* harmony default export */ const regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);
// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/validate.js


function validate(uuid) {
  return typeof uuid === 'string' && regex.test(uuid);
}

/* harmony default export */ const esm_node_validate = (validate);
// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/stringify.js

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!esm_node_validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const esm_node_stringify = (stringify);
// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/v1.js

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || esm_node_stringify(b);
}

/* harmony default export */ const esm_node_v1 = (v1);
// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/parse.js


function parse(uuid) {
  if (!esm_node_validate(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const esm_node_parse = (parse);
// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/v35.js



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = esm_node_parse(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return esm_node_stringify(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/md5.js


function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return external_crypto_default().createHash('md5').update(bytes).digest();
}

/* harmony default export */ const esm_node_md5 = (md5);
// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/v3.js


const v3 = v35('v3', 0x30, esm_node_md5);
/* harmony default export */ const esm_node_v3 = (v3);
// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/v4.js



function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return esm_node_stringify(rnds);
}

/* harmony default export */ const esm_node_v4 = (v4);
// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/sha1.js


function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return external_crypto_default().createHash('sha1').update(bytes).digest();
}

/* harmony default export */ const esm_node_sha1 = (sha1);
// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/v5.js


const v5 = v35('v5', 0x50, esm_node_sha1);
/* harmony default export */ const esm_node_v5 = (v5);
// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/nil.js
/* harmony default export */ const nil = ('00000000-0000-0000-0000-000000000000');
// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/version.js


function version(uuid) {
  if (!esm_node_validate(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

/* harmony default export */ const esm_node_version = (version);
// CONCATENATED MODULE: ./node_modules/jest-cucumber/node_modules/uuid/dist/esm-node/index.js










/***/ }),

/***/ 4232:
/***/ ((module) => {

"use strict";


module.exports = longestStreak

// Get the count of the longest repeating streak of `character` in `value`.
function longestStreak(value, character) {
  var count = 0
  var maximum = 0
  var expected
  var index

  if (typeof character !== 'string' || character.length !== 1) {
    throw new Error('Expected character')
  }

  value = String(value)
  index = value.indexOf(character)
  expected = index

  while (index !== -1) {
    count++

    if (index === expected) {
      if (count > maximum) {
        maximum = count
      }
    } else {
      count = 1
    }

    expected = index + 1
    index = value.indexOf(character, expected)
  }

  return maximum
}


/***/ }),

/***/ 1062:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var repeat = __webpack_require__(6976)

module.exports = markdownTable

var trailingWhitespace = / +$/

// Characters.
var space = ' '
var lineFeed = '\n'
var dash = '-'
var colon = ':'
var verticalBar = '|'

var x = 0
var C = 67
var L = 76
var R = 82
var c = 99
var l = 108
var r = 114

// Create a table from a matrix of strings.
function markdownTable(table, options) {
  var settings = options || {}
  var padding = settings.padding !== false
  var start = settings.delimiterStart !== false
  var end = settings.delimiterEnd !== false
  var align = (settings.align || []).concat()
  var alignDelimiters = settings.alignDelimiters !== false
  var alignments = []
  var stringLength = settings.stringLength || defaultStringLength
  var rowIndex = -1
  var rowLength = table.length
  var cellMatrix = []
  var sizeMatrix = []
  var row = []
  var sizes = []
  var longestCellByColumn = []
  var mostCellsPerRow = 0
  var cells
  var columnIndex
  var columnLength
  var largest
  var size
  var cell
  var lines
  var line
  var before
  var after
  var code

  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d
  // do superfluous work when aligning, so optimize for aligning.
  while (++rowIndex < rowLength) {
    cells = table[rowIndex]
    columnIndex = -1
    columnLength = cells.length
    row = []
    sizes = []

    if (columnLength > mostCellsPerRow) {
      mostCellsPerRow = columnLength
    }

    while (++columnIndex < columnLength) {
      cell = serialize(cells[columnIndex])

      if (alignDelimiters === true) {
        size = stringLength(cell)
        sizes[columnIndex] = size

        largest = longestCellByColumn[columnIndex]

        if (largest === undefined || size > largest) {
          longestCellByColumn[columnIndex] = size
        }
      }

      row.push(cell)
    }

    cellMatrix[rowIndex] = row
    sizeMatrix[rowIndex] = sizes
  }

  // Figure out which alignments to use.
  columnIndex = -1
  columnLength = mostCellsPerRow

  if (typeof align === 'object' && 'length' in align) {
    while (++columnIndex < columnLength) {
      alignments[columnIndex] = toAlignment(align[columnIndex])
    }
  } else {
    code = toAlignment(align)

    while (++columnIndex < columnLength) {
      alignments[columnIndex] = code
    }
  }

  // Inject the alignment row.
  columnIndex = -1
  columnLength = mostCellsPerRow
  row = []
  sizes = []

  while (++columnIndex < columnLength) {
    code = alignments[columnIndex]
    before = ''
    after = ''

    if (code === l) {
      before = colon
    } else if (code === r) {
      after = colon
    } else if (code === c) {
      before = colon
      after = colon
    }

    // There *must* be at least one hyphen-minus in each alignment cell.
    size = alignDelimiters
      ? Math.max(
          1,
          longestCellByColumn[columnIndex] - before.length - after.length
        )
      : 1

    cell = before + repeat(dash, size) + after

    if (alignDelimiters === true) {
      size = before.length + size + after.length

      if (size > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size
      }

      sizes[columnIndex] = size
    }

    row[columnIndex] = cell
  }

  // Inject the alignment row.
  cellMatrix.splice(1, 0, row)
  sizeMatrix.splice(1, 0, sizes)

  rowIndex = -1
  rowLength = cellMatrix.length
  lines = []

  while (++rowIndex < rowLength) {
    row = cellMatrix[rowIndex]
    sizes = sizeMatrix[rowIndex]
    columnIndex = -1
    columnLength = mostCellsPerRow
    line = []

    while (++columnIndex < columnLength) {
      cell = row[columnIndex] || ''
      before = ''
      after = ''

      if (alignDelimiters === true) {
        size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)
        code = alignments[columnIndex]

        if (code === r) {
          before = repeat(space, size)
        } else if (code === c) {
          if (size % 2 === 0) {
            before = repeat(space, size / 2)
            after = before
          } else {
            before = repeat(space, size / 2 + 0.5)
            after = repeat(space, size / 2 - 0.5)
          }
        } else {
          after = repeat(space, size)
        }
      }

      if (start === true && columnIndex === 0) {
        line.push(verticalBar)
      }

      if (
        padding === true &&
        // Don’t add the opening space if we’re not aligning and the cell is
        // empty: there will be a closing space.
        !(alignDelimiters === false && cell === '') &&
        (start === true || columnIndex !== 0)
      ) {
        line.push(space)
      }

      if (alignDelimiters === true) {
        line.push(before)
      }

      line.push(cell)

      if (alignDelimiters === true) {
        line.push(after)
      }

      if (padding === true) {
        line.push(space)
      }

      if (end === true || columnIndex !== columnLength - 1) {
        line.push(verticalBar)
      }
    }

    line = line.join('')

    if (end === false) {
      line = line.replace(trailingWhitespace, '')
    }

    lines.push(line)
  }

  return lines.join(lineFeed)
}

function serialize(value) {
  return value === null || value === undefined ? '' : String(value)
}

function defaultStringLength(value) {
  return value.length
}

function toAlignment(value) {
  var code = typeof value === 'string' ? value.charCodeAt(0) : x

  return code === L || code === l
    ? l
    : code === R || code === r
    ? r
    : code === C || code === c
    ? c
    : x
}


/***/ }),

/***/ 6855:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = findAndReplace

var visit = __webpack_require__(3246)
var convert = __webpack_require__(4070)
var escape = __webpack_require__(2802)

var splice = [].splice

function findAndReplace(tree, find, replace, options) {
  var settings
  var schema

  if (typeof find === 'string' || (find && typeof find.exec === 'function')) {
    schema = [[find, replace]]
  } else {
    schema = find
    options = replace
  }

  settings = options || {}

  search(tree, settings, handlerFactory(toPairs(schema)))

  return tree

  function handlerFactory(pairs) {
    var pair = pairs[0]

    return handler

    function handler(node, parent) {
      var find = pair[0]
      var replace = pair[1]
      var nodes = []
      var start = 0
      var index = parent.children.indexOf(node)
      var position
      var match
      var subhandler
      var value

      find.lastIndex = 0

      match = find.exec(node.value)

      while (match) {
        position = match.index
        value = replace.apply(
          null,
          [].concat(match, {index: match.index, input: match.input})
        )

        if (value !== false) {
          if (start !== position) {
            nodes.push({type: 'text', value: node.value.slice(start, position)})
          }

          if (typeof value === 'string' && value.length > 0) {
            value = {type: 'text', value: value}
          }

          if (value) {
            nodes = [].concat(nodes, value)
          }

          start = position + match[0].length
        }

        if (!find.global) {
          break
        }

        match = find.exec(node.value)
      }

      if (position === undefined) {
        nodes = [node]
        index--
      } else {
        if (start < node.value.length) {
          nodes.push({type: 'text', value: node.value.slice(start)})
        }

        nodes.unshift(index, 1)
        splice.apply(parent.children, nodes)
      }

      if (pairs.length > 1) {
        subhandler = handlerFactory(pairs.slice(1))
        position = -1

        while (++position < nodes.length) {
          node = nodes[position]

          if (node.type === 'text') {
            subhandler(node, parent)
          } else {
            search(node, settings, subhandler)
          }
        }
      }

      return index + nodes.length + 1
    }
  }
}

function search(tree, settings, handler) {
  var ignored = convert(settings.ignore || [])
  var result = []

  visit(tree, 'text', visitor)

  return result

  function visitor(node, parents) {
    var index = -1
    var parent
    var grandparent

    while (++index < parents.length) {
      parent = parents[index]

      if (
        ignored(
          parent,
          grandparent ? grandparent.children.indexOf(parent) : undefined,
          grandparent
        )
      ) {
        return
      }

      grandparent = parent
    }

    return handler(node, grandparent)
  }
}

function toPairs(schema) {
  var result = []
  var key
  var index

  if (typeof schema !== 'object') {
    throw new Error('Expected array or object as schema')
  }

  if ('length' in schema) {
    index = -1

    while (++index < schema.length) {
      result.push([
        toExpression(schema[index][0]),
        toFunction(schema[index][1])
      ])
    }
  } else {
    for (key in schema) {
      result.push([toExpression(key), toFunction(schema[key])])
    }
  }

  return result
}

function toExpression(find) {
  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find
}

function toFunction(replace) {
  return typeof replace === 'function' ? replace : returner

  function returner() {
    return replace
  }
}


/***/ }),

/***/ 2802:
/***/ ((module) => {

"use strict";


module.exports = string => {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	// Escape characters with special meaning either inside or outside character sets.
	// Use a simple backslash escape when it’s always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
	return string
		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
		.replace(/-/g, '\\x2d');
};


/***/ }),

/***/ 6869:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = fromMarkdown

// These three are compiled away in the `dist/`

var toString = __webpack_require__(5789)
var assign = __webpack_require__(3512)
var own = __webpack_require__(3500)
var normalizeIdentifier = __webpack_require__(712)
var safeFromInt = __webpack_require__(6214)
var parser = __webpack_require__(488)
var preprocessor = __webpack_require__(5603)
var postprocess = __webpack_require__(6948)
var decode = __webpack_require__(3485)
var stringifyPosition = __webpack_require__(1957)

function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== 'string') {
    options = encoding
    encoding = undefined
  }

  return compiler(options)(
    postprocess(
      parser(options).document().write(preprocessor()(value, encoding, true))
    )
  )
}

// Note this compiler only understand complete buffering, not streaming.
function compiler(options) {
  var settings = options || {}
  var config = configure(
    {
      transforms: [],
      canContainEols: [
        'emphasis',
        'fragment',
        'heading',
        'paragraph',
        'strong'
      ],

      enter: {
        autolink: opener(link),
        autolinkProtocol: onenterdata,
        autolinkEmail: onenterdata,
        atxHeading: opener(heading),
        blockQuote: opener(blockQuote),
        characterEscape: onenterdata,
        characterReference: onenterdata,
        codeFenced: opener(codeFlow),
        codeFencedFenceInfo: buffer,
        codeFencedFenceMeta: buffer,
        codeIndented: opener(codeFlow, buffer),
        codeText: opener(codeText, buffer),
        codeTextData: onenterdata,
        data: onenterdata,
        codeFlowValue: onenterdata,
        definition: opener(definition),
        definitionDestinationString: buffer,
        definitionLabelString: buffer,
        definitionTitleString: buffer,
        emphasis: opener(emphasis),
        hardBreakEscape: opener(hardBreak),
        hardBreakTrailing: opener(hardBreak),
        htmlFlow: opener(html, buffer),
        htmlFlowData: onenterdata,
        htmlText: opener(html, buffer),
        htmlTextData: onenterdata,
        image: opener(image),
        label: buffer,
        link: opener(link),
        listItem: opener(listItem),
        listItemValue: onenterlistitemvalue,
        listOrdered: opener(list, onenterlistordered),
        listUnordered: opener(list),
        paragraph: opener(paragraph),
        reference: onenterreference,
        referenceString: buffer,
        resourceDestinationString: buffer,
        resourceTitleString: buffer,
        setextHeading: opener(heading),
        strong: opener(strong),
        thematicBreak: opener(thematicBreak)
      },

      exit: {
        atxHeading: closer(),
        atxHeadingSequence: onexitatxheadingsequence,
        autolink: closer(),
        autolinkEmail: onexitautolinkemail,
        autolinkProtocol: onexitautolinkprotocol,
        blockQuote: closer(),
        characterEscapeValue: onexitdata,
        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
        characterReferenceValue: onexitcharacterreferencevalue,
        codeFenced: closer(onexitcodefenced),
        codeFencedFence: onexitcodefencedfence,
        codeFencedFenceInfo: onexitcodefencedfenceinfo,
        codeFencedFenceMeta: onexitcodefencedfencemeta,
        codeFlowValue: onexitdata,
        codeIndented: closer(onexitcodeindented),
        codeText: closer(onexitcodetext),
        codeTextData: onexitdata,
        data: onexitdata,
        definition: closer(),
        definitionDestinationString: onexitdefinitiondestinationstring,
        definitionLabelString: onexitdefinitionlabelstring,
        definitionTitleString: onexitdefinitiontitlestring,
        emphasis: closer(),
        hardBreakEscape: closer(onexithardbreak),
        hardBreakTrailing: closer(onexithardbreak),
        htmlFlow: closer(onexithtmlflow),
        htmlFlowData: onexitdata,
        htmlText: closer(onexithtmltext),
        htmlTextData: onexitdata,
        image: closer(onexitimage),
        label: onexitlabel,
        labelText: onexitlabeltext,
        lineEnding: onexitlineending,
        link: closer(onexitlink),
        listItem: closer(),
        listOrdered: closer(),
        listUnordered: closer(),
        paragraph: closer(),
        referenceString: onexitreferencestring,
        resourceDestinationString: onexitresourcedestinationstring,
        resourceTitleString: onexitresourcetitlestring,
        resource: onexitresource,
        setextHeading: closer(onexitsetextheading),
        setextHeadingLineSequence: onexitsetextheadinglinesequence,
        setextHeadingText: onexitsetextheadingtext,
        strong: closer(),
        thematicBreak: closer()
      }
    },

    settings.mdastExtensions || []
  )

  var data = {}

  return compile

  function compile(events) {
    var tree = {type: 'root', children: []}
    var stack = [tree]
    var tokenStack = []
    var listStack = []
    var index = -1
    var handler
    var listStart

    var context = {
      stack: stack,
      tokenStack: tokenStack,
      config: config,
      enter: enter,
      exit: exit,
      buffer: buffer,
      resume: resume,
      setData: setData,
      getData: getData
    }

    while (++index < events.length) {
      // We preprocess lists to add `listItem` tokens, and to infer whether
      // items the list itself are spread out.
      if (
        events[index][1].type === 'listOrdered' ||
        events[index][1].type === 'listUnordered'
      ) {
        if (events[index][0] === 'enter') {
          listStack.push(index)
        } else {
          listStart = listStack.pop(index)
          index = prepareList(events, listStart, index)
        }
      }
    }

    index = -1

    while (++index < events.length) {
      handler = config[events[index][0]]

      if (own.call(handler, events[index][1].type)) {
        handler[events[index][1].type].call(
          assign({sliceSerialize: events[index][2].sliceSerialize}, context),
          events[index][1]
        )
      }
    }

    if (tokenStack.length) {
      throw new Error(
        'Cannot close document, a token (`' +
          tokenStack[tokenStack.length - 1].type +
          '`, ' +
          stringifyPosition({
            start: tokenStack[tokenStack.length - 1].start,
            end: tokenStack[tokenStack.length - 1].end
          }) +
          ') is still open'
      )
    }

    // Figure out `root` position.
    tree.position = {
      start: point(
        events.length ? events[0][1].start : {line: 1, column: 1, offset: 0}
      ),

      end: point(
        events.length
          ? events[events.length - 2][1].end
          : {line: 1, column: 1, offset: 0}
      )
    }

    index = -1
    while (++index < config.transforms.length) {
      tree = config.transforms[index](tree) || tree
    }

    return tree
  }

  function prepareList(events, start, length) {
    var index = start - 1
    var containerBalance = -1
    var listSpread = false
    var listItem
    var tailIndex
    var lineIndex
    var tailEvent
    var event
    var firstBlankLineIndex
    var atMarker

    while (++index <= length) {
      event = events[index]

      if (
        event[1].type === 'listUnordered' ||
        event[1].type === 'listOrdered' ||
        event[1].type === 'blockQuote'
      ) {
        if (event[0] === 'enter') {
          containerBalance++
        } else {
          containerBalance--
        }

        atMarker = undefined
      } else if (event[1].type === 'lineEndingBlank') {
        if (event[0] === 'enter') {
          if (
            listItem &&
            !atMarker &&
            !containerBalance &&
            !firstBlankLineIndex
          ) {
            firstBlankLineIndex = index
          }

          atMarker = undefined
        }
      } else if (
        event[1].type === 'linePrefix' ||
        event[1].type === 'listItemValue' ||
        event[1].type === 'listItemMarker' ||
        event[1].type === 'listItemPrefix' ||
        event[1].type === 'listItemPrefixWhitespace'
      ) {
        // Empty.
      } else {
        atMarker = undefined
      }

      if (
        (!containerBalance &&
          event[0] === 'enter' &&
          event[1].type === 'listItemPrefix') ||
        (containerBalance === -1 &&
          event[0] === 'exit' &&
          (event[1].type === 'listUnordered' ||
            event[1].type === 'listOrdered'))
      ) {
        if (listItem) {
          tailIndex = index
          lineIndex = undefined

          while (tailIndex--) {
            tailEvent = events[tailIndex]

            if (
              tailEvent[1].type === 'lineEnding' ||
              tailEvent[1].type === 'lineEndingBlank'
            ) {
              if (tailEvent[0] === 'exit') continue

              if (lineIndex) {
                events[lineIndex][1].type = 'lineEndingBlank'
                listSpread = true
              }

              tailEvent[1].type = 'lineEnding'
              lineIndex = tailIndex
            } else if (
              tailEvent[1].type === 'linePrefix' ||
              tailEvent[1].type === 'blockQuotePrefix' ||
              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||
              tailEvent[1].type === 'blockQuoteMarker' ||
              tailEvent[1].type === 'listItemIndent'
            ) {
              // Empty
            } else {
              break
            }
          }

          if (
            firstBlankLineIndex &&
            (!lineIndex || firstBlankLineIndex < lineIndex)
          ) {
            listItem._spread = true
          }

          // Fix position.
          listItem.end = point(
            lineIndex ? events[lineIndex][1].start : event[1].end
          )

          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])
          index++
          length++
        }

        // Create a new list item.
        if (event[1].type === 'listItemPrefix') {
          listItem = {
            type: 'listItem',
            _spread: false,
            start: point(event[1].start)
          }

          events.splice(index, 0, ['enter', listItem, event[2]])
          index++
          length++
          firstBlankLineIndex = undefined
          atMarker = true
        }
      }
    }

    events[start][1]._spread = listSpread
    return length
  }

  function setData(key, value) {
    data[key] = value
  }

  function getData(key) {
    return data[key]
  }

  function point(d) {
    return {line: d.line, column: d.column, offset: d.offset}
  }

  function opener(create, and) {
    return open

    function open(token) {
      enter.call(this, create(token), token)
      if (and) and.call(this, token)
    }
  }

  function buffer() {
    this.stack.push({type: 'fragment', children: []})
  }

  function enter(node, token) {
    this.stack[this.stack.length - 1].children.push(node)
    this.stack.push(node)
    this.tokenStack.push(token)
    node.position = {start: point(token.start)}
    return node
  }

  function closer(and) {
    return close

    function close(token) {
      if (and) and.call(this, token)
      exit.call(this, token)
    }
  }

  function exit(token) {
    var node = this.stack.pop()
    var open = this.tokenStack.pop()

    if (!open) {
      throw new Error(
        'Cannot close `' +
          token.type +
          '` (' +
          stringifyPosition({start: token.start, end: token.end}) +
          '): it’s not open'
      )
    } else if (open.type !== token.type) {
      throw new Error(
        'Cannot close `' +
          token.type +
          '` (' +
          stringifyPosition({start: token.start, end: token.end}) +
          '): a different token (`' +
          open.type +
          '`, ' +
          stringifyPosition({start: open.start, end: open.end}) +
          ') is open'
      )
    }

    node.position.end = point(token.end)
    return node
  }

  function resume() {
    return toString(this.stack.pop())
  }

  //
  // Handlers.
  //

  function onenterlistordered() {
    setData('expectingFirstListItemValue', true)
  }

  function onenterlistitemvalue(token) {
    if (getData('expectingFirstListItemValue')) {
      this.stack[this.stack.length - 2].start = parseInt(
        this.sliceSerialize(token),
        10
      )

      setData('expectingFirstListItemValue')
    }
  }

  function onexitcodefencedfenceinfo() {
    var data = this.resume()
    this.stack[this.stack.length - 1].lang = data
  }

  function onexitcodefencedfencemeta() {
    var data = this.resume()
    this.stack[this.stack.length - 1].meta = data
  }

  function onexitcodefencedfence() {
    // Exit if this is the closing fence.
    if (getData('flowCodeInside')) return
    this.buffer()
    setData('flowCodeInside', true)
  }

  function onexitcodefenced() {
    var data = this.resume()
    this.stack[this.stack.length - 1].value = data.replace(
      /^(\r?\n|\r)|(\r?\n|\r)$/g,
      ''
    )

    setData('flowCodeInside')
  }

  function onexitcodeindented() {
    var data = this.resume()
    this.stack[this.stack.length - 1].value = data
  }

  function onexitdefinitionlabelstring(token) {
    // Discard label, use the source content instead.
    var label = this.resume()
    this.stack[this.stack.length - 1].label = label
    this.stack[this.stack.length - 1].identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase()
  }

  function onexitdefinitiontitlestring() {
    var data = this.resume()
    this.stack[this.stack.length - 1].title = data
  }

  function onexitdefinitiondestinationstring() {
    var data = this.resume()
    this.stack[this.stack.length - 1].url = data
  }

  function onexitatxheadingsequence(token) {
    if (!this.stack[this.stack.length - 1].depth) {
      this.stack[this.stack.length - 1].depth = this.sliceSerialize(
        token
      ).length
    }
  }

  function onexitsetextheadingtext() {
    setData('setextHeadingSlurpLineEnding', true)
  }

  function onexitsetextheadinglinesequence(token) {
    this.stack[this.stack.length - 1].depth =
      this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2
  }

  function onexitsetextheading() {
    setData('setextHeadingSlurpLineEnding')
  }

  function onenterdata(token) {
    var siblings = this.stack[this.stack.length - 1].children
    var tail = siblings[siblings.length - 1]

    if (!tail || tail.type !== 'text') {
      // Add a new text node.
      tail = text()
      tail.position = {start: point(token.start)}
      this.stack[this.stack.length - 1].children.push(tail)
    }

    this.stack.push(tail)
  }

  function onexitdata(token) {
    var tail = this.stack.pop()
    tail.value += this.sliceSerialize(token)
    tail.position.end = point(token.end)
  }

  function onexitlineending(token) {
    var context = this.stack[this.stack.length - 1]

    // If we’re at a hard break, include the line ending in there.
    if (getData('atHardBreak')) {
      context.children[context.children.length - 1].position.end = point(
        token.end
      )

      setData('atHardBreak')
      return
    }

    if (
      !getData('setextHeadingSlurpLineEnding') &&
      config.canContainEols.indexOf(context.type) > -1
    ) {
      onenterdata.call(this, token)
      onexitdata.call(this, token)
    }
  }

  function onexithardbreak() {
    setData('atHardBreak', true)
  }

  function onexithtmlflow() {
    var data = this.resume()
    this.stack[this.stack.length - 1].value = data
  }

  function onexithtmltext() {
    var data = this.resume()
    this.stack[this.stack.length - 1].value = data
  }

  function onexitcodetext() {
    var data = this.resume()
    this.stack[this.stack.length - 1].value = data
  }

  function onexitlink() {
    var context = this.stack[this.stack.length - 1]

    // To do: clean.
    if (getData('inReference')) {
      context.type += 'Reference'
      context.referenceType = getData('referenceType') || 'shortcut'
      delete context.url
      delete context.title
    } else {
      delete context.identifier
      delete context.label
      delete context.referenceType
    }

    setData('referenceType')
  }

  function onexitimage() {
    var context = this.stack[this.stack.length - 1]

    // To do: clean.
    if (getData('inReference')) {
      context.type += 'Reference'
      context.referenceType = getData('referenceType') || 'shortcut'
      delete context.url
      delete context.title
    } else {
      delete context.identifier
      delete context.label
      delete context.referenceType
    }

    setData('referenceType')
  }

  function onexitlabeltext(token) {
    this.stack[this.stack.length - 2].identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase()
  }

  function onexitlabel() {
    var fragment = this.stack[this.stack.length - 1]
    var value = this.resume()

    this.stack[this.stack.length - 1].label = value

    // Assume a reference.
    setData('inReference', true)

    if (this.stack[this.stack.length - 1].type === 'link') {
      this.stack[this.stack.length - 1].children = fragment.children
    } else {
      this.stack[this.stack.length - 1].alt = value
    }
  }

  function onexitresourcedestinationstring() {
    var data = this.resume()
    this.stack[this.stack.length - 1].url = data
  }

  function onexitresourcetitlestring() {
    var data = this.resume()
    this.stack[this.stack.length - 1].title = data
  }

  function onexitresource() {
    setData('inReference')
  }

  function onenterreference() {
    setData('referenceType', 'collapsed')
  }

  function onexitreferencestring(token) {
    var label = this.resume()
    this.stack[this.stack.length - 1].label = label
    this.stack[this.stack.length - 1].identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase()
    setData('referenceType', 'full')
  }

  function onexitcharacterreferencemarker(token) {
    setData('characterReferenceType', token.type)
  }

  function onexitcharacterreferencevalue(token) {
    var data = this.sliceSerialize(token)
    var type = getData('characterReferenceType')
    var value
    var tail

    if (type) {
      value = safeFromInt(
        data,
        type === 'characterReferenceMarkerNumeric' ? 10 : 16
      )

      setData('characterReferenceType')
    } else {
      value = decode(data)
    }

    tail = this.stack.pop()
    tail.value += value
    tail.position.end = point(token.end)
  }

  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token)
    this.stack[this.stack.length - 1].url = this.sliceSerialize(token)
  }

  function onexitautolinkemail(token) {
    onexitdata.call(this, token)
    this.stack[this.stack.length - 1].url =
      'mailto:' + this.sliceSerialize(token)
  }

  //
  // Creaters.
  //

  function blockQuote() {
    return {type: 'blockquote', children: []}
  }

  function codeFlow() {
    return {type: 'code', lang: null, meta: null, value: ''}
  }

  function codeText() {
    return {type: 'inlineCode', value: ''}
  }

  function definition() {
    return {
      type: 'definition',
      identifier: '',
      label: null,
      title: null,
      url: ''
    }
  }

  function emphasis() {
    return {type: 'emphasis', children: []}
  }

  function heading() {
    return {type: 'heading', depth: undefined, children: []}
  }

  function hardBreak() {
    return {type: 'break'}
  }

  function html() {
    return {type: 'html', value: ''}
  }

  function image() {
    return {type: 'image', title: null, url: '', alt: null}
  }

  function link() {
    return {type: 'link', title: null, url: '', children: []}
  }

  function list(token) {
    return {
      type: 'list',
      ordered: token.type === 'listOrdered',
      start: null,
      spread: token._spread,
      children: []
    }
  }

  function listItem(token) {
    return {
      type: 'listItem',
      spread: token._spread,
      checked: null,
      children: []
    }
  }

  function paragraph() {
    return {type: 'paragraph', children: []}
  }

  function strong() {
    return {type: 'strong', children: []}
  }

  function text() {
    return {type: 'text', value: ''}
  }

  function thematicBreak() {
    return {type: 'thematicBreak'}
  }
}

function configure(config, extensions) {
  var index = -1

  while (++index < extensions.length) {
    extension(config, extensions[index])
  }

  return config
}

function extension(config, extension) {
  var key
  var left

  for (key in extension) {
    left = own.call(config, key) ? config[key] : (config[key] = {})

    if (key === 'canContainEols' || key === 'transforms') {
      config[key] = [].concat(left, extension[key])
    } else {
      Object.assign(left, extension[key])
    }
  }
}


/***/ }),

/***/ 3068:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(6869)


/***/ }),

/***/ 6628:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = createFromMarkdown

var matters = __webpack_require__(8592)

function createFromMarkdown(options) {
  var settings = matters(options)
  var length = settings.length
  var index = -1
  var enter = {}
  var exit = {}
  var matter

  while (++index < length) {
    matter = settings[index]
    enter[matter.type] = opener(matter)
    exit[matter.type] = close
    exit[matter.type + 'Value'] = value
  }

  return {enter: enter, exit: exit}
}

function opener(matter) {
  return open
  function open(token) {
    this.enter({type: matter.type, value: ''}, token)
    this.buffer()
  }
}

function close(token) {
  var data = this.resume()
  // Remove the initial and final eol.
  this.exit(token).value = data.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, '')
}

function value(token) {
  this.config.enter.data.call(this, token)
  this.config.exit.data.call(this, token)
}


/***/ }),

/***/ 4792:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = createToMarkdown

var matters = __webpack_require__(8592)

function createToMarkdown(options) {
  var unsafe = []
  var handlers = {}
  var settings = matters(options)
  var length = settings.length
  var index = -1
  var matter

  while (++index < length) {
    matter = settings[index]
    handlers[matter.type] = handler(matter)
    unsafe.push({atBreak: true, character: fence(matter, 'open').charAt(0)})
  }

  return {unsafe: unsafe, handlers: handlers}
}

function handler(matter) {
  var open = fence(matter, 'open')
  var close = fence(matter, 'close')

  return handle

  function handle(node) {
    return open + (node.value ? '\n' + node.value : '') + '\n' + close
  }
}

function fence(matter, prop) {
  var marker

  if (matter.marker) {
    marker = pick(matter.marker, prop)
    return marker + marker + marker
  }

  return pick(matter.fence, prop)
}

function pick(schema, prop) {
  return typeof schema === 'string' ? schema : schema[prop]
}


/***/ }),

/***/ 4857:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var ccount = __webpack_require__(1291)
var findAndReplace = __webpack_require__(6855)
var unicodePunctuation = __webpack_require__(9372)
var unicodeWhitespace = __webpack_require__(9968)

exports.transforms = [transformGfmAutolinkLiterals]
exports.enter = {
  literalAutolink: enterLiteralAutolink,
  literalAutolinkEmail: enterLiteralAutolinkValue,
  literalAutolinkHttp: enterLiteralAutolinkValue,
  literalAutolinkWww: enterLiteralAutolinkValue
}
exports.exit = {
  literalAutolink: exitLiteralAutolink,
  literalAutolinkEmail: exitLiteralAutolinkEmail,
  literalAutolinkHttp: exitLiteralAutolinkHttp,
  literalAutolinkWww: exitLiteralAutolinkWww
}

function enterLiteralAutolink(token) {
  this.enter({type: 'link', title: null, url: '', children: []}, token)
}

function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token)
}

function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token)
}

function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token)
  this.stack[this.stack.length - 1].url = 'http://' + this.sliceSerialize(token)
}

function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token)
}

function exitLiteralAutolink(token) {
  this.exit(token)
}

function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/i, findUrl],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/, findEmail]
    ],
    {ignore: ['link', 'linkReference']}
  )
}

function findUrl($0, protocol, domain, path, match) {
  var prefix = ''
  var parts
  var result

  // Not an expected previous character.
  if (!previous(match)) {
    return false
  }

  // Treat `www` as part of the domain.
  if (/^w/i.test(protocol)) {
    domain = protocol + domain
    protocol = ''
    prefix = 'http://'
  }

  if (!isCorrectDomain(domain)) {
    return false
  }

  parts = splitUrl(domain + path)

  if (!parts[0]) return false

  result = {
    type: 'link',
    title: null,
    url: prefix + protocol + parts[0],
    children: [{type: 'text', value: protocol + parts[0]}]
  }

  if (parts[1]) {
    result = [result, {type: 'text', value: parts[1]}]
  }

  return result
}

function findEmail($0, atext, label, match) {
  // Not an expected previous character.
  if (!previous(match, true) || /[_-]$/.test(label)) {
    return false
  }

  return {
    type: 'link',
    title: null,
    url: 'mailto:' + atext + '@' + label,
    children: [{type: 'text', value: atext + '@' + label}]
  }
}

function isCorrectDomain(domain) {
  var parts = domain.split('.')

  if (
    parts.length < 2 ||
    (parts[parts.length - 1] &&
      (/_/.test(parts[parts.length - 1]) ||
        !/[a-zA-Z\d]/.test(parts[parts.length - 1]))) ||
    (parts[parts.length - 2] &&
      (/_/.test(parts[parts.length - 2]) ||
        !/[a-zA-Z\d]/.test(parts[parts.length - 2])))
  ) {
    return false
  }

  return true
}

function splitUrl(url) {
  var trail = /[!"&'),.:;<>?\]}]+$/.exec(url)
  var closingParenIndex
  var openingParens
  var closingParens

  if (trail) {
    url = url.slice(0, trail.index)
    trail = trail[0]
    closingParenIndex = trail.indexOf(')')
    openingParens = ccount(url, '(')
    closingParens = ccount(url, ')')

    while (closingParenIndex !== -1 && openingParens > closingParens) {
      url += trail.slice(0, closingParenIndex + 1)
      trail = trail.slice(closingParenIndex + 1)
      closingParenIndex = trail.indexOf(')')
      closingParens++
    }
  }

  return [url, trail]
}

function previous(match, email) {
  var code = match.input.charCodeAt(match.index - 1)
  return (
    (code !== code || unicodeWhitespace(code) || unicodePunctuation(code)) &&
    (!email || code !== 47)
  )
}


/***/ }),

/***/ 7339:
/***/ ((__unused_webpack_module, exports) => {

var inConstruct = 'phrasing'
var notInConstruct = ['autolink', 'link', 'image', 'label']

exports.unsafe = [
  {
    character: '@',
    before: '[+\\-.\\w]',
    after: '[\\-.\\w]',
    inConstruct: inConstruct,
    notInConstruct: notInConstruct
  },
  {
    character: '.',
    before: '[Ww]',
    after: '[\\-.\\w]',
    inConstruct: inConstruct,
    notInConstruct: notInConstruct
  },
  {
    character: ':',
    before: '[ps]',
    after: '\\/',
    inConstruct: inConstruct,
    notInConstruct: notInConstruct
  }
]


/***/ }),

/***/ 6247:
/***/ ((__unused_webpack_module, exports) => {

exports.canContainEols = ['delete']
exports.enter = {strikethrough: enterStrikethrough}
exports.exit = {strikethrough: exitStrikethrough}

function enterStrikethrough(token) {
  this.enter({type: 'delete', children: []}, token)
}

function exitStrikethrough(token) {
  this.exit(token)
}


/***/ }),

/***/ 6474:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var phrasing = __webpack_require__(7489)

exports.unsafe = [{character: '~', inConstruct: 'phrasing'}]
exports.handlers = {delete: handleDelete}

handleDelete.peek = peekDelete

function handleDelete(node, _, context) {
  var exit = context.enter('emphasis')
  var value = phrasing(node, context, {before: '~', after: '~'})
  exit()
  return '~~' + value + '~~'
}

function peekDelete() {
  return '~'
}


/***/ }),

/***/ 1464:
/***/ ((__unused_webpack_module, exports) => {

exports.enter = {
  table: enterTable,
  tableData: enterCell,
  tableHeader: enterCell,
  tableRow: enterRow
}
exports.exit = {
  codeText: exitCodeText,
  table: exitTable,
  tableData: exit,
  tableHeader: exit,
  tableRow: exit
}

function enterTable(token) {
  this.enter({type: 'table', align: token._align, children: []}, token)
  this.setData('inTable', true)
}

function exitTable(token) {
  this.exit(token)
  this.setData('inTable')
}

function enterRow(token) {
  this.enter({type: 'tableRow', children: []}, token)
}

function exit(token) {
  this.exit(token)
}

function enterCell(token) {
  this.enter({type: 'tableCell', children: []}, token)
}

// Overwrite the default code text data handler to unescape escaped pipes when
// they are in tables.
function exitCodeText(token) {
  var value = this.resume()

  if (this.getData('inTable')) {
    value = value.replace(/\\([\\|])/g, replace)
  }

  this.stack[this.stack.length - 1].value = value
  this.exit(token)
}

function replace($0, $1) {
  // Pipes work, backslashes don’t (but can’t escape pipes).
  return $1 === '|' ? $1 : $0
}


/***/ }),

/***/ 2689:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var phrasing = __webpack_require__(7489)
var defaultInlineCode = __webpack_require__(5645)
var markdownTable = __webpack_require__(1062)

module.exports = toMarkdown

function toMarkdown(options) {
  var settings = options || {}
  var padding = settings.tableCellPadding
  var alignDelimiters = settings.tablePipeAlign
  var stringLength = settings.stringLength
  var around = padding ? ' ' : '|'

  return {
    unsafe: [
      {character: '\r', inConstruct: 'tableCell'},
      {character: '\n', inConstruct: 'tableCell'},
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      {atBreak: true, character: '|', after: '[\t :-]'},
      // A pipe in a cell must be encoded.
      {character: '|', inConstruct: 'tableCell'},
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      {atBreak: true, character: ':', after: '-'},
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      {atBreak: true, character: '-', after: '[:|-]'}
    ],
    handlers: {
      table: handleTable,
      tableRow: handleTableRow,
      tableCell: handleTableCell,
      inlineCode: inlineCodeWithTable
    }
  }

  function handleTable(node, _, context) {
    return serializeData(handleTableAsData(node, context), node.align)
  }

  // This function isn’t really used normally, because we handle rows at the
  // table level.
  // But, if someone passes in a table row, this ensures we make somewhat sense.
  function handleTableRow(node, _, context) {
    var row = handleTableRowAsData(node, context)
    // `markdown-table` will always add an align row
    var value = serializeData([row])
    return value.slice(0, value.indexOf('\n'))
  }

  function handleTableCell(node, _, context) {
    var exit = context.enter('tableCell')
    var value = phrasing(node, context, {before: around, after: around})
    exit()
    return value
  }

  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align: align,
      alignDelimiters: alignDelimiters,
      padding: padding,
      stringLength: stringLength
    })
  }

  function handleTableAsData(node, context) {
    var children = node.children
    var index = -1
    var length = children.length
    var result = []
    var subexit = context.enter('table')

    while (++index < length) {
      result[index] = handleTableRowAsData(children[index], context)
    }

    subexit()

    return result
  }

  function handleTableRowAsData(node, context) {
    var children = node.children
    var index = -1
    var length = children.length
    var result = []
    var subexit = context.enter('tableRow')

    while (++index < length) {
      result[index] = handleTableCell(children[index], node, context)
    }

    subexit()

    return result
  }

  function inlineCodeWithTable(node, parent, context) {
    var value = defaultInlineCode(node, parent, context)

    if (context.stack.indexOf('tableCell') !== -1) {
      value = value.replace(/\|/g, '\\$&')
    }

    return value
  }
}


/***/ }),

/***/ 8442:
/***/ ((__unused_webpack_module, exports) => {

exports.exit = {
  taskListCheckValueChecked: exitCheck,
  taskListCheckValueUnchecked: exitCheck,
  paragraph: exitParagraphWithTaskListItem
}

function exitCheck(token) {
  // We’re always in a paragraph, in a list item.
  this.stack[this.stack.length - 2].checked =
    token.type === 'taskListCheckValueChecked'
}

function exitParagraphWithTaskListItem(token) {
  var parent = this.stack[this.stack.length - 2]
  var node = this.stack[this.stack.length - 1]
  var siblings = parent.children
  var head = node.children[0]
  var index = -1
  var firstParaghraph

  if (
    parent &&
    parent.type === 'listItem' &&
    typeof parent.checked === 'boolean' &&
    head &&
    head.type === 'text'
  ) {
    while (++index < siblings.length) {
      if (siblings[index].type === 'paragraph') {
        firstParaghraph = siblings[index]
        break
      }
    }

    if (firstParaghraph === node) {
      // Must start with a space or a tab.
      head.value = head.value.slice(1)

      if (head.value.length === 0) {
        node.children.shift()
      } else {
        head.position.start.column++
        head.position.start.offset++
        node.position.start = Object.assign({}, head.position.start)
      }
    }
  }

  this.exit(token)
}


/***/ }),

/***/ 7319:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var defaultListItem = __webpack_require__(7016)

exports.unsafe = [{atBreak: true, character: '-', after: '[:|-]'}]

exports.handlers = {
  listItem: listItemWithTaskListItem
}

function listItemWithTaskListItem(node, parent, context) {
  var value = defaultListItem(node, parent, context)
  var head = node.children[0]

  if (typeof node.checked === 'boolean' && head && head.type === 'paragraph') {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check)
  }

  return value

  function check($0) {
    return $0 + '[' + (node.checked ? 'x' : ' ') + '] '
  }
}


/***/ }),

/***/ 7831:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var autolinkLiteral = __webpack_require__(4857)
var strikethrough = __webpack_require__(6247)
var table = __webpack_require__(1464)
var taskListItem = __webpack_require__(8442)

var own = {}.hasOwnProperty

module.exports = configure([
  autolinkLiteral,
  strikethrough,
  table,
  taskListItem
])

function configure(extensions) {
  var config = {transforms: [], canContainEols: []}
  var length = extensions.length
  var index = -1

  while (++index < length) {
    extension(config, extensions[index])
  }

  return config
}

function extension(config, extension) {
  var key
  var left
  var right

  for (key in extension) {
    left = own.call(config, key) ? config[key] : (config[key] = {})
    right = extension[key]

    if (key === 'canContainEols' || key === 'transforms') {
      config[key] = [].concat(left, right)
    } else {
      Object.assign(left, right)
    }
  }
}


/***/ }),

/***/ 9129:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var autolinkLiteral = __webpack_require__(7339)
var strikethrough = __webpack_require__(6474)
var table = __webpack_require__(2689)
var taskListItem = __webpack_require__(7319)
var configure = __webpack_require__(9363)

module.exports = toMarkdown

function toMarkdown(options) {
  var config = configure(
    {handlers: {}, join: [], unsafe: [], options: {}},
    {
      extensions: [autolinkLiteral, strikethrough, table(options), taskListItem]
    }
  )

  return Object.assign(config.options, {
    handlers: config.handlers,
    join: config.join,
    unsafe: config.unsafe
  })
}


/***/ }),

/***/ 219:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(3683)


/***/ }),

/***/ 9363:
/***/ ((module) => {

module.exports = configure

function configure(base, extension) {
  var index = -1
  var key

  // First do subextensions.
  if (extension.extensions) {
    while (++index < extension.extensions.length) {
      configure(base, extension.extensions[index])
    }
  }

  for (key in extension) {
    if (key === 'extensions') {
      // Empty.
    } else if (key === 'unsafe' || key === 'join') {
      base[key] = base[key].concat(extension[key] || [])
    } else if (key === 'handlers') {
      base[key] = Object.assign(base[key], extension[key] || {})
    } else {
      base.options[key] = extension[key]
    }
  }

  return base
}


/***/ }),

/***/ 3920:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = blockquote

var flow = __webpack_require__(7530)
var indentLines = __webpack_require__(6887)

function blockquote(node, _, context) {
  var exit = context.enter('blockquote')
  var value = indentLines(flow(node, context), map)
  exit()
  return value
}

function map(line, index, blank) {
  return '>' + (blank ? '' : ' ') + line
}


/***/ }),

/***/ 229:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = hardBreak

var patternInScope = __webpack_require__(8850)

function hardBreak(node, _, context, safe) {
  var index = -1

  while (++index < context.unsafe.length) {
    // If we can’t put eols in this construct (setext headings, tables), use a
    // space instead.
    if (
      context.unsafe[index].character === '\n' &&
      patternInScope(context.stack, context.unsafe[index])
    ) {
      return /[ \t]/.test(safe.before) ? '' : ' '
    }
  }

  return '\\\n'
}


/***/ }),

/***/ 5268:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = code

var repeat = __webpack_require__(6976)
var streak = __webpack_require__(4232)
var formatCodeAsIndented = __webpack_require__(8446)
var checkFence = __webpack_require__(158)
var indentLines = __webpack_require__(6887)
var safe = __webpack_require__(3906)

function code(node, _, context) {
  var marker = checkFence(context)
  var raw = node.value || ''
  var suffix = marker === '`' ? 'GraveAccent' : 'Tilde'
  var value
  var sequence
  var exit
  var subexit

  if (formatCodeAsIndented(node, context)) {
    exit = context.enter('codeIndented')
    value = indentLines(raw, map)
  } else {
    sequence = repeat(marker, Math.max(streak(raw, marker) + 1, 3))
    exit = context.enter('codeFenced')
    value = sequence

    if (node.lang) {
      subexit = context.enter('codeFencedLang' + suffix)
      value += safe(context, node.lang, {
        before: '`',
        after: ' ',
        encode: ['`']
      })
      subexit()
    }

    if (node.lang && node.meta) {
      subexit = context.enter('codeFencedMeta' + suffix)
      value +=
        ' ' +
        safe(context, node.meta, {
          before: ' ',
          after: '\n',
          encode: ['`']
        })
      subexit()
    }

    value += '\n'

    if (raw) {
      value += raw + '\n'
    }

    value += sequence
  }

  exit()
  return value
}

function map(line, _, blank) {
  return (blank ? '' : '    ') + line
}


/***/ }),

/***/ 7385:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = definition

var association = __webpack_require__(9211)
var checkQuote = __webpack_require__(3366)
var safe = __webpack_require__(3906)

function definition(node, _, context) {
  var marker = checkQuote(context)
  var suffix = marker === '"' ? 'Quote' : 'Apostrophe'
  var exit = context.enter('definition')
  var subexit = context.enter('label')
  var value =
    '[' + safe(context, association(node), {before: '[', after: ']'}) + ']: '

  subexit()

  if (
    // If there’s no url, or…
    !node.url ||
    // If there’s whitespace, enclosed is prettier.
    /[ \t\r\n]/.test(node.url)
  ) {
    subexit = context.enter('destinationLiteral')
    value += '<' + safe(context, node.url, {before: '<', after: '>'}) + '>'
  } else {
    // No whitespace, raw is prettier.
    subexit = context.enter('destinationRaw')
    value += safe(context, node.url, {before: ' ', after: ' '})
  }

  subexit()

  if (node.title) {
    subexit = context.enter('title' + suffix)
    value +=
      ' ' +
      marker +
      safe(context, node.title, {before: marker, after: marker}) +
      marker
    subexit()
  }

  exit()

  return value
}


/***/ }),

/***/ 8909:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = emphasis
emphasis.peek = emphasisPeek

var checkEmphasis = __webpack_require__(6452)
var phrasing = __webpack_require__(7489)

// To do: there are cases where emphasis cannot “form” depending on the
// previous or next character of sequences.
// There’s no way around that though, except for injecting zero-width stuff.
// Do we need to safeguard against that?
function emphasis(node, _, context) {
  var marker = checkEmphasis(context)
  var exit = context.enter('emphasis')
  var value = phrasing(node, context, {before: marker, after: marker})
  exit()
  return marker + value + marker
}

function emphasisPeek(node, _, context) {
  return context.options.emphasis || '*'
}


/***/ }),

/***/ 2568:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = heading

var repeat = __webpack_require__(6976)
var formatHeadingAsSetext = __webpack_require__(4954)
var phrasing = __webpack_require__(7489)

function heading(node, _, context) {
  var rank = Math.max(Math.min(6, node.depth || 1), 1)
  var exit
  var subexit
  var value
  var sequence

  if (formatHeadingAsSetext(node, context)) {
    exit = context.enter('headingSetext')
    subexit = context.enter('phrasing')
    value = phrasing(node, context, {before: '\n', after: '\n'})
    subexit()
    exit()

    return (
      value +
      '\n' +
      repeat(
        rank === 1 ? '=' : '-',
        // The whole size…
        value.length -
          // Minus the position of the character after the last EOL (or
          // 0 if there is none)…
          (Math.max(value.lastIndexOf('\r'), value.lastIndexOf('\n')) + 1)
      )
    )
  }

  sequence = repeat('#', rank)
  exit = context.enter('headingAtx')
  subexit = context.enter('phrasing')
  value = phrasing(node, context, {before: '# ', after: '\n'})
  value = value ? sequence + ' ' + value : sequence
  if (context.options.closeAtx) {
    value += ' ' + sequence
  }

  subexit()
  exit()

  return value
}


/***/ }),

/***/ 5538:
/***/ ((module) => {

module.exports = html
html.peek = htmlPeek

function html(node) {
  return node.value || ''
}

function htmlPeek() {
  return '<'
}


/***/ }),

/***/ 3885:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = imageReference
imageReference.peek = imageReferencePeek

var association = __webpack_require__(9211)
var safe = __webpack_require__(3906)

function imageReference(node, _, context) {
  var type = node.referenceType
  var exit = context.enter('imageReference')
  var subexit = context.enter('label')
  var alt = safe(context, node.alt, {before: '[', after: ']'})
  var value = '![' + alt + ']'
  var reference
  var stack

  subexit()
  // Hide the fact that we’re in phrasing, because escapes don’t work.
  stack = context.stack
  context.stack = []
  subexit = context.enter('reference')
  reference = safe(context, association(node), {before: '[', after: ']'})
  subexit()
  context.stack = stack
  exit()

  if (type === 'full' || !alt || alt !== reference) {
    value += '[' + reference + ']'
  } else if (type !== 'shortcut') {
    value += '[]'
  }

  return value
}

function imageReferencePeek() {
  return '!'
}


/***/ }),

/***/ 1591:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = image
image.peek = imagePeek

var checkQuote = __webpack_require__(3366)
var safe = __webpack_require__(3906)

function image(node, _, context) {
  var quote = checkQuote(context)
  var suffix = quote === '"' ? 'Quote' : 'Apostrophe'
  var exit = context.enter('image')
  var subexit = context.enter('label')
  var value = '![' + safe(context, node.alt, {before: '[', after: ']'}) + ']('

  subexit()

  if (
    // If there’s no url but there is a title…
    (!node.url && node.title) ||
    // Or if there’s markdown whitespace or an eol, enclose.
    /[ \t\r\n]/.test(node.url)
  ) {
    subexit = context.enter('destinationLiteral')
    value += '<' + safe(context, node.url, {before: '<', after: '>'}) + '>'
  } else {
    // No whitespace, raw is prettier.
    subexit = context.enter('destinationRaw')
    value += safe(context, node.url, {
      before: '(',
      after: node.title ? ' ' : ')'
    })
  }

  subexit()

  if (node.title) {
    subexit = context.enter('title' + suffix)
    value +=
      ' ' +
      quote +
      safe(context, node.title, {before: quote, after: quote}) +
      quote
    subexit()
  }

  value += ')'
  exit()

  return value
}

function imagePeek() {
  return '!'
}


/***/ }),

/***/ 3769:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.blockquote = __webpack_require__(3920)
exports.break = __webpack_require__(229)
exports.code = __webpack_require__(5268)
exports.definition = __webpack_require__(7385)
exports.emphasis = __webpack_require__(8909)
exports.hardBreak = __webpack_require__(229)
exports.heading = __webpack_require__(2568)
exports.html = __webpack_require__(5538)
exports.image = __webpack_require__(1591)
exports.imageReference = __webpack_require__(3885)
exports.inlineCode = __webpack_require__(5645)
exports.link = __webpack_require__(7938)
exports.linkReference = __webpack_require__(9556)
exports.list = __webpack_require__(9323)
exports.listItem = __webpack_require__(7016)
exports.paragraph = __webpack_require__(5197)
exports.root = __webpack_require__(54)
exports.strong = __webpack_require__(2150)
exports.text = __webpack_require__(2124)
exports.thematicBreak = __webpack_require__(3960)


/***/ }),

/***/ 5645:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = inlineCode
inlineCode.peek = inlineCodePeek

var patternCompile = __webpack_require__(4810)

function inlineCode(node, parent, context) {
  var value = node.value || ''
  var sequence = '`'
  var index = -1
  var pattern
  var expression
  var match
  var position

  // If there is a single grave accent on its own in the code, use a fence of
  // two.
  // If there are two in a row, use one.
  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {
    sequence += '`'
  }

  // If this is not just spaces or eols (tabs don’t count), and either the
  // first or last character are a space, eol, or tick, then pad with spaces.
  if (
    /[^ \r\n]/.test(value) &&
    (/[ \r\n`]/.test(value.charAt(0)) ||
      /[ \r\n`]/.test(value.charAt(value.length - 1)))
  ) {
    value = ' ' + value + ' '
  }

  // We have a potential problem: certain characters after eols could result in
  // blocks being seen.
  // For example, if someone injected the string `'\n# b'`, then that would
  // result in an ATX heading.
  // We can’t escape characters in `inlineCode`, but because eols are
  // transformed to spaces when going from markdown to HTML anyway, we can swap
  // them out.
  while (++index < context.unsafe.length) {
    pattern = context.unsafe[index]

    // Only look for `atBreak`s.
    // Btw: note that `atBreak` patterns will always start the regex at LF or
    // CR.
    if (!pattern.atBreak) continue

    expression = patternCompile(pattern)

    while ((match = expression.exec(value))) {
      position = match.index

      // Support CRLF (patterns only look for one of the characters).
      if (
        value.charCodeAt(position) === 10 /* `\n` */ &&
        value.charCodeAt(position - 1) === 13 /* `\r` */
      ) {
        position--
      }

      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)
    }
  }

  return sequence + value + sequence
}

function inlineCodePeek() {
  return '`'
}


/***/ }),

/***/ 9556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = linkReference
linkReference.peek = linkReferencePeek

var association = __webpack_require__(9211)
var phrasing = __webpack_require__(7489)
var safe = __webpack_require__(3906)

function linkReference(node, _, context) {
  var type = node.referenceType
  var exit = context.enter('linkReference')
  var subexit = context.enter('label')
  var text = phrasing(node, context, {before: '[', after: ']'})
  var value = '[' + text + ']'
  var reference
  var stack

  subexit()
  // Hide the fact that we’re in phrasing, because escapes don’t work.
  stack = context.stack
  context.stack = []
  subexit = context.enter('reference')
  reference = safe(context, association(node), {before: '[', after: ']'})
  subexit()
  context.stack = stack
  exit()

  if (type === 'full' || !text || text !== reference) {
    value += '[' + reference + ']'
  } else if (type !== 'shortcut') {
    value += '[]'
  }

  return value
}

function linkReferencePeek() {
  return '['
}


/***/ }),

/***/ 7938:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = link
link.peek = linkPeek

var checkQuote = __webpack_require__(3366)
var formatLinkAsAutolink = __webpack_require__(5358)
var phrasing = __webpack_require__(7489)
var safe = __webpack_require__(3906)

function link(node, _, context) {
  var quote = checkQuote(context)
  var suffix = quote === '"' ? 'Quote' : 'Apostrophe'
  var exit
  var subexit
  var value
  var stack

  if (formatLinkAsAutolink(node, context)) {
    // Hide the fact that we’re in phrasing, because escapes don’t work.
    stack = context.stack
    context.stack = []
    exit = context.enter('autolink')
    value = '<' + phrasing(node, context, {before: '<', after: '>'}) + '>'
    exit()
    context.stack = stack
    return value
  }

  exit = context.enter('link')
  subexit = context.enter('label')
  value = '[' + phrasing(node, context, {before: '[', after: ']'}) + ']('
  subexit()

  if (
    // If there’s no url but there is a title…
    (!node.url && node.title) ||
    // Or if there’s markdown whitespace or an eol, enclose.
    /[ \t\r\n]/.test(node.url)
  ) {
    subexit = context.enter('destinationLiteral')
    value += '<' + safe(context, node.url, {before: '<', after: '>'}) + '>'
  } else {
    // No whitespace, raw is prettier.
    subexit = context.enter('destinationRaw')
    value += safe(context, node.url, {
      before: '(',
      after: node.title ? ' ' : ')'
    })
  }

  subexit()

  if (node.title) {
    subexit = context.enter('title' + suffix)
    value +=
      ' ' +
      quote +
      safe(context, node.title, {before: quote, after: quote}) +
      quote
    subexit()
  }

  value += ')'

  exit()
  return value
}

function linkPeek(node, _, context) {
  return formatLinkAsAutolink(node, context) ? '<' : '['
}


/***/ }),

/***/ 7016:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = listItem

var repeat = __webpack_require__(6976)
var checkBullet = __webpack_require__(8599)
var checkListItemIndent = __webpack_require__(9009)
var flow = __webpack_require__(7530)
var indentLines = __webpack_require__(6887)

function listItem(node, parent, context) {
  var bullet = checkBullet(context)
  var listItemIndent = checkListItemIndent(context)
  var size
  var value
  var exit

  if (parent && parent.ordered) {
    bullet =
      (parent.start > -1 ? parent.start : 1) +
      (context.options.incrementListMarker === false
        ? 0
        : parent.children.indexOf(node)) +
      '.'
  }

  size = bullet.length + 1

  if (
    listItemIndent === 'tab' ||
    (listItemIndent === 'mixed' && ((parent && parent.spread) || node.spread))
  ) {
    size = Math.ceil(size / 4) * 4
  }

  exit = context.enter('listItem')
  value = indentLines(flow(node, context), map)
  exit()

  return value

  function map(line, index, blank) {
    if (index) {
      return (blank ? '' : repeat(' ', size)) + line
    }

    return (blank ? bullet : bullet + repeat(' ', size - bullet.length)) + line
  }
}


/***/ }),

/***/ 9323:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = list

var flow = __webpack_require__(7530)

function list(node, _, context) {
  var exit = context.enter('list')
  var value = flow(node, context)
  exit()
  return value
}


/***/ }),

/***/ 5197:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = paragraph

var phrasing = __webpack_require__(7489)

function paragraph(node, _, context) {
  var exit = context.enter('paragraph')
  var subexit = context.enter('phrasing')
  var value = phrasing(node, context, {before: '\n', after: '\n'})
  subexit()
  exit()
  return value
}


/***/ }),

/***/ 54:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = root

var flow = __webpack_require__(7530)

function root(node, _, context) {
  return flow(node, context)
}


/***/ }),

/***/ 2150:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = strong
strong.peek = strongPeek

var checkStrong = __webpack_require__(3534)
var phrasing = __webpack_require__(7489)

// To do: there are cases where emphasis cannot “form” depending on the
// previous or next character of sequences.
// There’s no way around that though, except for injecting zero-width stuff.
// Do we need to safeguard against that?
function strong(node, _, context) {
  var marker = checkStrong(context)
  var exit = context.enter('strong')
  var value = phrasing(node, context, {before: marker, after: marker})
  exit()
  return marker + marker + value + marker + marker
}

function strongPeek(node, _, context) {
  return context.options.strong || '*'
}


/***/ }),

/***/ 2124:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = text

var safe = __webpack_require__(3906)

function text(node, parent, context, safeOptions) {
  return safe(context, node.value, safeOptions)
}


/***/ }),

/***/ 3960:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = thematicBreak

var repeat = __webpack_require__(6976)
var checkRepeat = __webpack_require__(3680)
var checkRule = __webpack_require__(7253)

function thematicBreak(node, parent, context) {
  var value = repeat(
    checkRule(context) + (context.options.ruleSpaces ? ' ' : ''),
    checkRepeat(context)
  )

  return context.options.ruleSpaces ? value.slice(0, -1) : value
}


/***/ }),

/***/ 3683:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = toMarkdown

var zwitch = __webpack_require__(1067)
var configure = __webpack_require__(9363)
var defaultHandlers = __webpack_require__(3769)
var defaultJoin = __webpack_require__(3701)
var defaultUnsafe = __webpack_require__(6566)

function toMarkdown(tree, options) {
  var settings = options || {}
  var context = {
    enter: enter,
    stack: [],
    unsafe: [],
    join: [],
    handlers: {},
    options: {}
  }
  var result

  configure(context, {
    unsafe: defaultUnsafe,
    join: defaultJoin,
    handlers: defaultHandlers
  })
  configure(context, settings)

  if (context.options.tightDefinitions) {
    context.join = [joinDefinition].concat(context.join)
  }

  context.handle = zwitch('type', {
    invalid: invalid,
    unknown: unknown,
    handlers: context.handlers
  })

  result = context.handle(tree, null, context, {before: '\n', after: '\n'})

  if (
    result &&
    result.charCodeAt(result.length - 1) !== 10 &&
    result.charCodeAt(result.length - 1) !== 13
  ) {
    result += '\n'
  }

  return result

  function enter(name) {
    context.stack.push(name)
    return exit

    function exit() {
      context.stack.pop()
    }
  }
}

function invalid(value) {
  throw new Error('Cannot handle value `' + value + '`, expected node')
}

function unknown(node) {
  throw new Error('Cannot handle unknown node `' + node.type + '`')
}

function joinDefinition(left, right) {
  // No blank line between adjacent definitions.
  if (left.type === 'definition' && left.type === right.type) {
    return 0
  }
}


/***/ }),

/***/ 3701:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = [joinDefaults]

var formatCodeAsIndented = __webpack_require__(8446)
var formatHeadingAsSetext = __webpack_require__(4954)

function joinDefaults(left, right, parent, context) {
  if (
    // Two lists with the same marker.
    (right.type === 'list' &&
      right.type === left.type &&
      Boolean(left.ordered) === Boolean(right.ordered)) ||
    // Indented code after list or another indented code.
    (right.type === 'code' &&
      formatCodeAsIndented(right, context) &&
      (left.type === 'list' ||
        (left.type === right.type && formatCodeAsIndented(left, context))))
  ) {
    return false
  }

  // Join children of a list or an item.
  // In which case, `parent` has a `spread` field.
  if (typeof parent.spread === 'boolean') {
    if (
      left.type === 'paragraph' &&
      // Two paragraphs.
      (left.type === right.type ||
        right.type === 'definition' ||
        // Paragraph followed by a setext heading.
        (right.type === 'heading' && formatHeadingAsSetext(right, context)))
    ) {
      return
    }

    return parent.spread ? 1 : 0
  }
}


/***/ }),

/***/ 6566:
/***/ ((module) => {

module.exports = [
  {
    character: '\t',
    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']
  },
  {
    character: '\r',
    inConstruct: [
      'codeFencedLangGraveAccent',
      'codeFencedLangTilde',
      'codeFencedMetaGraveAccent',
      'codeFencedMetaTilde',
      'destinationLiteral',
      'headingAtx'
    ]
  },
  {
    character: '\n',
    inConstruct: [
      'codeFencedLangGraveAccent',
      'codeFencedLangTilde',
      'codeFencedMetaGraveAccent',
      'codeFencedMetaTilde',
      'destinationLiteral',
      'headingAtx'
    ]
  },
  {
    character: ' ',
    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {character: '!', after: '\\[', inConstruct: 'phrasing'},
  // A quote can break out of a title.
  {character: '"', inConstruct: 'titleQuote'},
  // A number sign could start an ATX heading if it starts a line.
  {atBreak: true, character: '#'},
  {character: '#', inConstruct: 'headingAtx', after: '(?:[\r\n]|$)'},
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},
  // An apostrophe can break out of a title.
  {character: "'", inConstruct: 'titleApostrophe'},
  // A left paren could break out of a destination raw.
  {character: '(', inConstruct: 'destinationRaw'},
  {before: '\\]', character: '(', inConstruct: 'phrasing'},
  // A right paren could start a list item or break out of a destination
  // raw.
  {atBreak: true, before: '\\d+', character: ')'},
  {character: ')', inConstruct: 'destinationRaw'},
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  {atBreak: true, character: '*'},
  {character: '*', inConstruct: 'phrasing'},
  // A plus sign could start a list item.
  {atBreak: true, character: '+'},
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  {atBreak: true, character: '-'},
  // A dot could start a list item.
  {atBreak: true, before: '\\d+', character: '.', after: '(?:[ \t\r\n]|$)'},
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},
  {character: '<', after: '[!/?A-Za-z]', inConstruct: 'phrasing'},
  {character: '<', inConstruct: 'destinationLiteral'},
  // An equals to can start setext heading underlines.
  {atBreak: true, character: '='},
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  {atBreak: true, character: '>'},
  {character: '>', inConstruct: 'destinationLiteral'},
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  {atBreak: true, character: '['},
  {character: '[', inConstruct: ['phrasing', 'label', 'reference']},
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  {character: '\\', after: '[\\r\\n]', inConstruct: 'phrasing'},
  // A right bracket can exit labels.
  {
    character: ']',
    inConstruct: ['label', 'reference']
  },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  {atBreak: true, character: '_'},
  {before: '[^A-Za-z]', character: '_', inConstruct: 'phrasing'},
  {character: '_', after: '[^A-Za-z]', inConstruct: 'phrasing'},
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  {atBreak: true, character: '`'},
  {
    character: '`',
    inConstruct: [
      'codeFencedLangGraveAccent',
      'codeFencedMetaGraveAccent',
      'phrasing'
    ]
  },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  {atBreak: true, character: '~'}
]


/***/ }),

/***/ 9211:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = association

var decode = __webpack_require__(3485)

var characterEscape = /\\([!-/:-@[-`{-~])/g
var characterReference = /&(#(\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi

// The `label` of an association is the string value: character escapes and
// references work, and casing is intact.
// The `identifier` is used to match one association to another: controversially,
// character escapes and references don’t work in this matching: `&copy;` does
// not match `©`, and `\+` does not match `+`.
// But casing is ignored (and whitespace) is trimmed and collapsed: ` A\nb`
// matches `a b`.
// So, we do prefer the label when figuring out how we’re going to serialize:
// it has whitespace, casing, and we can ignore most useless character escapes
// and all character references.
function association(node) {
  if (node.label || !node.identifier) {
    return node.label || ''
  }

  return node.identifier
    .replace(characterEscape, '$1')
    .replace(characterReference, decodeIfPossible)
}

function decodeIfPossible($0, $1) {
  return decode($1) || $0
}


/***/ }),

/***/ 8599:
/***/ ((module) => {

module.exports = checkBullet

function checkBullet(context) {
  var marker = context.options.bullet || '*'

  if (marker !== '*' && marker !== '+' && marker !== '-') {
    throw new Error(
      'Cannot serialize items with `' +
        marker +
        '` for `options.bullet`, expected `*`, `+`, or `-`'
    )
  }

  return marker
}


/***/ }),

/***/ 6452:
/***/ ((module) => {

module.exports = checkEmphasis

function checkEmphasis(context) {
  var marker = context.options.emphasis || '*'

  if (marker !== '*' && marker !== '_') {
    throw new Error(
      'Cannot serialize emphasis with `' +
        marker +
        '` for `options.emphasis`, expected `*`, or `_`'
    )
  }

  return marker
}


/***/ }),

/***/ 158:
/***/ ((module) => {

module.exports = checkFence

function checkFence(context) {
  var marker = context.options.fence || '`'

  if (marker !== '`' && marker !== '~') {
    throw new Error(
      'Cannot serialize code with `' +
        marker +
        '` for `options.fence`, expected `` ` `` or `~`'
    )
  }

  return marker
}


/***/ }),

/***/ 9009:
/***/ ((module) => {

module.exports = checkListItemIndent

function checkListItemIndent(context) {
  var style = context.options.listItemIndent || 'tab'

  if (style === 1 || style === '1') {
    return 'one'
  }

  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {
    throw new Error(
      'Cannot serialize items with `' +
        style +
        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'
    )
  }

  return style
}


/***/ }),

/***/ 3366:
/***/ ((module) => {

module.exports = checkQuote

function checkQuote(context) {
  var marker = context.options.quote || '"'

  if (marker !== '"' && marker !== "'") {
    throw new Error(
      'Cannot serialize title with `' +
        marker +
        '` for `options.quote`, expected `"`, or `\'`'
    )
  }

  return marker
}


/***/ }),

/***/ 3680:
/***/ ((module) => {

module.exports = checkRule

function checkRule(context) {
  var repetition = context.options.ruleRepetition || 3

  if (repetition < 3) {
    throw new Error(
      'Cannot serialize rules with repetition `' +
        repetition +
        '` for `options.ruleRepetition`, expected `3` or more'
    )
  }

  return repetition
}


/***/ }),

/***/ 7253:
/***/ ((module) => {

module.exports = checkRule

function checkRule(context) {
  var marker = context.options.rule || '*'

  if (marker !== '*' && marker !== '-' && marker !== '_') {
    throw new Error(
      'Cannot serialize rules with `' +
        marker +
        '` for `options.rule`, expected `*`, `-`, or `_`'
    )
  }

  return marker
}


/***/ }),

/***/ 3534:
/***/ ((module) => {

module.exports = checkStrong

function checkStrong(context) {
  var marker = context.options.strong || '*'

  if (marker !== '*' && marker !== '_') {
    throw new Error(
      'Cannot serialize strong with `' +
        marker +
        '` for `options.strong`, expected `*`, or `_`'
    )
  }

  return marker
}


/***/ }),

/***/ 7530:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = flow

var repeat = __webpack_require__(6976)

function flow(parent, context) {
  var children = parent.children || []
  var results = []
  var index = -1
  var child

  while (++index < children.length) {
    child = children[index]

    results.push(
      context.handle(child, parent, context, {before: '\n', after: '\n'})
    )

    if (index + 1 < children.length) {
      results.push(between(child, children[index + 1]))
    }
  }

  return results.join('')

  function between(left, right) {
    var index = -1
    var result

    while (++index < context.join.length) {
      result = context.join[index](left, right, parent, context)

      if (result === true || result === 1) {
        break
      }

      if (typeof result === 'number') {
        return repeat('\n', 1 + Number(result))
      }

      if (result === false) {
        return '\n\n<!---->\n\n'
      }
    }

    return '\n\n'
  }
}


/***/ }),

/***/ 7489:
/***/ ((module) => {

module.exports = phrasing

function phrasing(parent, context, safeOptions) {
  var children = parent.children || []
  var results = []
  var index = -1
  var before = safeOptions.before
  var after
  var handle
  var child

  while (++index < children.length) {
    child = children[index]

    if (index + 1 < children.length) {
      handle = context.handle.handlers[children[index + 1].type]
      if (handle && handle.peek) handle = handle.peek
      after = handle
        ? handle(children[index + 1], parent, context, {
            before: '',
            after: ''
          }).charAt(0)
        : ''
    } else {
      after = safeOptions.after
    }

    // In some cases, html (text) can be found in phrasing right after an eol.
    // When we’d serialize that, in most cases that would be seen as html
    // (flow).
    // As we can’t escape or so to prevent it from happening, we take a somewhat
    // reasonable approach: replace that eol with a space.
    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>
    if (
      results.length > 0 &&
      (before === '\r' || before === '\n') &&
      child.type === 'html'
    ) {
      results[results.length - 1] = results[results.length - 1].replace(
        /(\r?\n|\r)$/,
        ' '
      )
      before = ' '
    }

    results.push(
      context.handle(child, parent, context, {
        before: before,
        after: after
      })
    )

    before = results[results.length - 1].slice(-1)
  }

  return results.join('')
}


/***/ }),

/***/ 8446:
/***/ ((module) => {

module.exports = formatCodeAsIndented

function formatCodeAsIndented(node, context) {
  return (
    !context.options.fences &&
    node.value &&
    // If there’s no info…
    !node.lang &&
    // And there’s a non-whitespace character…
    /[^ \r\n]/.test(node.value) &&
    // And the value doesn’t start or end in a blank…
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node.value)
  )
}


/***/ }),

/***/ 4954:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = formatHeadingAsSetext

var toString = __webpack_require__(5789)

function formatHeadingAsSetext(node, context) {
  return (
    context.options.setext && (!node.depth || node.depth < 3) && toString(node)
  )
}


/***/ }),

/***/ 5358:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = formatLinkAsAutolink

var toString = __webpack_require__(5789)

function formatLinkAsAutolink(node, context) {
  var raw = toString(node)

  return (
    !context.options.resourceLink &&
    // If there’s a url…
    node.url &&
    // And there’s a no title…
    !node.title &&
    // And the content of `node` is a single text node…
    node.children &&
    node.children.length === 1 &&
    node.children[0].type === 'text' &&
    // And if the url is the same as the content…
    (raw === node.url || 'mailto:' + raw === node.url) &&
    // And that starts w/ a protocol…
    /^[a-z][a-z+.-]+:/i.test(node.url) &&
    // And that doesn’t contain ASCII control codes (character escapes and
    // references don’t work) or angle brackets…
    !/[\0- <>\u007F]/.test(node.url)
  )
}


/***/ }),

/***/ 6887:
/***/ ((module) => {

module.exports = indentLines

var eol = /\r?\n|\r/g

function indentLines(value, map) {
  var result = []
  var start = 0
  var line = 0
  var match

  while ((match = eol.exec(value))) {
    one(value.slice(start, match.index))
    result.push(match[0])
    start = match.index + match[0].length
    line++
  }

  one(value.slice(start))

  return result.join('')

  function one(value) {
    result.push(map(value, line, !value))
  }
}


/***/ }),

/***/ 4810:
/***/ ((module) => {

module.exports = patternCompile

function patternCompile(pattern) {
  var before
  var after

  if (!pattern._compiled) {
    before = pattern.before ? '(?:' + pattern.before + ')' : ''
    after = pattern.after ? '(?:' + pattern.after + ')' : ''

    if (pattern.atBreak) {
      before = '[\\r\\n][\\t ]*' + before
    }

    pattern._compiled = new RegExp(
      (before ? '(' + before + ')' : '') +
        (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? '\\' : '') +
        pattern.character +
        (after || ''),
      'g'
    )
  }

  return pattern._compiled
}


/***/ }),

/***/ 8850:
/***/ ((module) => {

module.exports = patternInScope

function patternInScope(stack, pattern) {
  return (
    listInScope(stack, pattern.inConstruct, true) &&
    !listInScope(stack, pattern.notInConstruct)
  )
}

function listInScope(stack, list, none) {
  var index

  if (!list) {
    return none
  }

  if (typeof list === 'string') {
    list = [list]
  }

  index = -1

  while (++index < list.length) {
    if (stack.indexOf(list[index]) !== -1) {
      return true
    }
  }

  return false
}


/***/ }),

/***/ 3906:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = safe

var patternCompile = __webpack_require__(4810)
var patternInScope = __webpack_require__(8850)

function safe(context, input, config) {
  var value = (config.before || '') + (input || '') + (config.after || '')
  var positions = []
  var result = []
  var infos = {}
  var index = -1
  var before
  var after
  var position
  var pattern
  var expression
  var match
  var start
  var end

  while (++index < context.unsafe.length) {
    pattern = context.unsafe[index]

    if (!patternInScope(context.stack, pattern)) {
      continue
    }

    expression = patternCompile(pattern)

    while ((match = expression.exec(value))) {
      before = 'before' in pattern || pattern.atBreak
      after = 'after' in pattern

      position = match.index + (before ? match[1].length : 0)

      if (positions.indexOf(position) === -1) {
        positions.push(position)
        infos[position] = {before: before, after: after}
      } else {
        if (infos[position].before && !before) {
          infos[position].before = false
        }

        if (infos[position].after && !after) {
          infos[position].after = false
        }
      }
    }
  }

  positions.sort(numerical)

  start = config.before ? config.before.length : 0
  end = value.length - (config.after ? config.after.length : 0)
  index = -1

  while (++index < positions.length) {
    position = positions[index]

    if (
      // Character before or after matched:
      position < start ||
      position >= end
    ) {
      continue
    }

    // If this character is supposed to be escaped because it has a condition on
    // the next character, and the next character is definitly being escaped,
    // then skip this escape.
    if (
      position + 1 < end &&
      positions[index + 1] === position + 1 &&
      infos[position].after &&
      !infos[position + 1].before &&
      !infos[position + 1].after
    ) {
      continue
    }

    if (start !== position) {
      // If we have to use a character reference, an ampersand would be more
      // correct, but as backslashes only care about punctuation, either will
      // do the trick
      result.push(escapeBackslashes(value.slice(start, position), '\\'))
    }

    start = position

    if (
      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&
      (!config.encode || config.encode.indexOf(value.charAt(position)) === -1)
    ) {
      // Character escape.
      result.push('\\')
    } else {
      // Character reference.
      result.push(
        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'
      )
      start++
    }
  }

  result.push(escapeBackslashes(value.slice(start, end), config.after))

  return result.join('')
}

function numerical(a, b) {
  return a - b
}

function escapeBackslashes(value, after) {
  var expression = /\\(?=[!-/:-@[-`{-~])/g
  var positions = []
  var results = []
  var index = -1
  var start = 0
  var whole = value + after
  var match

  while ((match = expression.exec(whole))) {
    positions.push(match.index)
  }

  while (++index < positions.length) {
    if (start !== positions[index]) {
      results.push(value.slice(start, positions[index]))
    }

    results.push('\\')
    start = positions[index]
  }

  results.push(value.slice(start))

  return results.join('')
}


/***/ }),

/***/ 5789:
/***/ ((module) => {

"use strict";


module.exports = toString

// Get the text content of a node.
// Prefer the node’s plain-text fields, otherwise serialize its children,
// and if the given value is an array, serialize the nodes in it.
function toString(node) {
  return (
    (node &&
      (node.value ||
        node.alt ||
        node.title ||
        ('children' in node && all(node.children)) ||
        ('length' in node && all(node)))) ||
    ''
  )
}

function all(values) {
  var result = []
  var index = -1

  while (++index < values.length) {
    result[index] = toString(values[index])
  }

  return result.join('')
}


/***/ }),

/***/ 5701:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(3083)


/***/ }),

/***/ 8592:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = matters

var fault = __webpack_require__(7335)

var own = {}.hasOwnProperty

var markers = {yaml: '-', toml: '+'}

function matters(options) {
  var settings = options || 'yaml'
  var results = []
  var index = -1
  var length

  // One preset or matter.
  if (typeof settings === 'string' || !('length' in settings)) {
    settings = [settings]
  }

  length = settings.length

  while (++index < length) {
    results[index] = matter(settings[index])
  }

  return results
}

function matter(option) {
  var result = option

  if (typeof result === 'string') {
    if (!own.call(markers, result)) {
      throw fault('Missing matter definition for `%s`', result)
    }

    result = {type: result, marker: markers[result]}
  } else if (typeof result !== 'object') {
    throw fault('Expected matter to be an object, not `%j`', result)
  }

  if (!own.call(result, 'type')) {
    throw fault('Missing `type` in matter `%j`', result)
  }

  if (!own.call(result, 'fence') && !own.call(result, 'marker')) {
    throw fault('Missing `marker` or `fence` in matter `%j`', result)
  }

  return result
}


/***/ }),

/***/ 3083:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = create

var matters = __webpack_require__(8592)

function create(options) {
  var settings = matters(options)
  var length = settings.length
  var index = -1
  var flow = {}
  var matter
  var code

  while (++index < length) {
    matter = settings[index]
    code = fence(matter, 'open').charCodeAt(0)
    if (code in flow) {
      flow[code].push(parse(matter))
    } else {
      flow[code] = [parse(matter)]
    }
  }

  return {flow: flow}
}

function parse(matter) {
  var name = matter.type
  var anywhere = matter.anywhere
  var valueType = name + 'Value'
  var fenceType = name + 'Fence'
  var sequenceType = fenceType + 'Sequence'
  var fenceConstruct = {tokenize: tokenizeFence, partial: true}
  var buffer

  return {tokenize: tokenizeFrontmatter, concrete: true}

  function tokenizeFrontmatter(effects, ok, nok) {
    var self = this

    return start

    function start(code) {
      var position = self.now()

      if (position.column !== 1 || (!anywhere && position.line !== 1)) {
        return nok(code)
      }

      effects.enter(name)
      buffer = fence(matter, 'open')
      return effects.attempt(fenceConstruct, afterOpeningFence, nok)(code)
    }

    function afterOpeningFence(code) {
      buffer = fence(matter, 'close')
      return lineEnd(code)
    }

    function lineStart(code) {
      if (code === -5 || code === -4 || code === -3 || code === null) {
        return lineEnd(code)
      }

      effects.enter(valueType)
      return lineData(code)
    }

    function lineData(code) {
      if (code === -5 || code === -4 || code === -3 || code === null) {
        effects.exit(valueType)
        return lineEnd(code)
      }

      effects.consume(code)
      return lineData
    }

    function lineEnd(code) {
      // Require a closing fence.
      if (code === null) {
        return nok(code)
      }

      // Can only be an eol.
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      return effects.attempt(fenceConstruct, after, lineStart)
    }

    function after(code) {
      effects.exit(name)
      return ok(code)
    }
  }

  function tokenizeFence(effects, ok, nok) {
    var bufferIndex = 0

    return start

    function start(code) {
      if (code === buffer.charCodeAt(bufferIndex)) {
        effects.enter(fenceType)
        effects.enter(sequenceType)
        return insideSequence(code)
      }

      return nok(code)
    }

    function insideSequence(code) {
      if (bufferIndex === buffer.length) {
        effects.exit(sequenceType)

        if (code === -2 || code === -1 || code === 32) {
          effects.enter('whitespace')
          return insideWhitespace(code)
        }

        return fenceEnd(code)
      }

      if (code === buffer.charCodeAt(bufferIndex)) {
        effects.consume(code)
        bufferIndex++
        return insideSequence
      }

      return nok(code)
    }

    function insideWhitespace(code) {
      if (code === -2 || code === -1 || code === 32) {
        effects.consume(code)
        return insideWhitespace
      }

      effects.exit('whitespace')
      return fenceEnd(code)
    }

    function fenceEnd(code) {
      if (code === -5 || code === -4 || code === -3 || code === null) {
        effects.exit(fenceType)
        return ok(code)
      }

      return nok(code)
    }
  }
}

function fence(matter, prop) {
  var marker

  if (matter.marker) {
    marker = pick(matter.marker, prop)
    return marker + marker + marker
  }

  return pick(matter.fence, prop)
}

function pick(schema, prop) {
  return typeof schema === 'string' ? schema : schema[prop]
}


/***/ }),

/***/ 7321:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(2007)


/***/ }),

/***/ 2007:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var asciiAlpha = __webpack_require__(3847)
var asciiAlphanumeric = __webpack_require__(598)
var asciiControl = __webpack_require__(1336)
var markdownLineEnding = __webpack_require__(7506)
var unicodePunctuation = __webpack_require__(9372)
var unicodeWhitespace = __webpack_require__(9968)

var www = {tokenize: tokenizeWww, partial: true}
var domain = {tokenize: tokenizeDomain, partial: true}
var path = {tokenize: tokenizePath, partial: true}
var punctuation = {tokenize: tokenizePunctuation, partial: true}
var paren = {tokenize: tokenizeParen, partial: true}
var namedCharacterReference = {
  tokenize: tokenizeNamedCharacterReference,
  partial: true
}

var wwwAutolink = {tokenize: tokenizeWwwAutolink, previous: previousWww}
var httpAutolink = {tokenize: tokenizeHttpAutolink, previous: previousHttp}
var emailAutolink = {tokenize: tokenizeEmailAutolink, previous: previousEmail}

var text = {}

// Export hooked constructs.
exports.text = text

// `0`
var code = 48

// While the code is smaller than `{`.
while (code < 123) {
  text[code] = emailAutolink
  code++
  // Jump from `:` -> `A`
  if (code === 58) code = 65
  // Jump from `[` -> `a`
  else if (code === 91) code = 97
}

// `+`
text[43] = emailAutolink
// `-`
text[45] = emailAutolink
// `.`
text[46] = emailAutolink
// `_`
text[95] = emailAutolink
// `h`.
text[72] = [emailAutolink, httpAutolink]
text[104] = [emailAutolink, httpAutolink]
// `w`.
text[87] = [emailAutolink, wwwAutolink]
text[119] = [emailAutolink, wwwAutolink]

function tokenizeEmailAutolink(effects, ok, nok) {
  var self = this
  var hasDot

  return start

  function start(code) {
    /* istanbul ignore next - hooks. */
    if (
      !gfmAtext(code) ||
      !previousEmail(self.previous) ||
      previous(self.events)
    ) {
      return nok(code)
    }

    effects.enter('literalAutolink')
    effects.enter('literalAutolinkEmail')
    return atext(code)
  }

  function atext(code) {
    if (gfmAtext(code)) {
      effects.consume(code)
      return atext
    }

    // `@`
    if (code === 64) {
      effects.consume(code)
      return label
    }

    return nok(code)
  }

  function label(code) {
    // `.`
    if (code === 46) {
      return effects.check(punctuation, done, dotContinuation)(code)
    }

    if (
      // `-`
      code === 45 ||
      // `_`
      code === 95
    ) {
      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code)
    }

    if (asciiAlphanumeric(code)) {
      effects.consume(code)
      return label
    }

    return done(code)
  }

  function dotContinuation(code) {
    effects.consume(code)
    hasDot = true
    return label
  }

  function dashOrUnderscoreContinuation(code) {
    effects.consume(code)
    return afterDashOrUnderscore
  }

  function afterDashOrUnderscore(code) {
    // `.`
    if (code === 46) {
      return effects.check(punctuation, nok, dotContinuation)(code)
    }

    return label(code)
  }

  function done(code) {
    if (hasDot) {
      effects.exit('literalAutolinkEmail')
      effects.exit('literalAutolink')
      return ok(code)
    }

    return nok(code)
  }
}

function tokenizeWwwAutolink(effects, ok, nok) {
  var self = this

  return start

  function start(code) {
    /* istanbul ignore next - hooks. */
    if (
      (code !== 87 && code - 32 !== 87) ||
      !previousWww(self.previous) ||
      previous(self.events)
    ) {
      return nok(code)
    }

    effects.enter('literalAutolink')
    effects.enter('literalAutolinkWww')
    // For `www.` we check instead of attempt, because when it matches, GH
    // treats it as part of a domain (yes, it says a valid domain must come
    // after `www.`, but that’s not how it’s implemented by them).
    return effects.check(
      www,
      effects.attempt(domain, effects.attempt(path, done), nok),
      nok
    )(code)
  }

  function done(code) {
    effects.exit('literalAutolinkWww')
    effects.exit('literalAutolink')
    return ok(code)
  }
}

function tokenizeHttpAutolink(effects, ok, nok) {
  var self = this

  return start

  function start(code) {
    /* istanbul ignore next - hooks. */
    if (
      (code !== 72 && code - 32 !== 72) ||
      !previousHttp(self.previous) ||
      previous(self.events)
    ) {
      return nok(code)
    }

    effects.enter('literalAutolink')
    effects.enter('literalAutolinkHttp')
    effects.consume(code)
    return t1
  }

  function t1(code) {
    // `t`
    if (code === 84 || code - 32 === 84) {
      effects.consume(code)
      return t2
    }

    return nok(code)
  }

  function t2(code) {
    // `t`
    if (code === 84 || code - 32 === 84) {
      effects.consume(code)
      return p
    }

    return nok(code)
  }

  function p(code) {
    // `p`
    if (code === 80 || code - 32 === 80) {
      effects.consume(code)
      return s
    }

    return nok(code)
  }

  function s(code) {
    // `s`
    if (code === 83 || code - 32 === 83) {
      effects.consume(code)
      return colon
    }

    return colon(code)
  }

  function colon(code) {
    // `:`
    if (code === 58) {
      effects.consume(code)
      return slash1
    }

    return nok(code)
  }

  function slash1(code) {
    // `/`
    if (code === 47) {
      effects.consume(code)
      return slash2
    }

    return nok(code)
  }

  function slash2(code) {
    // `/`
    if (code === 47) {
      effects.consume(code)
      return after
    }

    return nok(code)
  }

  function after(code) {
    return asciiControl(code) ||
      unicodeWhitespace(code) ||
      unicodePunctuation(code)
      ? nok(code)
      : effects.attempt(domain, effects.attempt(path, done), nok)(code)
  }

  function done(code) {
    effects.exit('literalAutolinkHttp')
    effects.exit('literalAutolink')
    return ok(code)
  }
}

function tokenizeWww(effects, ok, nok) {
  return start

  function start(code) {
    // Assume a `w`.
    effects.consume(code)
    return w2
  }

  function w2(code) {
    // `w`
    if (code === 87 || code - 32 === 87) {
      effects.consume(code)
      return w3
    }

    return nok(code)
  }

  function w3(code) {
    // `w`
    if (code === 87 || code - 32 === 87) {
      effects.consume(code)
      return dot
    }

    return nok(code)
  }

  function dot(code) {
    // `.`
    if (code === 46) {
      effects.consume(code)
      return after
    }

    return nok(code)
  }

  function after(code) {
    return code === null || markdownLineEnding(code) ? nok(code) : ok(code)
  }
}

function tokenizeDomain(effects, ok, nok) {
  var hasUnderscoreInLastSegment
  var hasUnderscoreInLastLastSegment

  return domain

  function domain(code) {
    // `&`
    if (code === 38) {
      return effects.check(
        namedCharacterReference,
        done,
        punctuationContinuation
      )(code)
    }

    if (code === 46 /* `.` */ || code === 95 /* `_` */) {
      return effects.check(punctuation, done, punctuationContinuation)(code)
    }

    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can
    // occur, which sounds like ASCII only, but they also support `www.點看.com`,
    // so that’s Unicode.
    // Instead of some new production for Unicode alphanumerics, markdown
    // already has that for Unicode punctuation and whitespace, so use those.
    if (
      asciiControl(code) ||
      unicodeWhitespace(code) ||
      (code !== 45 /* `-` */ && unicodePunctuation(code))
    ) {
      return done(code)
    }

    effects.consume(code)
    return domain
  }

  function punctuationContinuation(code) {
    // `.`
    if (code === 46) {
      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment
      hasUnderscoreInLastSegment = undefined
      effects.consume(code)
      return domain
    }

    // `_`
    if (code === 95) hasUnderscoreInLastSegment = true

    effects.consume(code)
    return domain
  }

  function done(code) {
    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {
      return ok(code)
    }

    return nok(code)
  }
}

function tokenizePath(effects, ok) {
  var balance = 0

  return inPath

  function inPath(code) {
    // `&`
    if (code === 38) {
      return effects.check(
        namedCharacterReference,
        ok,
        continuedPunctuation
      )(code)
    }

    // `(`
    if (code === 40) {
      balance++
    }

    // `)`
    if (code === 41) {
      return effects.check(paren, parenAtPathEnd, continuedPunctuation)(code)
    }

    if (pathEnd(code)) {
      return ok(code)
    }

    if (trailingPunctuation(code)) {
      return effects.check(punctuation, ok, continuedPunctuation)(code)
    }

    effects.consume(code)
    return inPath
  }

  function continuedPunctuation(code) {
    effects.consume(code)
    return inPath
  }

  function parenAtPathEnd(code) {
    balance--
    return balance < 0 ? ok(code) : continuedPunctuation(code)
  }
}

function tokenizeNamedCharacterReference(effects, ok, nok) {
  return start

  function start(code) {
    // Assume an ampersand.
    effects.consume(code)
    return inside
  }

  function inside(code) {
    if (asciiAlpha(code)) {
      effects.consume(code)
      return inside
    }

    // `;`
    if (code === 59) {
      effects.consume(code)
      return after
    }

    return nok(code)
  }

  function after(code) {
    // If the named character reference is followed by the end of the path, it’s
    // not continued punctuation.
    return pathEnd(code) ? ok(code) : nok(code)
  }
}

function tokenizeParen(effects, ok, nok) {
  return start

  function start(code) {
    // Assume a right paren.
    effects.consume(code)
    return after
  }

  function after(code) {
    // If the punctuation marker is followed by the end of the path, it’s not
    // continued punctuation.
    return pathEnd(code) ||
      // `)`
      code === 41
      ? ok(code)
      : nok(code)
  }
}

function tokenizePunctuation(effects, ok, nok) {
  return start

  function start(code) {
    // Always a valid trailing punctuation marker.
    effects.consume(code)
    return after
  }

  function after(code) {
    // Check the next.
    if (trailingPunctuation(code)) {
      effects.consume(code)
      return after
    }

    // If the punctuation marker is followed by the end of the path, it’s not
    // continued punctuation.
    return pathEnd(code) ? ok(code) : nok(code)
  }
}

function trailingPunctuation(code) {
  return (
    // `!`
    code === 33 ||
    // `"`
    code === 34 ||
    // `'`
    code === 39 ||
    // `)`
    code === 41 ||
    // `*`
    code === 42 ||
    // `,`
    code === 44 ||
    // `.`
    code === 46 ||
    // `:`
    code === 58 ||
    // `;`
    code === 59 ||
    // `<`
    code === 60 ||
    // `?`
    code === 63 ||
    // `_`.
    code === 95 ||
    // `~`
    code === 126
  )
}

function pathEnd(code) {
  return (
    // EOF.
    code === null ||
    // CR, LF, CRLF, HT, VS.
    code < 0 ||
    // Space.
    code === 32 ||
    // `<`
    code === 60
  )
}

function gfmAtext(code) {
  return (
    code === 43 /* `+` */ ||
    code === 45 /* `-` */ ||
    code === 46 /* `.` */ ||
    code === 95 /* `_` */ ||
    asciiAlphanumeric(code)
  )
}

function previousWww(code) {
  return (
    code === null ||
    code < 0 ||
    code === 32 /* ` ` */ ||
    code === 40 /* `(` */ ||
    code === 42 /* `*` */ ||
    code === 95 /* `_` */ ||
    code === 126 /* `~` */
  )
}

function previousHttp(code) {
  return code === null || !asciiAlpha(code)
}

function previousEmail(code) {
  return code !== 47 /* `/` */ && previousHttp(code)
}

function previous(events) {
  var index = events.length

  while (index--) {
    if (
      (events[index][1].type === 'labelLink' ||
        events[index][1].type === 'labelImage') &&
      !events[index][1]._balanced
    ) {
      return true
    }
  }
}


/***/ }),

/***/ 7119:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = create

var classifyCharacter = __webpack_require__(1324)
var chunkedSplice = __webpack_require__(778)
var resolveAll = __webpack_require__(2004)
var shallow = __webpack_require__(1479)

function create(options) {
  var settings = options || {}
  var single = settings.singleTilde
  var tokenizer = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  }

  if (single === null || single === undefined) {
    single = true
  }

  return {text: {126: tokenizer}, insideSpan: {null: tokenizer}}

  // Take events and resolve strikethrough.
  function resolveAllStrikethrough(events, context) {
    var index = -1
    var strikethrough
    var text
    var open
    var nextEvents

    // Walk through all events.
    while (++index < events.length) {
      // Find a token that can close.
      if (
        events[index][0] === 'enter' &&
        events[index][1].type === 'strikethroughSequenceTemporary' &&
        events[index][1]._close
      ) {
        open = index

        // Now walk back to find an opener.
        while (open--) {
          // Find a token that can open the closer.
          if (
            events[open][0] === 'exit' &&
            events[open][1].type === 'strikethroughSequenceTemporary' &&
            events[open][1]._open &&
            // If the sizes are the same:
            events[index][1].end.offset - events[index][1].start.offset ===
              events[open][1].end.offset - events[open][1].start.offset
          ) {
            events[index][1].type = 'strikethroughSequence'
            events[open][1].type = 'strikethroughSequence'

            strikethrough = {
              type: 'strikethrough',
              start: shallow(events[open][1].start),
              end: shallow(events[index][1].end)
            }

            text = {
              type: 'strikethroughText',
              start: shallow(events[open][1].end),
              end: shallow(events[index][1].start)
            }

            // Opening.
            nextEvents = [
              ['enter', strikethrough, context],
              ['enter', events[open][1], context],
              ['exit', events[open][1], context],
              ['enter', text, context]
            ]

            // Between.
            chunkedSplice(
              nextEvents,
              nextEvents.length,
              0,
              resolveAll(
                context.parser.constructs.insideSpan.null,
                events.slice(open + 1, index),
                context
              )
            )

            // Closing.
            chunkedSplice(nextEvents, nextEvents.length, 0, [
              ['exit', text, context],
              ['enter', events[index][1], context],
              ['exit', events[index][1], context],
              ['exit', strikethrough, context]
            ])

            chunkedSplice(events, open - 1, index - open + 3, nextEvents)

            index = open + nextEvents.length - 2
            break
          }
        }
      }
    }

    return removeRemainingSequences(events)
  }

  function removeRemainingSequences(events) {
    var index = -1
    var length = events.length

    while (++index < length) {
      if (events[index][1].type === 'strikethroughSequenceTemporary') {
        events[index][1].type = 'data'
      }
    }

    return events
  }

  function tokenizeStrikethrough(effects, ok, nok) {
    var previous = this.previous
    var events = this.events
    var size = 0

    return start

    function start(code) {
      if (
        code !== 126 ||
        (previous === 126 &&
          events[events.length - 1][1].type !== 'characterEscape')
      ) {
        return nok(code)
      }

      effects.enter('strikethroughSequenceTemporary')
      return more(code)
    }

    function more(code) {
      var before = classifyCharacter(previous)
      var token
      var after

      if (code === 126) {
        // If this is the third marker, exit.
        if (size > 1) return nok(code)
        effects.consume(code)
        size++
        return more
      }

      if (size < 2 && !single) return nok(code)
      token = effects.exit('strikethroughSequenceTemporary')
      after = classifyCharacter(code)
      token._open = !after || (after === 2 && before)
      token._close = !before || (before === 2 && after)
      return ok(code)
    }
  }
}


/***/ }),

/***/ 7200:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(2743)


/***/ }),

/***/ 2743:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.flow = {
  null: {tokenize: tokenizeTable, resolve: resolveTable, interruptible: true}
}

var createSpace = __webpack_require__(8200)

var setextUnderlineMini = {tokenize: tokenizeSetextUnderlineMini, partial: true}
var nextPrefixedOrBlank = {tokenize: tokenizeNextPrefixedOrBlank, partial: true}

function resolveTable(events, context) {
  var length = events.length
  var index = -1
  var token
  var inHead
  var inDelimiterRow
  var inRow
  var cell
  var content
  var text
  var contentStart
  var contentEnd
  var cellStart

  while (++index < length) {
    token = events[index][1]

    if (inRow) {
      if (token.type === 'temporaryTableCellContent') {
        contentStart = contentStart || index
        contentEnd = index
      }

      if (
        // Combine separate content parts into one.
        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&
        contentEnd
      ) {
        content = {
          type: 'tableContent',
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end
        }
        text = {
          type: 'chunkText',
          start: content.start,
          end: content.end,
          contentType: 'text'
        }

        events.splice(
          contentStart,
          contentEnd - contentStart + 1,
          ['enter', content, context],
          ['enter', text, context],
          ['exit', text, context],
          ['exit', content, context]
        )
        index -= contentEnd - contentStart - 3
        length = events.length
        contentStart = undefined
        contentEnd = undefined
      }
    }

    if (
      events[index][0] === 'exit' &&
      cellStart &&
      cellStart + 1 < index &&
      (token.type === 'tableCellDivider' ||
        (token.type === 'tableRow' &&
          (cellStart + 3 < index ||
            events[cellStart][1].type !== 'whitespace')))
    ) {
      cell = {
        type: inDelimiterRow
          ? 'tableDelimiter'
          : inHead
          ? 'tableHeader'
          : 'tableData',
        start: events[cellStart][1].start,
        end: events[index][1].end
      }
      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [
        'exit',
        cell,
        context
      ])
      events.splice(cellStart, 0, ['enter', cell, context])
      index += 2
      length = events.length
      cellStart = index + 1
    }

    if (token.type === 'tableRow') {
      inRow = events[index][0] === 'enter'

      if (inRow) {
        cellStart = index + 1
      }
    }

    if (token.type === 'tableDelimiterRow') {
      inDelimiterRow = events[index][0] === 'enter'

      if (inDelimiterRow) {
        cellStart = index + 1
      }
    }

    if (token.type === 'tableHead') {
      inHead = events[index][0] === 'enter'
    }
  }

  return events
}

function tokenizeTable(effects, ok, nok) {
  var align = []
  var tableHeaderCount = 0
  var seenDelimiter
  var hasDash

  return start

  function start(code) {
    /* istanbul ignore if - used to be passed in beta micromark versions. */
    if (code === null || code === -5 || code === -4 || code === -3) {
      return nok(code)
    }

    effects.enter('table')._align = align
    effects.enter('tableHead')
    effects.enter('tableRow')

    // If we start with a pipe, we open a cell marker.
    if (code === 124) {
      return cellDividerHead(code)
    }

    tableHeaderCount++
    effects.enter('temporaryTableCellContent')
    // Can’t be space or eols at the start of a construct, so we’re in a cell.
    return inCellContentHead(code)
  }

  function cellDividerHead(code) {
    // Always a pipe.
    effects.enter('tableCellDivider')
    effects.consume(code)
    effects.exit('tableCellDivider')
    seenDelimiter = true
    return cellBreakHead
  }

  function cellBreakHead(code) {
    // EOF, CR, LF, CRLF.
    if (code === null || code === -5 || code === -4 || code === -3) {
      return atRowEndHead(code)
    }

    // HT, VS, SP.
    if (code === -2 || code === -1 || code === 32) {
      effects.enter('whitespace')
      effects.consume(code)
      return inWhitespaceHead
    }

    if (seenDelimiter) {
      seenDelimiter = undefined
      tableHeaderCount++
    }

    // `|`
    if (code === 124) {
      return cellDividerHead(code)
    }

    // Anything else is cell content.
    effects.enter('temporaryTableCellContent')
    return inCellContentHead(code)
  }

  function inWhitespaceHead(code) {
    // HT, VS, SP.
    if (code === -2 || code === -1 || code === 32) {
      effects.consume(code)
      return inWhitespaceHead
    }

    effects.exit('whitespace')
    return cellBreakHead(code)
  }

  function inCellContentHead(code) {
    // EOF, whitespace, pipe
    if (code === null || code < 0 || code === 32 || code === 124) {
      effects.exit('temporaryTableCellContent')
      return cellBreakHead(code)
    }

    effects.consume(code)
    // `\`
    return code === 92 ? inCellContentEscapeHead : inCellContentHead
  }

  function inCellContentEscapeHead(code) {
    // `\` or `|`
    if (code === 92 || code === 124) {
      effects.consume(code)
      return inCellContentHead
    }

    // Anything else.
    return inCellContentHead(code)
  }

  function atRowEndHead(code) {
    if (code === null) {
      return nok(code)
    }

    effects.exit('tableRow')
    effects.exit('tableHead')

    // Always a line ending.
    effects.enter('lineEnding')
    effects.consume(code)
    effects.exit('lineEnding')

    // If a setext heading, exit.
    return effects.check(
      setextUnderlineMini,
      nok,
      // Support an indent before the delimiter row.
      createSpace(effects, rowStartDelimiter, 'linePrefix', 4)
    )
  }

  function rowStartDelimiter(code) {
    // If there’s another space, or we’re at the EOL/EOF, exit.
    if (code === null || code < 0 || code === 32) {
      return nok(code)
    }

    effects.enter('tableDelimiterRow')
    return atDelimiterRowBreak(code)
  }

  function atDelimiterRowBreak(code) {
    // EOF, CR, LF, CRLF.
    if (code === null || code === -5 || code === -4 || code === -3) {
      return rowEndDelimiter(code)
    }

    // HT, VS, SP.
    if (code === -2 || code === -1 || code === 32) {
      effects.enter('whitespace')
      effects.consume(code)
      return inWhitespaceDelimiter
    }

    // `-`
    if (code === 45) {
      effects.enter('tableDelimiterFiller')
      effects.consume(code)
      hasDash = true
      align.push(null)
      return inFillerDelimiter
    }

    // `:`
    if (code === 58) {
      effects.enter('tableDelimiterAlignment')
      effects.consume(code)
      effects.exit('tableDelimiterAlignment')
      align.push('left')
      return afterLeftAlignment
    }

    // If we start with a pipe, we open a cell marker.
    if (code === 124) {
      effects.enter('tableCellDivider')
      effects.consume(code)
      effects.exit('tableCellDivider')
      return atDelimiterRowBreak
    }

    return nok(code)
  }

  function inWhitespaceDelimiter(code) {
    // HT, VS, SP.
    if (code === -2 || code === -1 || code === 32) {
      effects.consume(code)
      return inWhitespaceDelimiter
    }

    effects.exit('whitespace')
    return atDelimiterRowBreak(code)
  }

  function inFillerDelimiter(code) {
    // `-`
    if (code === 45) {
      effects.consume(code)
      return inFillerDelimiter
    }

    effects.exit('tableDelimiterFiller')

    // `:`
    if (code === 58) {
      effects.enter('tableDelimiterAlignment')
      effects.consume(code)
      effects.exit('tableDelimiterAlignment')

      align[align.length - 1] =
        align[align.length - 1] === 'left' ? 'center' : 'right'

      return afterRightAlignment
    }

    return atDelimiterRowBreak(code)
  }

  function afterLeftAlignment(code) {
    // `-`
    if (code === 45) {
      effects.enter('tableDelimiterFiller')
      effects.consume(code)
      hasDash = true
      return inFillerDelimiter
    }

    // Anything else is not ok.
    return nok(code)
  }

  function afterRightAlignment(code) {
    // EOF, CR, LF, CRLF.
    if (code === null || code === -5 || code === -4 || code === -3) {
      return rowEndDelimiter(code)
    }

    // HT, VS, SP.
    if (code === -2 || code === -1 || code === 32) {
      effects.enter('whitespace')
      effects.consume(code)
      return inWhitespaceDelimiter
    }

    // `|`
    if (code === 124) {
      effects.enter('tableCellDivider')
      effects.consume(code)
      effects.exit('tableCellDivider')
      return atDelimiterRowBreak
    }

    return nok(code)
  }

  function rowEndDelimiter(code) {
    effects.exit('tableDelimiterRow')

    // Exit if there was no dash at all, or if the header cell count is not the
    // delimiter cell count.
    if (!hasDash || tableHeaderCount !== align.length) {
      return nok(code)
    }

    if (code === null) {
      return tableClose(code)
    }

    return effects.check(nextPrefixedOrBlank, tableClose, tableContinue)(code)
  }

  function tableClose(code) {
    effects.exit('table')
    return ok(code)
  }

  function tableContinue(code) {
    // Always a line ending.
    effects.enter('lineEnding')
    effects.consume(code)
    effects.exit('lineEnding')
    // We checked that it’s not a prefixed or blank line, so we’re certain a
    // body is coming, though it may be indented.
    return createSpace(effects, bodyStart, 'linePrefix', 4)
  }

  function bodyStart(code) {
    effects.enter('tableBody')
    return rowStartBody(code)
  }

  function rowStartBody(code) {
    effects.enter('tableRow')

    // If we start with a pipe, we open a cell marker.
    if (code === 124) {
      return cellDividerBody(code)
    }

    effects.enter('temporaryTableCellContent')
    // Can’t be space or eols at the start of a construct, so we’re in a cell.
    return inCellContentBody(code)
  }

  function cellDividerBody(code) {
    // Always a pipe.
    effects.enter('tableCellDivider')
    effects.consume(code)
    effects.exit('tableCellDivider')
    return cellBreakBody
  }

  function cellBreakBody(code) {
    // EOF, CR, LF, CRLF.
    if (code === null || code === -5 || code === -4 || code === -3) {
      return atRowEndBody(code)
    }

    // HT, VS, SP.
    if (code === -2 || code === -1 || code === 32) {
      effects.enter('whitespace')
      effects.consume(code)
      return inWhitespaceBody
    }

    // `|`
    if (code === 124) {
      return cellDividerBody(code)
    }

    // Anything else is cell content.
    effects.enter('temporaryTableCellContent')
    return inCellContentBody(code)
  }

  function inWhitespaceBody(code) {
    // HT, VS, SP.
    if (code === -2 || code === -1 || code === 32) {
      effects.consume(code)
      return inWhitespaceBody
    }

    effects.exit('whitespace')
    return cellBreakBody(code)
  }

  function inCellContentBody(code) {
    // EOF, whitespace, pipe
    if (code === null || code < 0 || code === 32 || code === 124) {
      effects.exit('temporaryTableCellContent')
      return cellBreakBody(code)
    }

    effects.consume(code)
    // `\`
    return code === 92 ? inCellContentEscapeBody : inCellContentBody
  }

  function inCellContentEscapeBody(code) {
    // `\` or `|`
    if (code === 92 || code === 124) {
      effects.consume(code)
      return inCellContentBody
    }

    // Anything else.
    return inCellContentBody(code)
  }

  function atRowEndBody(code) {
    effects.exit('tableRow')

    if (code === null) {
      return tableBodyClose(code)
    }

    return effects.check(
      nextPrefixedOrBlank,
      tableBodyClose,
      tableBodyContinue
    )(code)
  }

  function tableBodyClose(code) {
    effects.exit('tableBody')
    return tableClose(code)
  }

  function tableBodyContinue(code) {
    // Always a line ending.
    effects.enter('lineEnding')
    effects.consume(code)
    effects.exit('lineEnding')
    // Support an optional prefix, then start a body row.
    return createSpace(effects, rowStartBody, 'linePrefix', 4)
  }
}

// Based on micromark, but that won’t work as we’re in a table, and that expects
// content.
// <https://github.com/micromark/micromark/blob/main/lib/tokenize/setext-underline.js>
function tokenizeSetextUnderlineMini(effects, ok, nok) {
  return start

  function start(code) {
    // `-`
    if (code !== 45) {
      return nok(code)
    }

    effects.enter('setextUnderline')
    return sequence(code)
  }

  function sequence(code) {
    if (code === 45) {
      effects.consume(code)
      return sequence
    }

    return whitespace(code)
  }

  function whitespace(code) {
    if (code === -2 || code === -1 || code === 32) {
      effects.consume(code)
      return whitespace
    }

    if (code === null || code === -5 || code === -4 || code === -3) {
      return ok(code)
    }

    return nok(code)
  }
}

function tokenizeNextPrefixedOrBlank(effects, ok, nok) {
  var size = 0

  return start

  function start(code) {
    // This is a check, so we don’t care about tokens, but we open a bogus one
    // so we’re valid.
    effects.enter('check')
    // EOL.
    effects.consume(code)
    return whitespace
  }

  function whitespace(code) {
    // VS or SP.
    if (code === -1 || code === 32) {
      effects.consume(code)
      size++
      return size === 4 ? ok : whitespace
    }

    // EOF or whitespace
    if (code === null || code < 0) {
      return ok(code)
    }

    // Anything else.
    return nok(code)
  }
}


/***/ }),

/***/ 2801:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(3867)


/***/ }),

/***/ 3867:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var markdownLineEndingOrSpace = __webpack_require__(9180)
var spaceFactory = __webpack_require__(8200)
var prefixSize = __webpack_require__(3722)

var tasklistCheck = {tokenize: tokenizeTasklistCheck}

exports.text = {91: tasklistCheck}

function tokenizeTasklistCheck(effects, ok, nok) {
  var self = this

  return open

  function open(code) {
    if (
      // Exit if not `[`.
      code !== 91 ||
      // Exit if there’s stuff before.
      self.previous !== null ||
      // Exit if not in the first content that is the first child of a list
      // item.
      !self._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code)
    }

    effects.enter('taskListCheck')
    effects.enter('taskListCheckMarker')
    effects.consume(code)
    effects.exit('taskListCheckMarker')
    return inside
  }

  function inside(code) {
    // Tab or space.
    if (code === -2 || code === 32) {
      effects.enter('taskListCheckValueUnchecked')
      effects.consume(code)
      effects.exit('taskListCheckValueUnchecked')
      return close
    }

    // Upper- and lower `x`.
    if (code === 88 || code === 120) {
      effects.enter('taskListCheckValueChecked')
      effects.consume(code)
      effects.exit('taskListCheckValueChecked')
      return close
    }

    return nok(code)
  }

  function close(code) {
    // `]`
    if (code === 93) {
      effects.enter('taskListCheckMarker')
      effects.consume(code)
      effects.exit('taskListCheckMarker')
      effects.exit('taskListCheck')
      return effects.check({tokenize: spaceThenNonSpace}, ok, nok)
    }

    return nok(code)
  }
}

function spaceThenNonSpace(effects, ok, nok) {
  var self = this

  return spaceFactory(effects, after, 'whitespace')

  function after(code) {
    return prefixSize(self.events, 'whitespace') &&
      code !== null &&
      !markdownLineEndingOrSpace(code)
      ? ok(code)
      : nok(code)
  }
}


/***/ }),

/***/ 6083:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(6796)


/***/ }),

/***/ 6796:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var combine = __webpack_require__(8602)
var autolink = __webpack_require__(7321)
var strikethrough = __webpack_require__(7119)
var table = __webpack_require__(7200)
var tasklist = __webpack_require__(2801)

module.exports = create

function create(options) {
  return combine([autolink, strikethrough(options), table, tasklist])
}


/***/ }),

/***/ 3847:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexCheck = __webpack_require__(1028)

var asciiAlpha = regexCheck(/[A-Za-z]/)

module.exports = asciiAlpha


/***/ }),

/***/ 598:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexCheck = __webpack_require__(1028)

var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/)

module.exports = asciiAlphanumeric


/***/ }),

/***/ 245:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexCheck = __webpack_require__(1028)

var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/)

module.exports = asciiAtext


/***/ }),

/***/ 1336:
/***/ ((module) => {

"use strict";


// Note: EOF is seen as ASCII control here, because `null < 32 == true`.
function asciiControl(code) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code < 32 || code === 127
  )
}

module.exports = asciiControl


/***/ }),

/***/ 6996:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexCheck = __webpack_require__(1028)

var asciiDigit = regexCheck(/\d/)

module.exports = asciiDigit


/***/ }),

/***/ 6526:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexCheck = __webpack_require__(1028)

var asciiHexDigit = regexCheck(/[\dA-Fa-f]/)

module.exports = asciiHexDigit


/***/ }),

/***/ 7909:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexCheck = __webpack_require__(1028)

var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)

module.exports = asciiPunctuation


/***/ }),

/***/ 9180:
/***/ ((module) => {

"use strict";


function markdownLineEndingOrSpace(code) {
  return code < 0 || code === 32
}

module.exports = markdownLineEndingOrSpace


/***/ }),

/***/ 7506:
/***/ ((module) => {

"use strict";


function markdownLineEnding(code) {
  return code < -2
}

module.exports = markdownLineEnding


/***/ }),

/***/ 5989:
/***/ ((module) => {

"use strict";


function markdownSpace(code) {
  return code === -2 || code === -1 || code === 32
}

module.exports = markdownSpace


/***/ }),

/***/ 9372:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var unicodePunctuationRegex = __webpack_require__(9994)
var regexCheck = __webpack_require__(1028)

// In fact adds to the bundle size.

var unicodePunctuation = regexCheck(unicodePunctuationRegex)

module.exports = unicodePunctuation


/***/ }),

/***/ 9968:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexCheck = __webpack_require__(1028)

var unicodeWhitespace = regexCheck(/\s/)

module.exports = unicodeWhitespace


/***/ }),

/***/ 3512:
/***/ ((module) => {

"use strict";


var assign = Object.assign

module.exports = assign


/***/ }),

/***/ 3531:
/***/ ((module) => {

"use strict";


var fromCharCode = String.fromCharCode

module.exports = fromCharCode


/***/ }),

/***/ 3500:
/***/ ((module) => {

"use strict";


var own = {}.hasOwnProperty

module.exports = own


/***/ }),

/***/ 5159:
/***/ ((module) => {

"use strict";


// This module is copied from <https://spec.commonmark.org/0.29/#html-blocks>.
var basics = [
  'address',
  'article',
  'aside',
  'base',
  'basefont',
  'blockquote',
  'body',
  'caption',
  'center',
  'col',
  'colgroup',
  'dd',
  'details',
  'dialog',
  'dir',
  'div',
  'dl',
  'dt',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'frame',
  'frameset',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'head',
  'header',
  'hr',
  'html',
  'iframe',
  'legend',
  'li',
  'link',
  'main',
  'menu',
  'menuitem',
  'nav',
  'noframes',
  'ol',
  'optgroup',
  'option',
  'p',
  'param',
  'section',
  'source',
  'summary',
  'table',
  'tbody',
  'td',
  'tfoot',
  'th',
  'thead',
  'title',
  'tr',
  'track',
  'ul'
]

module.exports = basics


/***/ }),

/***/ 4677:
/***/ ((module) => {

"use strict";


// This module is copied from <https://spec.commonmark.org/0.29/#html-blocks>.
var raws = ['pre', 'script', 'style', 'textarea']

module.exports = raws


/***/ }),

/***/ 2366:
/***/ ((module) => {

"use strict";


var splice = [].splice

module.exports = splice


/***/ }),

/***/ 9994:
/***/ ((module) => {

"use strict";


// This module is generated by `script/`.
//
// CommonMark handles attention (emphasis, strong) markers based on what comes
// before or after them.
// One such difference is if those characters are Unicode punctuation.
// This script is generated from the Unicode data.
var unicodePunctuation = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/

module.exports = unicodePunctuation


/***/ }),

/***/ 289:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({value: true}))

var text$1 = __webpack_require__(7492)
var attention = __webpack_require__(2116)
var autolink = __webpack_require__(6681)
var blockQuote = __webpack_require__(9025)
var characterEscape = __webpack_require__(7128)
var characterReference = __webpack_require__(9500)
var codeFenced = __webpack_require__(3268)
var codeIndented = __webpack_require__(907)
var codeText = __webpack_require__(7033)
var definition = __webpack_require__(1193)
var hardBreakEscape = __webpack_require__(7608)
var headingAtx = __webpack_require__(4558)
var htmlFlow = __webpack_require__(6791)
var htmlText = __webpack_require__(7743)
var labelEnd = __webpack_require__(9797)
var labelStartImage = __webpack_require__(7860)
var labelStartLink = __webpack_require__(5908)
var lineEnding = __webpack_require__(5183)
var list = __webpack_require__(3107)
var setextUnderline = __webpack_require__(1196)
var thematicBreak = __webpack_require__(5590)

var document = {
  42: list,
  // Asterisk
  43: list,
  // Plus sign
  45: list,
  // Dash
  48: list,
  // 0
  49: list,
  // 1
  50: list,
  // 2
  51: list,
  // 3
  52: list,
  // 4
  53: list,
  // 5
  54: list,
  // 6
  55: list,
  // 7
  56: list,
  // 8
  57: list,
  // 9
  62: blockQuote // Greater than
}
var contentInitial = {
  91: definition // Left square bracket
}
var flowInitial = {
  '-2': codeIndented,
  // Horizontal tab
  '-1': codeIndented,
  // Virtual space
  32: codeIndented // Space
}
var flow = {
  35: headingAtx,
  // Number sign
  42: thematicBreak,
  // Asterisk
  45: [setextUnderline, thematicBreak],
  // Dash
  60: htmlFlow,
  // Less than
  61: setextUnderline,
  // Equals to
  95: thematicBreak,
  // Underscore
  96: codeFenced,
  // Grave accent
  126: codeFenced // Tilde
}
var string = {
  38: characterReference,
  // Ampersand
  92: characterEscape // Backslash
}
var text = {
  '-5': lineEnding,
  // Carriage return
  '-4': lineEnding,
  // Line feed
  '-3': lineEnding,
  // Carriage return + line feed
  33: labelStartImage,
  // Exclamation mark
  38: characterReference,
  // Ampersand
  42: attention,
  // Asterisk
  60: [autolink, htmlText],
  // Less than
  91: labelStartLink,
  // Left square bracket
  92: [hardBreakEscape, characterEscape],
  // Backslash
  93: labelEnd,
  // Right square bracket
  95: attention,
  // Underscore
  96: codeText // Grave accent
}
var insideSpan = {
  null: [attention, text$1.resolver]
}
var disable = {
  null: []
}

exports.contentInitial = contentInitial
exports.disable = disable
exports.document = document
exports.flow = flow
exports.flowInitial = flowInitial
exports.insideSpan = insideSpan
exports.string = string
exports.text = text


/***/ }),

/***/ 5834:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({value: true}))

var markdownLineEnding = __webpack_require__(7506)
var factorySpace = __webpack_require__(8200)

var tokenize = initializeContent

function initializeContent(effects) {
  var contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  )
  var previous
  return contentStart

  function afterContentStartConstruct(code) {
    if (code === null) {
      effects.consume(code)
      return
    }

    effects.enter('lineEnding')
    effects.consume(code)
    effects.exit('lineEnding')
    return factorySpace(effects, contentStart, 'linePrefix')
  }

  function paragraphInitial(code) {
    effects.enter('paragraph')
    return lineStart(code)
  }

  function lineStart(code) {
    var token = effects.enter('chunkText', {
      contentType: 'text',
      previous: previous
    })

    if (previous) {
      previous.next = token
    }

    previous = token
    return data(code)
  }

  function data(code) {
    if (code === null) {
      effects.exit('chunkText')
      effects.exit('paragraph')
      effects.consume(code)
      return
    }

    if (markdownLineEnding(code)) {
      effects.consume(code)
      effects.exit('chunkText')
      return lineStart
    } // Data.

    effects.consume(code)
    return data
  }
}

exports.tokenize = tokenize


/***/ }),

/***/ 9517:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({value: true}))

var markdownLineEnding = __webpack_require__(7506)
var factorySpace = __webpack_require__(8200)
var partialBlankLine = __webpack_require__(2244)

var tokenize = initializeDocument
var containerConstruct = {
  tokenize: tokenizeContainer
}
var lazyFlowConstruct = {
  tokenize: tokenizeLazyFlow
}

function initializeDocument(effects) {
  var self = this
  var stack = []
  var continued = 0
  var inspectConstruct = {
    tokenize: tokenizeInspect,
    partial: true
  }
  var inspectResult
  var childFlow
  var childToken
  return start

  function start(code) {
    if (continued < stack.length) {
      self.containerState = stack[continued][1]
      return effects.attempt(
        stack[continued][0].continuation,
        documentContinue,
        documentContinued
      )(code)
    }

    return documentContinued(code)
  }

  function documentContinue(code) {
    continued++
    return start(code)
  }

  function documentContinued(code) {
    // If we’re in a concrete construct (such as when expecting another line of
    // HTML, or we resulted in lazy content), we can immediately start flow.
    if (inspectResult && inspectResult.flowContinue) {
      return flowStart(code)
    }

    self.interrupt =
      childFlow &&
      childFlow.currentConstruct &&
      childFlow.currentConstruct.interruptible
    self.containerState = {}
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code)
  }

  function containerContinue(code) {
    stack.push([self.currentConstruct, self.containerState])
    self.containerState = undefined
    return documentContinued(code)
  }

  function flowStart(code) {
    if (code === null) {
      exitContainers(0, true)
      effects.consume(code)
      return
    }

    childFlow = childFlow || self.parser.flow(self.now())
    effects.enter('chunkFlow', {
      contentType: 'flow',
      previous: childToken,
      _tokenizer: childFlow
    })
    return flowContinue(code)
  }

  function flowContinue(code) {
    if (code === null) {
      continueFlow(effects.exit('chunkFlow'))
      return flowStart(code)
    }

    if (markdownLineEnding(code)) {
      effects.consume(code)
      continueFlow(effects.exit('chunkFlow'))
      return effects.check(inspectConstruct, documentAfterPeek)
    }

    effects.consume(code)
    return flowContinue
  }

  function documentAfterPeek(code) {
    exitContainers(
      inspectResult.continued,
      inspectResult && inspectResult.flowEnd
    )
    continued = 0
    return start(code)
  }

  function continueFlow(token) {
    if (childToken) childToken.next = token
    childToken = token
    childFlow.lazy = inspectResult && inspectResult.lazy
    childFlow.defineSkip(token.start)
    childFlow.write(self.sliceStream(token))
  }

  function exitContainers(size, end) {
    var index = stack.length // Close the flow.

    if (childFlow && end) {
      childFlow.write([null])
      childToken = childFlow = undefined
    } // Exit open containers.

    while (index-- > size) {
      self.containerState = stack[index][1]
      stack[index][0].exit.call(self, effects)
    }

    stack.length = size
  }

  function tokenizeInspect(effects, ok) {
    var subcontinued = 0
    inspectResult = {}
    return inspectStart

    function inspectStart(code) {
      if (subcontinued < stack.length) {
        self.containerState = stack[subcontinued][1]
        return effects.attempt(
          stack[subcontinued][0].continuation,
          inspectContinue,
          inspectLess
        )(code)
      } // If we’re continued but in a concrete flow, we can’t have more
      // containers.

      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        inspectResult.flowContinue = true
        return inspectDone(code)
      }

      self.interrupt =
        childFlow.currentConstruct && childFlow.currentConstruct.interruptible
      self.containerState = {}
      return effects.attempt(
        containerConstruct,
        inspectFlowEnd,
        inspectDone
      )(code)
    }

    function inspectContinue(code) {
      subcontinued++
      return self.containerState._closeFlow
        ? inspectFlowEnd(code)
        : inspectStart(code)
    }

    function inspectLess(code) {
      if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {
        // Maybe another container?
        self.containerState = {}
        return effects.attempt(
          containerConstruct,
          inspectFlowEnd, // Maybe flow, or a blank line?
          effects.attempt(
            lazyFlowConstruct,
            inspectFlowEnd,
            effects.check(partialBlankLine, inspectFlowEnd, inspectLazy)
          )
        )(code)
      } // Otherwise we’re interrupting.

      return inspectFlowEnd(code)
    }

    function inspectLazy(code) {
      // Act as if all containers are continued.
      subcontinued = stack.length
      inspectResult.lazy = true
      inspectResult.flowContinue = true
      return inspectDone(code)
    } // We’re done with flow if we have more containers, or an interruption.

    function inspectFlowEnd(code) {
      inspectResult.flowEnd = true
      return inspectDone(code)
    }

    function inspectDone(code) {
      inspectResult.continued = subcontinued
      self.interrupt = self.containerState = undefined
      return ok(code)
    }
  }
}

function tokenizeContainer(effects, ok, nok) {
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok, nok),
    'linePrefix',
    this.parser.constructs.disable.null.indexOf('codeIndented') > -1
      ? undefined
      : 4
  )
}

function tokenizeLazyFlow(effects, ok, nok) {
  return factorySpace(
    effects,
    effects.lazy(this.parser.constructs.flow, ok, nok),
    'linePrefix',
    this.parser.constructs.disable.null.indexOf('codeIndented') > -1
      ? undefined
      : 4
  )
}

exports.tokenize = tokenize


/***/ }),

/***/ 9670:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({value: true}))

var content = __webpack_require__(1259)
var factorySpace = __webpack_require__(8200)
var partialBlankLine = __webpack_require__(2244)

var tokenize = initializeFlow

function initializeFlow(effects) {
  var self = this
  var initial = effects.attempt(
    // Try to parse a blank line.
    partialBlankLine,
    atBlankEnding, // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content, afterConstruct)
        ),
        'linePrefix'
      )
    )
  )
  return initial

  function atBlankEnding(code) {
    if (code === null) {
      effects.consume(code)
      return
    }

    effects.enter('lineEndingBlank')
    effects.consume(code)
    effects.exit('lineEndingBlank')
    self.currentConstruct = undefined
    return initial
  }

  function afterConstruct(code) {
    if (code === null) {
      effects.consume(code)
      return
    }

    effects.enter('lineEnding')
    effects.consume(code)
    effects.exit('lineEnding')
    self.currentConstruct = undefined
    return initial
  }
}

exports.tokenize = tokenize


/***/ }),

/***/ 7492:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({value: true}))

var assign = __webpack_require__(3512)
var shallow = __webpack_require__(1479)

var text = initializeFactory('text')
var string = initializeFactory('string')
var resolver = {
  resolveAll: createResolver()
}

function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === 'text' ? resolveAllLineSuffixes : undefined
    )
  }

  function initializeText(effects) {
    var self = this
    var constructs = this.parser.constructs[field]
    var text = effects.attempt(constructs, start, notText)
    return start

    function start(code) {
      return atBreak(code) ? text(code) : notText(code)
    }

    function notText(code) {
      if (code === null) {
        effects.consume(code)
        return
      }

      effects.enter('data')
      effects.consume(code)
      return data
    }

    function data(code) {
      if (atBreak(code)) {
        effects.exit('data')
        return text(code)
      } // Data.

      effects.consume(code)
      return data
    }

    function atBreak(code) {
      var list = constructs[code]
      var index = -1

      if (code === null) {
        return true
      }

      if (list) {
        while (++index < list.length) {
          if (
            !list[index].previous ||
            list[index].previous.call(self, self.previous)
          ) {
            return true
          }
        }
      }
    }
  }
}

function createResolver(extraResolver) {
  return resolveAllText

  function resolveAllText(events, context) {
    var index = -1
    var enter // A rather boring computation (to merge adjacent `data` events) which
    // improves mm performance by 29%.

    while (++index <= events.length) {
      if (enter === undefined) {
        if (events[index] && events[index][1].type === 'data') {
          enter = index
          index++
        }
      } else if (!events[index] || events[index][1].type !== 'data') {
        // Don’t do anything if there is one data token.
        if (index !== enter + 2) {
          events[enter][1].end = events[index - 1][1].end
          events.splice(enter + 2, index - enter - 2)
          index = enter + 2
        }

        enter = undefined
      }
    }

    return extraResolver ? extraResolver(events, context) : events
  }
} // A rather ugly set of instructions which again looks at chunks in the input
// stream.
// The reason to do this here is that it is *much* faster to parse in reverse.
// And that we can’t hook into `null` to split the line suffix before an EOF.
// To do: figure out if we can make this into a clean utility, or even in core.
// As it will be useful for GFMs literal autolink extension (and maybe even
// tables?)

function resolveAllLineSuffixes(events, context) {
  var eventIndex = -1
  var chunks
  var data
  var chunk
  var index
  var bufferIndex
  var size
  var tabs
  var token

  while (++eventIndex <= events.length) {
    if (
      (eventIndex === events.length ||
        events[eventIndex][1].type === 'lineEnding') &&
      events[eventIndex - 1][1].type === 'data'
    ) {
      data = events[eventIndex - 1][1]
      chunks = context.sliceStream(data)
      index = chunks.length
      bufferIndex = -1
      size = 0
      tabs = undefined

      while (index--) {
        chunk = chunks[index]

        if (typeof chunk === 'string') {
          bufferIndex = chunk.length

          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++
            bufferIndex--
          }

          if (bufferIndex) break
          bufferIndex = -1
        } // Number
        else if (chunk === -2) {
          tabs = true
          size++
        } else if (chunk === -1);
        else {
          // Replacement character, exit.
          index++
          break
        }
      }

      if (size) {
        token = {
          type:
            eventIndex === events.length || tabs || size < 2
              ? 'lineSuffix'
              : 'hardBreakTrailing',
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index,
            _bufferIndex: index
              ? bufferIndex
              : data.start._bufferIndex + bufferIndex
          },
          end: shallow(data.end)
        }
        data.end = shallow(token.start)

        if (data.start.offset === data.end.offset) {
          assign(data, token)
        } else {
          events.splice(
            eventIndex,
            0,
            ['enter', token, context],
            ['exit', token, context]
          )
          eventIndex += 2
        }
      }

      eventIndex++
    }
  }

  return events
}

exports.resolver = resolver
exports.string = string
exports.text = text


/***/ }),

/***/ 488:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var content = __webpack_require__(5834)
var document = __webpack_require__(9517)
var flow = __webpack_require__(9670)
var text = __webpack_require__(7492)
var combineExtensions = __webpack_require__(8602)
var createTokenizer = __webpack_require__(4845)
var miniflat = __webpack_require__(9042)
var constructs = __webpack_require__(289)

function parse(options) {
  var settings = options || {}
  var parser = {
    defined: [],
    constructs: combineExtensions(
      [constructs].concat(miniflat(settings.extensions))
    ),
    content: create(content),
    document: create(document),
    flow: create(flow),
    string: create(text.string),
    text: create(text.text)
  }
  return parser

  function create(initializer) {
    return creator

    function creator(from) {
      return createTokenizer(parser, initializer, from)
    }
  }
}

module.exports = parse


/***/ }),

/***/ 6948:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var subtokenize = __webpack_require__(14)

function postprocess(events) {
  while (!subtokenize(events)) {
    // Empty
  }

  return events
}

module.exports = postprocess


/***/ }),

/***/ 5603:
/***/ ((module) => {

"use strict";


var search = /[\0\t\n\r]/g

function preprocess() {
  var start = true
  var column = 1
  var buffer = ''
  var atCarriageReturn
  return preprocessor

  function preprocessor(value, encoding, end) {
    var chunks = []
    var match
    var next
    var startPosition
    var endPosition
    var code
    value = buffer + value.toString(encoding)
    startPosition = 0
    buffer = ''

    if (start) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++
      }

      start = undefined
    }

    while (startPosition < value.length) {
      search.lastIndex = startPosition
      match = search.exec(value)
      endPosition = match ? match.index : value.length
      code = value.charCodeAt(endPosition)

      if (!match) {
        buffer = value.slice(startPosition)
        break
      }

      if (code === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3)
        atCarriageReturn = undefined
      } else {
        if (atCarriageReturn) {
          chunks.push(-5)
          atCarriageReturn = undefined
        }

        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition))
          column += endPosition - startPosition
        }

        if (code === 0) {
          chunks.push(65533)
          column++
        } else if (code === 9) {
          next = Math.ceil(column / 4) * 4
          chunks.push(-2)

          while (column++ < next) chunks.push(-1)
        } else if (code === 10) {
          chunks.push(-4)
          column = 1
        } // Must be carriage return.
        else {
          atCarriageReturn = true
          column = 1
        }
      }

      startPosition = endPosition + 1
    }

    if (end) {
      if (atCarriageReturn) chunks.push(-5)
      if (buffer) chunks.push(buffer)
      chunks.push(null)
    }

    return chunks
  }
}

module.exports = preprocess


/***/ }),

/***/ 2116:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var chunkedPush = __webpack_require__(4455)
var chunkedSplice = __webpack_require__(778)
var classifyCharacter = __webpack_require__(1324)
var movePoint = __webpack_require__(6985)
var resolveAll = __webpack_require__(2004)
var shallow = __webpack_require__(1479)

var attention = {
  name: 'attention',
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
}

function resolveAllAttention(events, context) {
  var index = -1
  var open
  var group
  var text
  var openingSequence
  var closingSequence
  var use
  var nextEvents
  var offset // Walk through all events.
  //
  // Note: performance of this is fine on an mb of normal markdown, but it’s
  // a bottleneck for malicious stuff.

  while (++index < events.length) {
    // Find a token that can close.
    if (
      events[index][0] === 'enter' &&
      events[index][1].type === 'attentionSequence' &&
      events[index][1]._close
    ) {
      open = index // Now walk back to find an opener.

      while (open--) {
        // Find a token that can open the closer.
        if (
          events[open][0] === 'exit' &&
          events[open][1].type === 'attentionSequence' &&
          events[open][1]._open && // If the markers are the same:
          context.sliceSerialize(events[open][1]).charCodeAt(0) ===
            context.sliceSerialize(events[index][1]).charCodeAt(0)
        ) {
          // If the opening can close or the closing can open,
          // and the close size *is not* a multiple of three,
          // but the sum of the opening and closing size *is* multiple of three,
          // then don’t match.
          if (
            (events[open][1]._close || events[index][1]._open) &&
            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&
            !(
              (events[open][1].end.offset -
                events[open][1].start.offset +
                events[index][1].end.offset -
                events[index][1].start.offset) %
              3
            )
          ) {
            continue
          } // Number of markers to use from the sequence.

          use =
            events[open][1].end.offset - events[open][1].start.offset > 1 &&
            events[index][1].end.offset - events[index][1].start.offset > 1
              ? 2
              : 1
          openingSequence = {
            type: use > 1 ? 'strongSequence' : 'emphasisSequence',
            start: movePoint(shallow(events[open][1].end), -use),
            end: shallow(events[open][1].end)
          }
          closingSequence = {
            type: use > 1 ? 'strongSequence' : 'emphasisSequence',
            start: shallow(events[index][1].start),
            end: movePoint(shallow(events[index][1].start), use)
          }
          text = {
            type: use > 1 ? 'strongText' : 'emphasisText',
            start: shallow(events[open][1].end),
            end: shallow(events[index][1].start)
          }
          group = {
            type: use > 1 ? 'strong' : 'emphasis',
            start: shallow(openingSequence.start),
            end: shallow(closingSequence.end)
          }
          events[open][1].end = shallow(openingSequence.start)
          events[index][1].start = shallow(closingSequence.end)
          nextEvents = [] // If there are more markers in the opening, add them before.

          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = chunkedPush(nextEvents, [
              ['enter', events[open][1], context],
              ['exit', events[open][1], context]
            ])
          } // Opening.

          nextEvents = chunkedPush(nextEvents, [
            ['enter', group, context],
            ['enter', openingSequence, context],
            ['exit', openingSequence, context],
            ['enter', text, context]
          ]) // Between.

          nextEvents = chunkedPush(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index),
              context
            )
          ) // Closing.

          nextEvents = chunkedPush(nextEvents, [
            ['exit', text, context],
            ['enter', closingSequence, context],
            ['exit', closingSequence, context],
            ['exit', group, context]
          ]) // If there are more markers in the closing, add them after.

          if (events[index][1].end.offset - events[index][1].start.offset) {
            offset = 2
            nextEvents = chunkedPush(nextEvents, [
              ['enter', events[index][1], context],
              ['exit', events[index][1], context]
            ])
          } else {
            offset = 0
          }

          chunkedSplice(events, open - 1, index - open + 3, nextEvents)
          index = open + nextEvents.length - offset - 2
          break
        }
      }
    }
  } // Remove remaining sequences.

  index = -1

  while (++index < events.length) {
    if (events[index][1].type === 'attentionSequence') {
      events[index][1].type = 'data'
    }
  }

  return events
}

function tokenizeAttention(effects, ok) {
  var before = classifyCharacter(this.previous)
  var marker
  return start

  function start(code) {
    effects.enter('attentionSequence')
    marker = code
    return sequence(code)
  }

  function sequence(code) {
    var token
    var after
    var open
    var close

    if (code === marker) {
      effects.consume(code)
      return sequence
    }

    token = effects.exit('attentionSequence')
    after = classifyCharacter(code)
    open = !after || (after === 2 && before)
    close = !before || (before === 2 && after)
    token._open = marker === 42 ? open : open && (before || !close)
    token._close = marker === 42 ? close : close && (after || !open)
    return ok(code)
  }
}

module.exports = attention


/***/ }),

/***/ 6681:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var asciiAlpha = __webpack_require__(3847)
var asciiAlphanumeric = __webpack_require__(598)
var asciiAtext = __webpack_require__(245)
var asciiControl = __webpack_require__(1336)

var autolink = {
  name: 'autolink',
  tokenize: tokenizeAutolink
}

function tokenizeAutolink(effects, ok, nok) {
  var size = 1
  return start

  function start(code) {
    effects.enter('autolink')
    effects.enter('autolinkMarker')
    effects.consume(code)
    effects.exit('autolinkMarker')
    effects.enter('autolinkProtocol')
    return open
  }

  function open(code) {
    if (asciiAlpha(code)) {
      effects.consume(code)
      return schemeOrEmailAtext
    }

    return asciiAtext(code) ? emailAtext(code) : nok(code)
  }

  function schemeOrEmailAtext(code) {
    return code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)
      ? schemeInsideOrEmailAtext(code)
      : emailAtext(code)
  }

  function schemeInsideOrEmailAtext(code) {
    if (code === 58) {
      effects.consume(code)
      return urlInside
    }

    if (
      (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) &&
      size++ < 32
    ) {
      effects.consume(code)
      return schemeInsideOrEmailAtext
    }

    return emailAtext(code)
  }

  function urlInside(code) {
    if (code === 62) {
      effects.exit('autolinkProtocol')
      return end(code)
    }

    if (code === 32 || code === 60 || asciiControl(code)) {
      return nok(code)
    }

    effects.consume(code)
    return urlInside
  }

  function emailAtext(code) {
    if (code === 64) {
      effects.consume(code)
      size = 0
      return emailAtSignOrDot
    }

    if (asciiAtext(code)) {
      effects.consume(code)
      return emailAtext
    }

    return nok(code)
  }

  function emailAtSignOrDot(code) {
    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)
  }

  function emailLabel(code) {
    if (code === 46) {
      effects.consume(code)
      size = 0
      return emailAtSignOrDot
    }

    if (code === 62) {
      // Exit, then change the type.
      effects.exit('autolinkProtocol').type = 'autolinkEmail'
      return end(code)
    }

    return emailValue(code)
  }

  function emailValue(code) {
    if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {
      effects.consume(code)
      return code === 45 ? emailValue : emailLabel
    }

    return nok(code)
  }

  function end(code) {
    effects.enter('autolinkMarker')
    effects.consume(code)
    effects.exit('autolinkMarker')
    effects.exit('autolink')
    return ok
  }
}

module.exports = autolink


/***/ }),

/***/ 9025:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownSpace = __webpack_require__(5989)
var factorySpace = __webpack_require__(8200)

var blockQuote = {
  name: 'blockQuote',
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit: exit
}

function tokenizeBlockQuoteStart(effects, ok, nok) {
  var self = this
  return start

  function start(code) {
    if (code === 62) {
      if (!self.containerState.open) {
        effects.enter('blockQuote', {
          _container: true
        })
        self.containerState.open = true
      }

      effects.enter('blockQuotePrefix')
      effects.enter('blockQuoteMarker')
      effects.consume(code)
      effects.exit('blockQuoteMarker')
      return after
    }

    return nok(code)
  }

  function after(code) {
    if (markdownSpace(code)) {
      effects.enter('blockQuotePrefixWhitespace')
      effects.consume(code)
      effects.exit('blockQuotePrefixWhitespace')
      effects.exit('blockQuotePrefix')
      return ok
    }

    effects.exit('blockQuotePrefix')
    return ok(code)
  }
}

function tokenizeBlockQuoteContinuation(effects, ok, nok) {
  return factorySpace(
    effects,
    effects.attempt(blockQuote, ok, nok),
    'linePrefix',
    this.parser.constructs.disable.null.indexOf('codeIndented') > -1
      ? undefined
      : 4
  )
}

function exit(effects) {
  effects.exit('blockQuote')
}

module.exports = blockQuote


/***/ }),

/***/ 7128:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var asciiPunctuation = __webpack_require__(7909)

var characterEscape = {
  name: 'characterEscape',
  tokenize: tokenizeCharacterEscape
}

function tokenizeCharacterEscape(effects, ok, nok) {
  return start

  function start(code) {
    effects.enter('characterEscape')
    effects.enter('escapeMarker')
    effects.consume(code)
    effects.exit('escapeMarker')
    return open
  }

  function open(code) {
    if (asciiPunctuation(code)) {
      effects.enter('characterEscapeValue')
      effects.consume(code)
      effects.exit('characterEscapeValue')
      effects.exit('characterEscape')
      return ok
    }

    return nok(code)
  }
}

module.exports = characterEscape


/***/ }),

/***/ 9500:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var decodeEntity = __webpack_require__(3485)
var asciiAlphanumeric = __webpack_require__(598)
var asciiDigit = __webpack_require__(6996)
var asciiHexDigit = __webpack_require__(6526)

function _interopDefaultLegacy(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {default: e}
}

var decodeEntity__default = /*#__PURE__*/ _interopDefaultLegacy(decodeEntity)

var characterReference = {
  name: 'characterReference',
  tokenize: tokenizeCharacterReference
}

function tokenizeCharacterReference(effects, ok, nok) {
  var self = this
  var size = 0
  var max
  var test
  return start

  function start(code) {
    effects.enter('characterReference')
    effects.enter('characterReferenceMarker')
    effects.consume(code)
    effects.exit('characterReferenceMarker')
    return open
  }

  function open(code) {
    if (code === 35) {
      effects.enter('characterReferenceMarkerNumeric')
      effects.consume(code)
      effects.exit('characterReferenceMarkerNumeric')
      return numeric
    }

    effects.enter('characterReferenceValue')
    max = 31
    test = asciiAlphanumeric
    return value(code)
  }

  function numeric(code) {
    if (code === 88 || code === 120) {
      effects.enter('characterReferenceMarkerHexadecimal')
      effects.consume(code)
      effects.exit('characterReferenceMarkerHexadecimal')
      effects.enter('characterReferenceValue')
      max = 6
      test = asciiHexDigit
      return value
    }

    effects.enter('characterReferenceValue')
    max = 7
    test = asciiDigit
    return value(code)
  }

  function value(code) {
    var token

    if (code === 59 && size) {
      token = effects.exit('characterReferenceValue')

      if (
        test === asciiAlphanumeric &&
        !decodeEntity__default['default'](self.sliceSerialize(token))
      ) {
        return nok(code)
      }

      effects.enter('characterReferenceMarker')
      effects.consume(code)
      effects.exit('characterReferenceMarker')
      effects.exit('characterReference')
      return ok
    }

    if (test(code) && size++ < max) {
      effects.consume(code)
      return value
    }

    return nok(code)
  }
}

module.exports = characterReference


/***/ }),

/***/ 3268:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(7506)
var markdownLineEndingOrSpace = __webpack_require__(9180)
var prefixSize = __webpack_require__(3722)
var factorySpace = __webpack_require__(8200)

var codeFenced = {
  name: 'codeFenced',
  tokenize: tokenizeCodeFenced,
  concrete: true
}

function tokenizeCodeFenced(effects, ok, nok) {
  var self = this
  var closingFenceConstruct = {
    tokenize: tokenizeClosingFence,
    partial: true
  }
  var initialPrefix = prefixSize(this.events, 'linePrefix')
  var sizeOpen = 0
  var marker
  return start

  function start(code) {
    effects.enter('codeFenced')
    effects.enter('codeFencedFence')
    effects.enter('codeFencedFenceSequence')
    marker = code
    return sequenceOpen(code)
  }

  function sequenceOpen(code) {
    if (code === marker) {
      effects.consume(code)
      sizeOpen++
      return sequenceOpen
    }

    effects.exit('codeFencedFenceSequence')
    return sizeOpen < 3
      ? nok(code)
      : factorySpace(effects, infoOpen, 'whitespace')(code)
  }

  function infoOpen(code) {
    if (code === null || markdownLineEnding(code)) {
      return openAfter(code)
    }

    effects.enter('codeFencedFenceInfo')
    effects.enter('chunkString', {
      contentType: 'string'
    })
    return info(code)
  }

  function info(code) {
    if (code === null || markdownLineEndingOrSpace(code)) {
      effects.exit('chunkString')
      effects.exit('codeFencedFenceInfo')
      return factorySpace(effects, infoAfter, 'whitespace')(code)
    }

    if (code === 96 && code === marker) return nok(code)
    effects.consume(code)
    return info
  }

  function infoAfter(code) {
    if (code === null || markdownLineEnding(code)) {
      return openAfter(code)
    }

    effects.enter('codeFencedFenceMeta')
    effects.enter('chunkString', {
      contentType: 'string'
    })
    return meta(code)
  }

  function meta(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('chunkString')
      effects.exit('codeFencedFenceMeta')
      return openAfter(code)
    }

    if (code === 96 && code === marker) return nok(code)
    effects.consume(code)
    return meta
  }

  function openAfter(code) {
    effects.exit('codeFencedFence')
    return self.interrupt ? ok(code) : content(code)
  }

  function content(code) {
    if (code === null) {
      return after(code)
    }

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      return effects.attempt(
        closingFenceConstruct,
        after,
        initialPrefix
          ? factorySpace(effects, content, 'linePrefix', initialPrefix + 1)
          : content
      )
    }

    effects.enter('codeFlowValue')
    return contentContinue(code)
  }

  function contentContinue(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('codeFlowValue')
      return content(code)
    }

    effects.consume(code)
    return contentContinue
  }

  function after(code) {
    effects.exit('codeFenced')
    return ok(code)
  }

  function tokenizeClosingFence(effects, ok, nok) {
    var size = 0
    return factorySpace(
      effects,
      closingSequenceStart,
      'linePrefix',
      this.parser.constructs.disable.null.indexOf('codeIndented') > -1
        ? undefined
        : 4
    )

    function closingSequenceStart(code) {
      effects.enter('codeFencedFence')
      effects.enter('codeFencedFenceSequence')
      return closingSequence(code)
    }

    function closingSequence(code) {
      if (code === marker) {
        effects.consume(code)
        size++
        return closingSequence
      }

      if (size < sizeOpen) return nok(code)
      effects.exit('codeFencedFenceSequence')
      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)
    }

    function closingSequenceEnd(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit('codeFencedFence')
        return ok(code)
      }

      return nok(code)
    }
  }
}

module.exports = codeFenced


/***/ }),

/***/ 907:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(7506)
var chunkedSplice = __webpack_require__(778)
var prefixSize = __webpack_require__(3722)
var factorySpace = __webpack_require__(8200)

var codeIndented = {
  name: 'codeIndented',
  tokenize: tokenizeCodeIndented,
  resolve: resolveCodeIndented
}
var indentedContentConstruct = {
  tokenize: tokenizeIndentedContent,
  partial: true
}

function resolveCodeIndented(events, context) {
  var code = {
    type: 'codeIndented',
    start: events[0][1].start,
    end: events[events.length - 1][1].end
  }
  chunkedSplice(events, 0, 0, [['enter', code, context]])
  chunkedSplice(events, events.length, 0, [['exit', code, context]])
  return events
}

function tokenizeCodeIndented(effects, ok, nok) {
  return effects.attempt(indentedContentConstruct, afterPrefix, nok)

  function afterPrefix(code) {
    if (code === null) {
      return ok(code)
    }

    if (markdownLineEnding(code)) {
      return effects.attempt(indentedContentConstruct, afterPrefix, ok)(code)
    }

    effects.enter('codeFlowValue')
    return content(code)
  }

  function content(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('codeFlowValue')
      return afterPrefix(code)
    }

    effects.consume(code)
    return content
  }
}

function tokenizeIndentedContent(effects, ok, nok) {
  var self = this
  return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)

  function afterPrefix(code) {
    if (markdownLineEnding(code)) {
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)
    }

    return prefixSize(self.events, 'linePrefix') < 4 ? nok(code) : ok(code)
  }
}

module.exports = codeIndented


/***/ }),

/***/ 7033:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(7506)

var codeText = {
  name: 'codeText',
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous: previous
}

function resolveCodeText(events) {
  var tailExitIndex = events.length - 4
  var headEnterIndex = 3
  var index
  var enter // If we start and end with an EOL or a space.

  if (
    (events[headEnterIndex][1].type === 'lineEnding' ||
      events[headEnterIndex][1].type === 'space') &&
    (events[tailExitIndex][1].type === 'lineEnding' ||
      events[tailExitIndex][1].type === 'space')
  ) {
    index = headEnterIndex // And we have data.

    while (++index < tailExitIndex) {
      if (events[index][1].type === 'codeTextData') {
        // Then we have padding.
        events[tailExitIndex][1].type = events[headEnterIndex][1].type =
          'codeTextPadding'
        headEnterIndex += 2
        tailExitIndex -= 2
        break
      }
    }
  } // Merge adjacent spaces and data.

  index = headEnterIndex - 1
  tailExitIndex++

  while (++index <= tailExitIndex) {
    if (enter === undefined) {
      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {
        enter = index
      }
    } else if (
      index === tailExitIndex ||
      events[index][1].type === 'lineEnding'
    ) {
      events[enter][1].type = 'codeTextData'

      if (index !== enter + 2) {
        events[enter][1].end = events[index - 1][1].end
        events.splice(enter + 2, index - enter - 2)
        tailExitIndex -= index - enter - 2
        index = enter + 2
      }

      enter = undefined
    }
  }

  return events
}

function previous(code) {
  // If there is a previous code, there will always be a tail.
  return (
    code !== 96 ||
    this.events[this.events.length - 1][1].type === 'characterEscape'
  )
}

function tokenizeCodeText(effects, ok, nok) {
  var sizeOpen = 0
  var size
  var token
  return start

  function start(code) {
    effects.enter('codeText')
    effects.enter('codeTextSequence')
    return openingSequence(code)
  }

  function openingSequence(code) {
    if (code === 96) {
      effects.consume(code)
      sizeOpen++
      return openingSequence
    }

    effects.exit('codeTextSequence')
    return gap(code)
  }

  function gap(code) {
    // EOF.
    if (code === null) {
      return nok(code)
    } // Closing fence?
    // Could also be data.

    if (code === 96) {
      token = effects.enter('codeTextSequence')
      size = 0
      return closingSequence(code)
    } // Tabs don’t work, and virtual spaces don’t make sense.

    if (code === 32) {
      effects.enter('space')
      effects.consume(code)
      effects.exit('space')
      return gap
    }

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      return gap
    } // Data.

    effects.enter('codeTextData')
    return data(code)
  } // In code.

  function data(code) {
    if (
      code === null ||
      code === 32 ||
      code === 96 ||
      markdownLineEnding(code)
    ) {
      effects.exit('codeTextData')
      return gap(code)
    }

    effects.consume(code)
    return data
  } // Closing fence.

  function closingSequence(code) {
    // More.
    if (code === 96) {
      effects.consume(code)
      size++
      return closingSequence
    } // Done!

    if (size === sizeOpen) {
      effects.exit('codeTextSequence')
      effects.exit('codeText')
      return ok(code)
    } // More or less accents: mark as data.

    token.type = 'codeTextData'
    return data(code)
  }
}

module.exports = codeText


/***/ }),

/***/ 1259:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(7506)
var prefixSize = __webpack_require__(3722)
var subtokenize = __webpack_require__(14)
var factorySpace = __webpack_require__(8200)

// No name because it must not be turned off.
var content = {
  tokenize: tokenizeContent,
  resolve: resolveContent,
  interruptible: true,
  lazy: true
}
var continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
} // Content is transparent: it’s parsed right now. That way, definitions are also
// parsed right now: before text in paragraphs (specifically, media) are parsed.

function resolveContent(events) {
  subtokenize(events)
  return events
}

function tokenizeContent(effects, ok) {
  var previous
  return start

  function start(code) {
    effects.enter('content')
    previous = effects.enter('chunkContent', {
      contentType: 'content'
    })
    return data(code)
  }

  function data(code) {
    if (code === null) {
      return contentEnd(code)
    }

    if (markdownLineEnding(code)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code)
    } // Data.

    effects.consume(code)
    return data
  }

  function contentEnd(code) {
    effects.exit('chunkContent')
    effects.exit('content')
    return ok(code)
  }

  function contentContinue(code) {
    effects.consume(code)
    effects.exit('chunkContent')
    previous = previous.next = effects.enter('chunkContent', {
      contentType: 'content',
      previous: previous
    })
    return data
  }
}

function tokenizeContinuation(effects, ok, nok) {
  var self = this
  return startLookahead

  function startLookahead(code) {
    effects.enter('lineEnding')
    effects.consume(code)
    effects.exit('lineEnding')
    return factorySpace(effects, prefixed, 'linePrefix')
  }

  function prefixed(code) {
    if (code === null || markdownLineEnding(code)) {
      return nok(code)
    }

    if (
      self.parser.constructs.disable.null.indexOf('codeIndented') > -1 ||
      prefixSize(self.events, 'linePrefix') < 4
    ) {
      return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)
    }

    return ok(code)
  }
}

module.exports = content


/***/ }),

/***/ 1193:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(7506)
var markdownLineEndingOrSpace = __webpack_require__(9180)
var normalizeIdentifier = __webpack_require__(712)
var factoryDestination = __webpack_require__(9851)
var factoryLabel = __webpack_require__(349)
var factorySpace = __webpack_require__(8200)
var factoryWhitespace = __webpack_require__(3168)
var factoryTitle = __webpack_require__(9469)

var definition = {
  name: 'definition',
  tokenize: tokenizeDefinition
}
var titleConstruct = {
  tokenize: tokenizeTitle,
  partial: true
}

function tokenizeDefinition(effects, ok, nok) {
  var self = this
  var identifier
  return start

  function start(code) {
    effects.enter('definition')
    return factoryLabel.call(
      self,
      effects,
      labelAfter,
      nok,
      'definitionLabel',
      'definitionLabelMarker',
      'definitionLabelString'
    )(code)
  }

  function labelAfter(code) {
    identifier = normalizeIdentifier(
      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
    )

    if (code === 58) {
      effects.enter('definitionMarker')
      effects.consume(code)
      effects.exit('definitionMarker') // Note: blank lines can’t exist in content.

      return factoryWhitespace(
        effects,
        factoryDestination(
          effects,
          effects.attempt(
            titleConstruct,
            factorySpace(effects, after, 'whitespace'),
            factorySpace(effects, after, 'whitespace')
          ),
          nok,
          'definitionDestination',
          'definitionDestinationLiteral',
          'definitionDestinationLiteralMarker',
          'definitionDestinationRaw',
          'definitionDestinationString'
        )
      )
    }

    return nok(code)
  }

  function after(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('definition')

      if (self.parser.defined.indexOf(identifier) < 0) {
        self.parser.defined.push(identifier)
      }

      return ok(code)
    }

    return nok(code)
  }
}

function tokenizeTitle(effects, ok, nok) {
  return start

  function start(code) {
    return markdownLineEndingOrSpace(code)
      ? factoryWhitespace(effects, before)(code)
      : nok(code)
  }

  function before(code) {
    if (code === 34 || code === 39 || code === 40) {
      return factoryTitle(
        effects,
        factorySpace(effects, after, 'whitespace'),
        nok,
        'definitionTitle',
        'definitionTitleMarker',
        'definitionTitleString'
      )(code)
    }

    return nok(code)
  }

  function after(code) {
    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)
  }
}

module.exports = definition


/***/ }),

/***/ 9851:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var asciiControl = __webpack_require__(1336)
var markdownLineEndingOrSpace = __webpack_require__(9180)
var markdownLineEnding = __webpack_require__(7506)

// eslint-disable-next-line max-params
function destinationFactory(
  effects,
  ok,
  nok,
  type,
  literalType,
  literalMarkerType,
  rawType,
  stringType,
  max
) {
  var limit = max || Infinity
  var balance = 0
  return start

  function start(code) {
    if (code === 60) {
      effects.enter(type)
      effects.enter(literalType)
      effects.enter(literalMarkerType)
      effects.consume(code)
      effects.exit(literalMarkerType)
      return destinationEnclosedBefore
    }

    if (asciiControl(code) || code === 41) {
      return nok(code)
    }

    effects.enter(type)
    effects.enter(rawType)
    effects.enter(stringType)
    effects.enter('chunkString', {
      contentType: 'string'
    })
    return destinationRaw(code)
  }

  function destinationEnclosedBefore(code) {
    if (code === 62) {
      effects.enter(literalMarkerType)
      effects.consume(code)
      effects.exit(literalMarkerType)
      effects.exit(literalType)
      effects.exit(type)
      return ok
    }

    effects.enter(stringType)
    effects.enter('chunkString', {
      contentType: 'string'
    })
    return destinationEnclosed(code)
  }

  function destinationEnclosed(code) {
    if (code === 62) {
      effects.exit('chunkString')
      effects.exit(stringType)
      return destinationEnclosedBefore(code)
    }

    if (code === null || code === 60 || markdownLineEnding(code)) {
      return nok(code)
    }

    effects.consume(code)
    return code === 92 ? destinationEnclosedEscape : destinationEnclosed
  }

  function destinationEnclosedEscape(code) {
    if (code === 60 || code === 62 || code === 92) {
      effects.consume(code)
      return destinationEnclosed
    }

    return destinationEnclosed(code)
  }

  function destinationRaw(code) {
    if (code === 40) {
      if (++balance > limit) return nok(code)
      effects.consume(code)
      return destinationRaw
    }

    if (code === 41) {
      if (!balance--) {
        effects.exit('chunkString')
        effects.exit(stringType)
        effects.exit(rawType)
        effects.exit(type)
        return ok(code)
      }

      effects.consume(code)
      return destinationRaw
    }

    if (code === null || markdownLineEndingOrSpace(code)) {
      if (balance) return nok(code)
      effects.exit('chunkString')
      effects.exit(stringType)
      effects.exit(rawType)
      effects.exit(type)
      return ok(code)
    }

    if (asciiControl(code)) return nok(code)
    effects.consume(code)
    return code === 92 ? destinationRawEscape : destinationRaw
  }

  function destinationRawEscape(code) {
    if (code === 40 || code === 41 || code === 92) {
      effects.consume(code)
      return destinationRaw
    }

    return destinationRaw(code)
  }
}

module.exports = destinationFactory


/***/ }),

/***/ 349:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(7506)
var markdownSpace = __webpack_require__(5989)

// eslint-disable-next-line max-params
function labelFactory(effects, ok, nok, type, markerType, stringType) {
  var self = this
  var size = 0
  var data
  return start

  function start(code) {
    effects.enter(type)
    effects.enter(markerType)
    effects.consume(code)
    effects.exit(markerType)
    effects.enter(stringType)
    return atBreak
  }

  function atBreak(code) {
    if (
      code === null ||
      code === 91 ||
      (code === 93 && !data) ||
      /* c8 ignore next */
      (code === 94 &&
        /* c8 ignore next */
        !size &&
        /* c8 ignore next */
        '_hiddenFootnoteSupport' in self.parser.constructs) ||
      size > 999
    ) {
      return nok(code)
    }

    if (code === 93) {
      effects.exit(stringType)
      effects.enter(markerType)
      effects.consume(code)
      effects.exit(markerType)
      effects.exit(type)
      return ok
    }

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      return atBreak
    }

    effects.enter('chunkString', {
      contentType: 'string'
    })
    return label(code)
  }

  function label(code) {
    if (
      code === null ||
      code === 91 ||
      code === 93 ||
      markdownLineEnding(code) ||
      size++ > 999
    ) {
      effects.exit('chunkString')
      return atBreak(code)
    }

    effects.consume(code)
    data = data || !markdownSpace(code)
    return code === 92 ? labelEscape : label
  }

  function labelEscape(code) {
    if (code === 91 || code === 92 || code === 93) {
      effects.consume(code)
      size++
      return label
    }

    return label(code)
  }
}

module.exports = labelFactory


/***/ }),

/***/ 8200:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownSpace = __webpack_require__(5989)

function spaceFactory(effects, ok, type, max) {
  var limit = max ? max - 1 : Infinity
  var size = 0
  return start

  function start(code) {
    if (markdownSpace(code)) {
      effects.enter(type)
      return prefix(code)
    }

    return ok(code)
  }

  function prefix(code) {
    if (markdownSpace(code) && size++ < limit) {
      effects.consume(code)
      return prefix
    }

    effects.exit(type)
    return ok(code)
  }
}

module.exports = spaceFactory


/***/ }),

/***/ 9469:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(7506)
var factorySpace = __webpack_require__(8200)

function titleFactory(effects, ok, nok, type, markerType, stringType) {
  var marker
  return start

  function start(code) {
    effects.enter(type)
    effects.enter(markerType)
    effects.consume(code)
    effects.exit(markerType)
    marker = code === 40 ? 41 : code
    return atFirstTitleBreak
  }

  function atFirstTitleBreak(code) {
    if (code === marker) {
      effects.enter(markerType)
      effects.consume(code)
      effects.exit(markerType)
      effects.exit(type)
      return ok
    }

    effects.enter(stringType)
    return atTitleBreak(code)
  }

  function atTitleBreak(code) {
    if (code === marker) {
      effects.exit(stringType)
      return atFirstTitleBreak(marker)
    }

    if (code === null) {
      return nok(code)
    } // Note: blank lines can’t exist in content.

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      return factorySpace(effects, atTitleBreak, 'linePrefix')
    }

    effects.enter('chunkString', {
      contentType: 'string'
    })
    return title(code)
  }

  function title(code) {
    if (code === marker || code === null || markdownLineEnding(code)) {
      effects.exit('chunkString')
      return atTitleBreak(code)
    }

    effects.consume(code)
    return code === 92 ? titleEscape : title
  }

  function titleEscape(code) {
    if (code === marker || code === 92) {
      effects.consume(code)
      return title
    }

    return title(code)
  }
}

module.exports = titleFactory


/***/ }),

/***/ 3168:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(7506)
var markdownSpace = __webpack_require__(5989)
var factorySpace = __webpack_require__(8200)

function whitespaceFactory(effects, ok) {
  var seen
  return start

  function start(code) {
    if (markdownLineEnding(code)) {
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      seen = true
      return start
    }

    if (markdownSpace(code)) {
      return factorySpace(
        effects,
        start,
        seen ? 'linePrefix' : 'lineSuffix'
      )(code)
    }

    return ok(code)
  }
}

module.exports = whitespaceFactory


/***/ }),

/***/ 7608:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(7506)

var hardBreakEscape = {
  name: 'hardBreakEscape',
  tokenize: tokenizeHardBreakEscape
}

function tokenizeHardBreakEscape(effects, ok, nok) {
  return start

  function start(code) {
    effects.enter('hardBreakEscape')
    effects.enter('escapeMarker')
    effects.consume(code)
    return open
  }

  function open(code) {
    if (markdownLineEnding(code)) {
      effects.exit('escapeMarker')
      effects.exit('hardBreakEscape')
      return ok(code)
    }

    return nok(code)
  }
}

module.exports = hardBreakEscape


/***/ }),

/***/ 4558:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(7506)
var markdownLineEndingOrSpace = __webpack_require__(9180)
var markdownSpace = __webpack_require__(5989)
var chunkedSplice = __webpack_require__(778)
var factorySpace = __webpack_require__(8200)

var headingAtx = {
  name: 'headingAtx',
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
}

function resolveHeadingAtx(events, context) {
  var contentEnd = events.length - 2
  var contentStart = 3
  var content
  var text // Prefix whitespace, part of the opening.

  if (events[contentStart][1].type === 'whitespace') {
    contentStart += 2
  } // Suffix whitespace, part of the closing.

  if (
    contentEnd - 2 > contentStart &&
    events[contentEnd][1].type === 'whitespace'
  ) {
    contentEnd -= 2
  }

  if (
    events[contentEnd][1].type === 'atxHeadingSequence' &&
    (contentStart === contentEnd - 1 ||
      (contentEnd - 4 > contentStart &&
        events[contentEnd - 2][1].type === 'whitespace'))
  ) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4
  }

  if (contentEnd > contentStart) {
    content = {
      type: 'atxHeadingText',
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    }
    text = {
      type: 'chunkText',
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: 'text'
    }
    chunkedSplice(events, contentStart, contentEnd - contentStart + 1, [
      ['enter', content, context],
      ['enter', text, context],
      ['exit', text, context],
      ['exit', content, context]
    ])
  }

  return events
}

function tokenizeHeadingAtx(effects, ok, nok) {
  var self = this
  var size = 0
  return start

  function start(code) {
    effects.enter('atxHeading')
    effects.enter('atxHeadingSequence')
    return fenceOpenInside(code)
  }

  function fenceOpenInside(code) {
    if (code === 35 && size++ < 6) {
      effects.consume(code)
      return fenceOpenInside
    }

    if (code === null || markdownLineEndingOrSpace(code)) {
      effects.exit('atxHeadingSequence')
      return self.interrupt ? ok(code) : headingBreak(code)
    }

    return nok(code)
  }

  function headingBreak(code) {
    if (code === 35) {
      effects.enter('atxHeadingSequence')
      return sequence(code)
    }

    if (code === null || markdownLineEnding(code)) {
      effects.exit('atxHeading')
      return ok(code)
    }

    if (markdownSpace(code)) {
      return factorySpace(effects, headingBreak, 'whitespace')(code)
    }

    effects.enter('atxHeadingText')
    return data(code)
  }

  function sequence(code) {
    if (code === 35) {
      effects.consume(code)
      return sequence
    }

    effects.exit('atxHeadingSequence')
    return headingBreak(code)
  }

  function data(code) {
    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {
      effects.exit('atxHeadingText')
      return headingBreak(code)
    }

    effects.consume(code)
    return data
  }
}

module.exports = headingAtx


/***/ }),

/***/ 6791:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var asciiAlpha = __webpack_require__(3847)
var asciiAlphanumeric = __webpack_require__(598)
var markdownLineEnding = __webpack_require__(7506)
var markdownLineEndingOrSpace = __webpack_require__(9180)
var markdownSpace = __webpack_require__(5989)
var fromCharCode = __webpack_require__(3531)
var htmlBlockNames = __webpack_require__(5159)
var htmlRawNames = __webpack_require__(4677)
var partialBlankLine = __webpack_require__(2244)

var htmlFlow = {
  name: 'htmlFlow',
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
}
var nextBlankConstruct = {
  tokenize: tokenizeNextBlank,
  partial: true
}

function resolveToHtmlFlow(events) {
  var index = events.length

  while (index--) {
    if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {
      break
    }
  }

  if (index > 1 && events[index - 2][1].type === 'linePrefix') {
    // Add the prefix start to the HTML token.
    events[index][1].start = events[index - 2][1].start // Add the prefix start to the HTML line token.

    events[index + 1][1].start = events[index - 2][1].start // Remove the line prefix.

    events.splice(index - 2, 2)
  }

  return events
}

function tokenizeHtmlFlow(effects, ok, nok) {
  var self = this
  var kind
  var startTag
  var buffer
  var index
  var marker
  return start

  function start(code) {
    effects.enter('htmlFlow')
    effects.enter('htmlFlowData')
    effects.consume(code)
    return open
  }

  function open(code) {
    if (code === 33) {
      effects.consume(code)
      return declarationStart
    }

    if (code === 47) {
      effects.consume(code)
      return tagCloseStart
    }

    if (code === 63) {
      effects.consume(code)
      kind = 3 // While we’re in an instruction instead of a declaration, we’re on a `?`
      // right now, so we do need to search for `>`, similar to declarations.

      return self.interrupt ? ok : continuationDeclarationInside
    }

    if (asciiAlpha(code)) {
      effects.consume(code)
      buffer = fromCharCode(code)
      startTag = true
      return tagName
    }

    return nok(code)
  }

  function declarationStart(code) {
    if (code === 45) {
      effects.consume(code)
      kind = 2
      return commentOpenInside
    }

    if (code === 91) {
      effects.consume(code)
      kind = 5
      buffer = 'CDATA['
      index = 0
      return cdataOpenInside
    }

    if (asciiAlpha(code)) {
      effects.consume(code)
      kind = 4
      return self.interrupt ? ok : continuationDeclarationInside
    }

    return nok(code)
  }

  function commentOpenInside(code) {
    if (code === 45) {
      effects.consume(code)
      return self.interrupt ? ok : continuationDeclarationInside
    }

    return nok(code)
  }

  function cdataOpenInside(code) {
    if (code === buffer.charCodeAt(index++)) {
      effects.consume(code)
      return index === buffer.length
        ? self.interrupt
          ? ok
          : continuation
        : cdataOpenInside
    }

    return nok(code)
  }

  function tagCloseStart(code) {
    if (asciiAlpha(code)) {
      effects.consume(code)
      buffer = fromCharCode(code)
      return tagName
    }

    return nok(code)
  }

  function tagName(code) {
    if (
      code === null ||
      code === 47 ||
      code === 62 ||
      markdownLineEndingOrSpace(code)
    ) {
      if (
        code !== 47 &&
        startTag &&
        htmlRawNames.indexOf(buffer.toLowerCase()) > -1
      ) {
        kind = 1
        return self.interrupt ? ok(code) : continuation(code)
      }

      if (htmlBlockNames.indexOf(buffer.toLowerCase()) > -1) {
        kind = 6

        if (code === 47) {
          effects.consume(code)
          return basicSelfClosing
        }

        return self.interrupt ? ok(code) : continuation(code)
      }

      kind = 7 // Do not support complete HTML when interrupting.

      return self.interrupt
        ? nok(code)
        : startTag
        ? completeAttributeNameBefore(code)
        : completeClosingTagAfter(code)
    }

    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code)
      buffer += fromCharCode(code)
      return tagName
    }

    return nok(code)
  }

  function basicSelfClosing(code) {
    if (code === 62) {
      effects.consume(code)
      return self.interrupt ? ok : continuation
    }

    return nok(code)
  }

  function completeClosingTagAfter(code) {
    if (markdownSpace(code)) {
      effects.consume(code)
      return completeClosingTagAfter
    }

    return completeEnd(code)
  }

  function completeAttributeNameBefore(code) {
    if (code === 47) {
      effects.consume(code)
      return completeEnd
    }

    if (code === 58 || code === 95 || asciiAlpha(code)) {
      effects.consume(code)
      return completeAttributeName
    }

    if (markdownSpace(code)) {
      effects.consume(code)
      return completeAttributeNameBefore
    }

    return completeEnd(code)
  }

  function completeAttributeName(code) {
    if (
      code === 45 ||
      code === 46 ||
      code === 58 ||
      code === 95 ||
      asciiAlphanumeric(code)
    ) {
      effects.consume(code)
      return completeAttributeName
    }

    return completeAttributeNameAfter(code)
  }

  function completeAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code)
      return completeAttributeValueBefore
    }

    if (markdownSpace(code)) {
      effects.consume(code)
      return completeAttributeNameAfter
    }

    return completeAttributeNameBefore(code)
  }

  function completeAttributeValueBefore(code) {
    if (
      code === null ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96
    ) {
      return nok(code)
    }

    if (code === 34 || code === 39) {
      effects.consume(code)
      marker = code
      return completeAttributeValueQuoted
    }

    if (markdownSpace(code)) {
      effects.consume(code)
      return completeAttributeValueBefore
    }

    marker = undefined
    return completeAttributeValueUnquoted(code)
  }

  function completeAttributeValueQuoted(code) {
    if (code === marker) {
      effects.consume(code)
      return completeAttributeValueQuotedAfter
    }

    if (code === null || markdownLineEnding(code)) {
      return nok(code)
    }

    effects.consume(code)
    return completeAttributeValueQuoted
  }

  function completeAttributeValueUnquoted(code) {
    if (
      code === null ||
      code === 34 ||
      code === 39 ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96 ||
      markdownLineEndingOrSpace(code)
    ) {
      return completeAttributeNameAfter(code)
    }

    effects.consume(code)
    return completeAttributeValueUnquoted
  }

  function completeAttributeValueQuotedAfter(code) {
    if (code === 47 || code === 62 || markdownSpace(code)) {
      return completeAttributeNameBefore(code)
    }

    return nok(code)
  }

  function completeEnd(code) {
    if (code === 62) {
      effects.consume(code)
      return completeAfter
    }

    return nok(code)
  }

  function completeAfter(code) {
    if (markdownSpace(code)) {
      effects.consume(code)
      return completeAfter
    }

    return code === null || markdownLineEnding(code)
      ? continuation(code)
      : nok(code)
  }

  function continuation(code) {
    if (code === 45 && kind === 2) {
      effects.consume(code)
      return continuationCommentInside
    }

    if (code === 60 && kind === 1) {
      effects.consume(code)
      return continuationRawTagOpen
    }

    if (code === 62 && kind === 4) {
      effects.consume(code)
      return continuationClose
    }

    if (code === 63 && kind === 3) {
      effects.consume(code)
      return continuationDeclarationInside
    }

    if (code === 93 && kind === 5) {
      effects.consume(code)
      return continuationCharacterDataInside
    }

    if (markdownLineEnding(code) && (kind === 6 || kind === 7)) {
      return effects.check(
        nextBlankConstruct,
        continuationClose,
        continuationAtLineEnding
      )(code)
    }

    if (code === null || markdownLineEnding(code)) {
      return continuationAtLineEnding(code)
    }

    effects.consume(code)
    return continuation
  }

  function continuationAtLineEnding(code) {
    effects.exit('htmlFlowData')
    return htmlContinueStart(code)
  }

  function htmlContinueStart(code) {
    if (code === null) {
      return done(code)
    }

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      return htmlContinueStart
    }

    effects.enter('htmlFlowData')
    return continuation(code)
  }

  function continuationCommentInside(code) {
    if (code === 45) {
      effects.consume(code)
      return continuationDeclarationInside
    }

    return continuation(code)
  }

  function continuationRawTagOpen(code) {
    if (code === 47) {
      effects.consume(code)
      buffer = ''
      return continuationRawEndTag
    }

    return continuation(code)
  }

  function continuationRawEndTag(code) {
    if (code === 62 && htmlRawNames.indexOf(buffer.toLowerCase()) > -1) {
      effects.consume(code)
      return continuationClose
    }

    if (asciiAlpha(code) && buffer.length < 8) {
      effects.consume(code)
      buffer += fromCharCode(code)
      return continuationRawEndTag
    }

    return continuation(code)
  }

  function continuationCharacterDataInside(code) {
    if (code === 93) {
      effects.consume(code)
      return continuationDeclarationInside
    }

    return continuation(code)
  }

  function continuationDeclarationInside(code) {
    if (code === 62) {
      effects.consume(code)
      return continuationClose
    }

    return continuation(code)
  }

  function continuationClose(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('htmlFlowData')
      return done(code)
    }

    effects.consume(code)
    return continuationClose
  }

  function done(code) {
    effects.exit('htmlFlow')
    return ok(code)
  }
}

function tokenizeNextBlank(effects, ok, nok) {
  return start

  function start(code) {
    effects.exit('htmlFlowData')
    effects.enter('lineEndingBlank')
    effects.consume(code)
    effects.exit('lineEndingBlank')
    return effects.attempt(partialBlankLine, ok, nok)
  }
}

module.exports = htmlFlow


/***/ }),

/***/ 7743:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var asciiAlpha = __webpack_require__(3847)
var asciiAlphanumeric = __webpack_require__(598)
var markdownLineEnding = __webpack_require__(7506)
var markdownLineEndingOrSpace = __webpack_require__(9180)
var markdownSpace = __webpack_require__(5989)
var factorySpace = __webpack_require__(8200)

var htmlText = {
  name: 'htmlText',
  tokenize: tokenizeHtmlText
}

function tokenizeHtmlText(effects, ok, nok) {
  var self = this
  var marker
  var buffer
  var index
  var returnState
  return start

  function start(code) {
    effects.enter('htmlText')
    effects.enter('htmlTextData')
    effects.consume(code)
    return open
  }

  function open(code) {
    if (code === 33) {
      effects.consume(code)
      return declarationOpen
    }

    if (code === 47) {
      effects.consume(code)
      return tagCloseStart
    }

    if (code === 63) {
      effects.consume(code)
      return instruction
    }

    if (asciiAlpha(code)) {
      effects.consume(code)
      return tagOpen
    }

    return nok(code)
  }

  function declarationOpen(code) {
    if (code === 45) {
      effects.consume(code)
      return commentOpen
    }

    if (code === 91) {
      effects.consume(code)
      buffer = 'CDATA['
      index = 0
      return cdataOpen
    }

    if (asciiAlpha(code)) {
      effects.consume(code)
      return declaration
    }

    return nok(code)
  }

  function commentOpen(code) {
    if (code === 45) {
      effects.consume(code)
      return commentStart
    }

    return nok(code)
  }

  function commentStart(code) {
    if (code === null || code === 62) {
      return nok(code)
    }

    if (code === 45) {
      effects.consume(code)
      return commentStartDash
    }

    return comment(code)
  }

  function commentStartDash(code) {
    if (code === null || code === 62) {
      return nok(code)
    }

    return comment(code)
  }

  function comment(code) {
    if (code === null) {
      return nok(code)
    }

    if (code === 45) {
      effects.consume(code)
      return commentClose
    }

    if (markdownLineEnding(code)) {
      returnState = comment
      return atLineEnding(code)
    }

    effects.consume(code)
    return comment
  }

  function commentClose(code) {
    if (code === 45) {
      effects.consume(code)
      return end
    }

    return comment(code)
  }

  function cdataOpen(code) {
    if (code === buffer.charCodeAt(index++)) {
      effects.consume(code)
      return index === buffer.length ? cdata : cdataOpen
    }

    return nok(code)
  }

  function cdata(code) {
    if (code === null) {
      return nok(code)
    }

    if (code === 93) {
      effects.consume(code)
      return cdataClose
    }

    if (markdownLineEnding(code)) {
      returnState = cdata
      return atLineEnding(code)
    }

    effects.consume(code)
    return cdata
  }

  function cdataClose(code) {
    if (code === 93) {
      effects.consume(code)
      return cdataEnd
    }

    return cdata(code)
  }

  function cdataEnd(code) {
    if (code === 62) {
      return end(code)
    }

    if (code === 93) {
      effects.consume(code)
      return cdataEnd
    }

    return cdata(code)
  }

  function declaration(code) {
    if (code === null || code === 62) {
      return end(code)
    }

    if (markdownLineEnding(code)) {
      returnState = declaration
      return atLineEnding(code)
    }

    effects.consume(code)
    return declaration
  }

  function instruction(code) {
    if (code === null) {
      return nok(code)
    }

    if (code === 63) {
      effects.consume(code)
      return instructionClose
    }

    if (markdownLineEnding(code)) {
      returnState = instruction
      return atLineEnding(code)
    }

    effects.consume(code)
    return instruction
  }

  function instructionClose(code) {
    return code === 62 ? end(code) : instruction(code)
  }

  function tagCloseStart(code) {
    if (asciiAlpha(code)) {
      effects.consume(code)
      return tagClose
    }

    return nok(code)
  }

  function tagClose(code) {
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code)
      return tagClose
    }

    return tagCloseBetween(code)
  }

  function tagCloseBetween(code) {
    if (markdownLineEnding(code)) {
      returnState = tagCloseBetween
      return atLineEnding(code)
    }

    if (markdownSpace(code)) {
      effects.consume(code)
      return tagCloseBetween
    }

    return end(code)
  }

  function tagOpen(code) {
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code)
      return tagOpen
    }

    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code)
    }

    return nok(code)
  }

  function tagOpenBetween(code) {
    if (code === 47) {
      effects.consume(code)
      return end
    }

    if (code === 58 || code === 95 || asciiAlpha(code)) {
      effects.consume(code)
      return tagOpenAttributeName
    }

    if (markdownLineEnding(code)) {
      returnState = tagOpenBetween
      return atLineEnding(code)
    }

    if (markdownSpace(code)) {
      effects.consume(code)
      return tagOpenBetween
    }

    return end(code)
  }

  function tagOpenAttributeName(code) {
    if (
      code === 45 ||
      code === 46 ||
      code === 58 ||
      code === 95 ||
      asciiAlphanumeric(code)
    ) {
      effects.consume(code)
      return tagOpenAttributeName
    }

    return tagOpenAttributeNameAfter(code)
  }

  function tagOpenAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code)
      return tagOpenAttributeValueBefore
    }

    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeNameAfter
      return atLineEnding(code)
    }

    if (markdownSpace(code)) {
      effects.consume(code)
      return tagOpenAttributeNameAfter
    }

    return tagOpenBetween(code)
  }

  function tagOpenAttributeValueBefore(code) {
    if (
      code === null ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96
    ) {
      return nok(code)
    }

    if (code === 34 || code === 39) {
      effects.consume(code)
      marker = code
      return tagOpenAttributeValueQuoted
    }

    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeValueBefore
      return atLineEnding(code)
    }

    if (markdownSpace(code)) {
      effects.consume(code)
      return tagOpenAttributeValueBefore
    }

    effects.consume(code)
    marker = undefined
    return tagOpenAttributeValueUnquoted
  }

  function tagOpenAttributeValueQuoted(code) {
    if (code === marker) {
      effects.consume(code)
      return tagOpenAttributeValueQuotedAfter
    }

    if (code === null) {
      return nok(code)
    }

    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeValueQuoted
      return atLineEnding(code)
    }

    effects.consume(code)
    return tagOpenAttributeValueQuoted
  }

  function tagOpenAttributeValueQuotedAfter(code) {
    if (code === 62 || code === 47 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code)
    }

    return nok(code)
  }

  function tagOpenAttributeValueUnquoted(code) {
    if (
      code === null ||
      code === 34 ||
      code === 39 ||
      code === 60 ||
      code === 61 ||
      code === 96
    ) {
      return nok(code)
    }

    if (code === 62 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code)
    }

    effects.consume(code)
    return tagOpenAttributeValueUnquoted
  } // We can’t have blank lines in content, so no need to worry about empty
  // tokens.

  function atLineEnding(code) {
    effects.exit('htmlTextData')
    effects.enter('lineEnding')
    effects.consume(code)
    effects.exit('lineEnding')
    return factorySpace(
      effects,
      afterPrefix,
      'linePrefix',
      self.parser.constructs.disable.null.indexOf('codeIndented') > -1
        ? undefined
        : 4
    )
  }

  function afterPrefix(code) {
    effects.enter('htmlTextData')
    return returnState(code)
  }

  function end(code) {
    if (code === 62) {
      effects.consume(code)
      effects.exit('htmlTextData')
      effects.exit('htmlText')
      return ok
    }

    return nok(code)
  }
}

module.exports = htmlText


/***/ }),

/***/ 9797:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEndingOrSpace = __webpack_require__(9180)
var chunkedPush = __webpack_require__(4455)
var chunkedSplice = __webpack_require__(778)
var normalizeIdentifier = __webpack_require__(712)
var resolveAll = __webpack_require__(2004)
var shallow = __webpack_require__(1479)
var factoryDestination = __webpack_require__(9851)
var factoryLabel = __webpack_require__(349)
var factoryTitle = __webpack_require__(9469)
var factoryWhitespace = __webpack_require__(3168)

var labelEnd = {
  name: 'labelEnd',
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
}
var resourceConstruct = {
  tokenize: tokenizeResource
}
var fullReferenceConstruct = {
  tokenize: tokenizeFullReference
}
var collapsedReferenceConstruct = {
  tokenize: tokenizeCollapsedReference
}

function resolveAllLabelEnd(events) {
  var index = -1
  var token

  while (++index < events.length) {
    token = events[index][1]

    if (
      !token._used &&
      (token.type === 'labelImage' ||
        token.type === 'labelLink' ||
        token.type === 'labelEnd')
    ) {
      // Remove the marker.
      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)
      token.type = 'data'
      index++
    }
  }

  return events
}

function resolveToLabelEnd(events, context) {
  var index = events.length
  var offset = 0
  var group
  var label
  var text
  var token
  var open
  var close
  var media // Find an opening.

  while (index--) {
    token = events[index][1]

    if (open) {
      // If we see another link, or inactive link label, we’ve been here before.
      if (
        token.type === 'link' ||
        (token.type === 'labelLink' && token._inactive)
      ) {
        break
      } // Mark other link openings as inactive, as we can’t have links in
      // links.

      if (events[index][0] === 'enter' && token.type === 'labelLink') {
        token._inactive = true
      }
    } else if (close) {
      if (
        events[index][0] === 'enter' &&
        (token.type === 'labelImage' || token.type === 'labelLink') &&
        !token._balanced
      ) {
        open = index

        if (token.type !== 'labelLink') {
          offset = 2
          break
        }
      }
    } else if (token.type === 'labelEnd') {
      close = index
    }
  }

  group = {
    type: events[open][1].type === 'labelLink' ? 'link' : 'image',
    start: shallow(events[open][1].start),
    end: shallow(events[events.length - 1][1].end)
  }
  label = {
    type: 'label',
    start: shallow(events[open][1].start),
    end: shallow(events[close][1].end)
  }
  text = {
    type: 'labelText',
    start: shallow(events[open + offset + 2][1].end),
    end: shallow(events[close - 2][1].start)
  }
  media = [
    ['enter', group, context],
    ['enter', label, context]
  ] // Opening marker.

  media = chunkedPush(media, events.slice(open + 1, open + offset + 3)) // Text open.

  media = chunkedPush(media, [['enter', text, context]]) // Between.

  media = chunkedPush(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close - 3),
      context
    )
  ) // Text close, marker close, label close.

  media = chunkedPush(media, [
    ['exit', text, context],
    events[close - 2],
    events[close - 1],
    ['exit', label, context]
  ]) // Reference, resource, or so.

  media = chunkedPush(media, events.slice(close + 1)) // Media close.

  media = chunkedPush(media, [['exit', group, context]])
  chunkedSplice(events, open, events.length, media)
  return events
}

function tokenizeLabelEnd(effects, ok, nok) {
  var self = this
  var index = self.events.length
  var labelStart
  var defined // Find an opening.

  while (index--) {
    if (
      (self.events[index][1].type === 'labelImage' ||
        self.events[index][1].type === 'labelLink') &&
      !self.events[index][1]._balanced
    ) {
      labelStart = self.events[index][1]
      break
    }
  }

  return start

  function start(code) {
    if (!labelStart) {
      return nok(code)
    } // It’s a balanced bracket, but contains a link.

    if (labelStart._inactive) return balanced(code)
    defined =
      self.parser.defined.indexOf(
        normalizeIdentifier(
          self.sliceSerialize({
            start: labelStart.end,
            end: self.now()
          })
        )
      ) > -1
    effects.enter('labelEnd')
    effects.enter('labelMarker')
    effects.consume(code)
    effects.exit('labelMarker')
    effects.exit('labelEnd')
    return afterLabelEnd
  }

  function afterLabelEnd(code) {
    // Resource: `[asd](fgh)`.
    if (code === 40) {
      return effects.attempt(
        resourceConstruct,
        ok,
        defined ? ok : balanced
      )(code)
    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?

    if (code === 91) {
      return effects.attempt(
        fullReferenceConstruct,
        ok,
        defined
          ? effects.attempt(collapsedReferenceConstruct, ok, balanced)
          : balanced
      )(code)
    } // Shortcut reference: `[asd]`?

    return defined ? ok(code) : balanced(code)
  }

  function balanced(code) {
    labelStart._balanced = true
    return nok(code)
  }
}

function tokenizeResource(effects, ok, nok) {
  return start

  function start(code) {
    effects.enter('resource')
    effects.enter('resourceMarker')
    effects.consume(code)
    effects.exit('resourceMarker')
    return factoryWhitespace(effects, open)
  }

  function open(code) {
    if (code === 41) {
      return end(code)
    }

    return factoryDestination(
      effects,
      destinationAfter,
      nok,
      'resourceDestination',
      'resourceDestinationLiteral',
      'resourceDestinationLiteralMarker',
      'resourceDestinationRaw',
      'resourceDestinationString',
      3
    )(code)
  }

  function destinationAfter(code) {
    return markdownLineEndingOrSpace(code)
      ? factoryWhitespace(effects, between)(code)
      : end(code)
  }

  function between(code) {
    if (code === 34 || code === 39 || code === 40) {
      return factoryTitle(
        effects,
        factoryWhitespace(effects, end),
        nok,
        'resourceTitle',
        'resourceTitleMarker',
        'resourceTitleString'
      )(code)
    }

    return end(code)
  }

  function end(code) {
    if (code === 41) {
      effects.enter('resourceMarker')
      effects.consume(code)
      effects.exit('resourceMarker')
      effects.exit('resource')
      return ok
    }

    return nok(code)
  }
}

function tokenizeFullReference(effects, ok, nok) {
  var self = this
  return start

  function start(code) {
    return factoryLabel.call(
      self,
      effects,
      afterLabel,
      nok,
      'reference',
      'referenceMarker',
      'referenceString'
    )(code)
  }

  function afterLabel(code) {
    return self.parser.defined.indexOf(
      normalizeIdentifier(
        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
      )
    ) < 0
      ? nok(code)
      : ok(code)
  }
}

function tokenizeCollapsedReference(effects, ok, nok) {
  return start

  function start(code) {
    effects.enter('reference')
    effects.enter('referenceMarker')
    effects.consume(code)
    effects.exit('referenceMarker')
    return open
  }

  function open(code) {
    if (code === 93) {
      effects.enter('referenceMarker')
      effects.consume(code)
      effects.exit('referenceMarker')
      effects.exit('reference')
      return ok
    }

    return nok(code)
  }
}

module.exports = labelEnd


/***/ }),

/***/ 7860:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var labelEnd = __webpack_require__(9797)

var labelStartImage = {
  name: 'labelStartImage',
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
}

function tokenizeLabelStartImage(effects, ok, nok) {
  var self = this
  return start

  function start(code) {
    effects.enter('labelImage')
    effects.enter('labelImageMarker')
    effects.consume(code)
    effects.exit('labelImageMarker')
    return open
  }

  function open(code) {
    if (code === 91) {
      effects.enter('labelMarker')
      effects.consume(code)
      effects.exit('labelMarker')
      effects.exit('labelImage')
      return after
    }

    return nok(code)
  }

  function after(code) {
    /* c8 ignore next */
    return code === 94 &&
      /* c8 ignore next */
      '_hiddenFootnoteSupport' in self.parser.constructs
      ? /* c8 ignore next */
        nok(code)
      : ok(code)
  }
}

module.exports = labelStartImage


/***/ }),

/***/ 5908:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var labelEnd = __webpack_require__(9797)

var labelStartLink = {
  name: 'labelStartLink',
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
}

function tokenizeLabelStartLink(effects, ok, nok) {
  var self = this
  return start

  function start(code) {
    effects.enter('labelLink')
    effects.enter('labelMarker')
    effects.consume(code)
    effects.exit('labelMarker')
    effects.exit('labelLink')
    return after
  }

  function after(code) {
    /* c8 ignore next */
    return code === 94 &&
      /* c8 ignore next */
      '_hiddenFootnoteSupport' in self.parser.constructs
      ? /* c8 ignore next */
        nok(code)
      : ok(code)
  }
}

module.exports = labelStartLink


/***/ }),

/***/ 5183:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var factorySpace = __webpack_require__(8200)

var lineEnding = {
  name: 'lineEnding',
  tokenize: tokenizeLineEnding
}

function tokenizeLineEnding(effects, ok) {
  return start

  function start(code) {
    effects.enter('lineEnding')
    effects.consume(code)
    effects.exit('lineEnding')
    return factorySpace(effects, ok, 'linePrefix')
  }
}

module.exports = lineEnding


/***/ }),

/***/ 3107:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var asciiDigit = __webpack_require__(6996)
var markdownSpace = __webpack_require__(5989)
var prefixSize = __webpack_require__(3722)
var sizeChunks = __webpack_require__(5041)
var factorySpace = __webpack_require__(8200)
var partialBlankLine = __webpack_require__(2244)
var thematicBreak = __webpack_require__(5590)

var list = {
  name: 'list',
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
}
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
}
var indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
}

function tokenizeListStart(effects, ok, nok) {
  var self = this
  var initialSize = prefixSize(self.events, 'linePrefix')
  var size = 0
  return start

  function start(code) {
    var kind =
      self.containerState.type ||
      (code === 42 || code === 43 || code === 45
        ? 'listUnordered'
        : 'listOrdered')

    if (
      kind === 'listUnordered'
        ? !self.containerState.marker || code === self.containerState.marker
        : asciiDigit(code)
    ) {
      if (!self.containerState.type) {
        self.containerState.type = kind
        effects.enter(kind, {
          _container: true
        })
      }

      if (kind === 'listUnordered') {
        effects.enter('listItemPrefix')
        return code === 42 || code === 45
          ? effects.check(thematicBreak, nok, atMarker)(code)
          : atMarker(code)
      }

      if (!self.interrupt || code === 49) {
        effects.enter('listItemPrefix')
        effects.enter('listItemValue')
        return inside(code)
      }
    }

    return nok(code)
  }

  function inside(code) {
    if (asciiDigit(code) && ++size < 10) {
      effects.consume(code)
      return inside
    }

    if (
      (!self.interrupt || size < 2) &&
      (self.containerState.marker
        ? code === self.containerState.marker
        : code === 41 || code === 46)
    ) {
      effects.exit('listItemValue')
      return atMarker(code)
    }

    return nok(code)
  }

  function atMarker(code) {
    effects.enter('listItemMarker')
    effects.consume(code)
    effects.exit('listItemMarker')
    self.containerState.marker = self.containerState.marker || code
    return effects.check(
      partialBlankLine, // Can’t be empty when interrupting.
      self.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    )
  }

  function onBlank(code) {
    self.containerState.initialBlankLine = true
    initialSize++
    return endOfPrefix(code)
  }

  function otherPrefix(code) {
    if (markdownSpace(code)) {
      effects.enter('listItemPrefixWhitespace')
      effects.consume(code)
      effects.exit('listItemPrefixWhitespace')
      return endOfPrefix
    }

    return nok(code)
  }

  function endOfPrefix(code) {
    self.containerState.size =
      initialSize + sizeChunks(self.sliceStream(effects.exit('listItemPrefix')))
    return ok(code)
  }
}

function tokenizeListContinuation(effects, ok, nok) {
  var self = this
  self.containerState._closeFlow = undefined
  return effects.check(partialBlankLine, onBlank, notBlank)

  function onBlank(code) {
    self.containerState.furtherBlankLines =
      self.containerState.furtherBlankLines ||
      self.containerState.initialBlankLine // We have a blank line.
    // Still, try to consume at most the items size.

    return factorySpace(
      effects,
      ok,
      'listItemIndent',
      self.containerState.size + 1
    )(code)
  }

  function notBlank(code) {
    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {
      self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined
      return notInCurrentItem(code)
    }

    self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined
    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)
  }

  function notInCurrentItem(code) {
    // While we do continue, we signal that the flow should be closed.
    self.containerState._closeFlow = true // As we’re closing flow, we’re no longer interrupting.

    self.interrupt = undefined
    return factorySpace(
      effects,
      effects.attempt(list, ok, nok),
      'linePrefix',
      self.parser.constructs.disable.null.indexOf('codeIndented') > -1
        ? undefined
        : 4
    )(code)
  }
}

function tokenizeIndent(effects, ok, nok) {
  var self = this
  return factorySpace(
    effects,
    afterPrefix,
    'listItemIndent',
    self.containerState.size + 1
  )

  function afterPrefix(code) {
    return prefixSize(self.events, 'listItemIndent') ===
      self.containerState.size
      ? ok(code)
      : nok(code)
  }
}

function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type)
}

function tokenizeListItemPrefixWhitespace(effects, ok, nok) {
  var self = this
  return factorySpace(
    effects,
    afterPrefix,
    'listItemPrefixWhitespace',
    self.parser.constructs.disable.null.indexOf('codeIndented') > -1
      ? undefined
      : 4 + 1
  )

  function afterPrefix(code) {
    return markdownSpace(code) ||
      !prefixSize(self.events, 'listItemPrefixWhitespace')
      ? nok(code)
      : ok(code)
  }
}

module.exports = list


/***/ }),

/***/ 2244:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(7506)
var factorySpace = __webpack_require__(8200)

var partialBlankLine = {
  tokenize: tokenizePartialBlankLine,
  partial: true
}

function tokenizePartialBlankLine(effects, ok, nok) {
  return factorySpace(effects, afterWhitespace, 'linePrefix')

  function afterWhitespace(code) {
    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)
  }
}

module.exports = partialBlankLine


/***/ }),

/***/ 1196:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(7506)
var shallow = __webpack_require__(1479)
var factorySpace = __webpack_require__(8200)

var setextUnderline = {
  name: 'setextUnderline',
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
}

function resolveToSetextUnderline(events, context) {
  var index = events.length
  var content
  var text
  var definition
  var heading // Find the opening of the content.
  // It’ll always exist: we don’t tokenize if it isn’t there.

  while (index--) {
    if (events[index][0] === 'enter') {
      if (events[index][1].type === 'content') {
        content = index
        break
      }

      if (events[index][1].type === 'paragraph') {
        text = index
      }
    } // Exit
    else {
      if (events[index][1].type === 'content') {
        // Remove the content end (if needed we’ll add it later)
        events.splice(index, 1)
      }

      if (!definition && events[index][1].type === 'definition') {
        definition = index
      }
    }
  }

  heading = {
    type: 'setextHeading',
    start: shallow(events[text][1].start),
    end: shallow(events[events.length - 1][1].end)
  } // Change the paragraph to setext heading text.

  events[text][1].type = 'setextHeadingText' // If we have definitions in the content, we’ll keep on having content,
  // but we need move it.

  if (definition) {
    events.splice(text, 0, ['enter', heading, context])
    events.splice(definition + 1, 0, ['exit', events[content][1], context])
    events[content][1].end = shallow(events[definition][1].end)
  } else {
    events[content][1] = heading
  } // Add the heading exit at the end.

  events.push(['exit', heading, context])
  return events
}

function tokenizeSetextUnderline(effects, ok, nok) {
  var self = this
  var index = self.events.length
  var marker
  var paragraph // Find an opening.

  while (index--) {
    // Skip enter/exit of line ending, line prefix, and content.
    // We can now either have a definition or a paragraph.
    if (
      self.events[index][1].type !== 'lineEnding' &&
      self.events[index][1].type !== 'linePrefix' &&
      self.events[index][1].type !== 'content'
    ) {
      paragraph = self.events[index][1].type === 'paragraph'
      break
    }
  }

  return start

  function start(code) {
    if (!self.lazy && (self.interrupt || paragraph)) {
      effects.enter('setextHeadingLine')
      effects.enter('setextHeadingLineSequence')
      marker = code
      return closingSequence(code)
    }

    return nok(code)
  }

  function closingSequence(code) {
    if (code === marker) {
      effects.consume(code)
      return closingSequence
    }

    effects.exit('setextHeadingLineSequence')
    return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code)
  }

  function closingSequenceEnd(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('setextHeadingLine')
      return ok(code)
    }

    return nok(code)
  }
}

module.exports = setextUnderline


/***/ }),

/***/ 5590:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(7506)
var markdownSpace = __webpack_require__(5989)
var factorySpace = __webpack_require__(8200)

var thematicBreak = {
  name: 'thematicBreak',
  tokenize: tokenizeThematicBreak
}

function tokenizeThematicBreak(effects, ok, nok) {
  var size = 0
  var marker
  return start

  function start(code) {
    effects.enter('thematicBreak')
    marker = code
    return atBreak(code)
  }

  function atBreak(code) {
    if (code === marker) {
      effects.enter('thematicBreakSequence')
      return sequence(code)
    }

    if (markdownSpace(code)) {
      return factorySpace(effects, atBreak, 'whitespace')(code)
    }

    if (size < 3 || (code !== null && !markdownLineEnding(code))) {
      return nok(code)
    }

    effects.exit('thematicBreak')
    return ok(code)
  }

  function sequence(code) {
    if (code === marker) {
      effects.consume(code)
      size++
      return sequence
    }

    effects.exit('thematicBreakSequence')
    return atBreak(code)
  }
}

module.exports = thematicBreak


/***/ }),

/***/ 4455:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var chunkedSplice = __webpack_require__(778)

function chunkedPush(list, items) {
  if (list.length) {
    chunkedSplice(list, list.length, 0, items)
    return list
  }

  return items
}

module.exports = chunkedPush


/***/ }),

/***/ 778:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var splice = __webpack_require__(2366)

// causes a stack overflow in V8 when trying to insert 100k items for instance.

function chunkedSplice(list, start, remove, items) {
  var end = list.length
  var chunkStart = 0
  var parameters // Make start between zero and `end` (included).

  if (start < 0) {
    start = -start > end ? 0 : end + start
  } else {
    start = start > end ? end : start
  }

  remove = remove > 0 ? remove : 0 // No need to chunk the items if there’s only a couple (10k) items.

  if (items.length < 10000) {
    parameters = Array.from(items)
    parameters.unshift(start, remove)
    splice.apply(list, parameters)
  } else {
    // Delete `remove` items starting from `start`
    if (remove) splice.apply(list, [start, remove]) // Insert the items in chunks to not cause stack overflows.

    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 10000)
      parameters.unshift(start, 0)
      splice.apply(list, parameters)
      chunkStart += 10000
      start += 10000
    }
  }
}

module.exports = chunkedSplice


/***/ }),

/***/ 1324:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEndingOrSpace = __webpack_require__(9180)
var unicodePunctuation = __webpack_require__(9372)
var unicodeWhitespace = __webpack_require__(9968)

// Classify whether a character is unicode whitespace, unicode punctuation, or
// anything else.
// Used for attention (emphasis, strong), whose sequences can open or close
// based on the class of surrounding characters.
function classifyCharacter(code) {
  if (
    code === null ||
    markdownLineEndingOrSpace(code) ||
    unicodeWhitespace(code)
  ) {
    return 1
  }

  if (unicodePunctuation(code)) {
    return 2
  }
}

module.exports = classifyCharacter


/***/ }),

/***/ 8602:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasOwnProperty = __webpack_require__(3500)
var chunkedSplice = __webpack_require__(778)
var miniflat = __webpack_require__(9042)

function combineExtensions(extensions) {
  var all = {}
  var index = -1

  while (++index < extensions.length) {
    extension(all, extensions[index])
  }

  return all
}

function extension(all, extension) {
  var hook
  var left
  var right
  var code

  for (hook in extension) {
    left = hasOwnProperty.call(all, hook) ? all[hook] : (all[hook] = {})
    right = extension[hook]

    for (code in right) {
      left[code] = constructs(
        miniflat(right[code]),
        hasOwnProperty.call(left, code) ? left[code] : []
      )
    }
  }
}

function constructs(list, existing) {
  var index = -1
  var before = []

  while (++index < list.length) {
    ;(list[index].add === 'after' ? existing : before).push(list[index])
  }

  chunkedSplice(existing, 0, 0, before)
  return existing
}

module.exports = combineExtensions


/***/ }),

/***/ 4845:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(3512)
var markdownLineEnding = __webpack_require__(7506)
var chunkedPush = __webpack_require__(4455)
var chunkedSplice = __webpack_require__(778)
var miniflat = __webpack_require__(9042)
var resolveAll = __webpack_require__(2004)
var serializeChunks = __webpack_require__(4363)
var shallow = __webpack_require__(1479)
var sliceChunks = __webpack_require__(7271)

// Create a tokenizer.
// Tokenizers deal with one type of data (e.g., containers, flow, text).
// The parser is the object dealing with it all.
// `initialize` works like other constructs, except that only its `tokenize`
// function is used, in which case it doesn’t receive an `ok` or `nok`.
// `from` can be given to set the point before the first character, although
// when further lines are indented, they must be set with `defineSkip`.
function createTokenizer(parser, initialize, from) {
  var point = from
    ? shallow(from)
    : {
        line: 1,
        column: 1,
        offset: 0
      }
  var columnStart = {}
  var resolveAllConstructs = []
  var chunks = []
  var stack = []

  var effects = {
    consume: consume,
    enter: enter,
    exit: exit,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    }),
    lazy: constructFactory(onsuccessfulcheck, {
      lazy: true
    })
  } // State and tools for resolving and serializing.

  var context = {
    previous: null,
    events: [],
    parser: parser,
    sliceStream: sliceStream,
    sliceSerialize: sliceSerialize,
    now: now,
    defineSkip: skip,
    write: write
  } // The state function.

  var state = initialize.tokenize.call(context, effects) // Track which character we expect to be consumed, to catch bugs.

  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize)
  } // Store where we are in the input stream.

  point._index = 0
  point._bufferIndex = -1
  return context

  function write(slice) {
    chunks = chunkedPush(chunks, slice)
    main() // Exit if we’re not done, resolve might change stuff.

    if (chunks[chunks.length - 1] !== null) {
      return []
    }

    addResult(initialize, 0) // Otherwise, resolve, and exit.

    context.events = resolveAll(resolveAllConstructs, context.events, context)
    return context.events
  } //
  // Tools.
  //

  function sliceSerialize(token) {
    return serializeChunks(sliceStream(token))
  }

  function sliceStream(token) {
    return sliceChunks(chunks, token)
  }

  function now() {
    return shallow(point)
  }

  function skip(value) {
    columnStart[value.line] = value.column
    accountForPotentialSkip()
  } //
  // State management.
  //
  // Main loop (note that `_index` and `_bufferIndex` in `point` are modified by
  // `consume`).
  // Here is where we walk through the chunks, which either include strings of
  // several characters, or numerical character codes.
  // The reason to do this in a loop instead of a call is so the stack can
  // drain.

  function main() {
    var chunkIndex
    var chunk

    while (point._index < chunks.length) {
      chunk = chunks[point._index] // If we’re in a buffer chunk, loop through it.

      if (typeof chunk === 'string') {
        chunkIndex = point._index

        if (point._bufferIndex < 0) {
          point._bufferIndex = 0
        }

        while (
          point._index === chunkIndex &&
          point._bufferIndex < chunk.length
        ) {
          go(chunk.charCodeAt(point._bufferIndex))
        }
      } else {
        go(chunk)
      }
    }
  } // Deal with one code.

  function go(code) {
    state = state(code)
  } // Move a character forward.

  function consume(code) {
    if (markdownLineEnding(code)) {
      point.line++
      point.column = 1
      point.offset += code === -3 ? 2 : 1
      accountForPotentialSkip()
    } else if (code !== -1) {
      point.column++
      point.offset++
    } // Not in a string chunk.

    if (point._bufferIndex < 0) {
      point._index++
    } else {
      point._bufferIndex++ // At end of string chunk.

      if (point._bufferIndex === chunks[point._index].length) {
        point._bufferIndex = -1
        point._index++
      }
    } // Expose the previous character.

    context.previous = code // Mark as consumed.
  } // Start a token.

  function enter(type, fields) {
    var token = fields || {}
    token.type = type
    token.start = now()
    context.events.push(['enter', token, context])
    stack.push(token)
    return token
  } // Stop a token.

  function exit(type) {
    var token = stack.pop()
    token.end = now()
    context.events.push(['exit', token, context])
    return token
  } // Use results.

  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from)
  } // Discard results.

  function onsuccessfulcheck(construct, info) {
    info.restore()
  } // Factory to attempt/check/interrupt.

  function constructFactory(onreturn, fields) {
    return hook // Handle either an object mapping codes to constructs, a list of
    // constructs, or a single construct.

    function hook(constructs, returnState, bogusState) {
      var listOfConstructs
      var constructIndex
      var currentConstruct
      var info
      return constructs.tokenize || 'length' in constructs
        ? handleListOfConstructs(miniflat(constructs))
        : handleMapOfConstructs

      function handleMapOfConstructs(code) {
        if (code in constructs || null in constructs) {
          return handleListOfConstructs(
            constructs.null
              ? /* c8 ignore next */
                miniflat(constructs[code]).concat(miniflat(constructs.null))
              : constructs[code]
          )(code)
        }

        return bogusState(code)
      }

      function handleListOfConstructs(list) {
        listOfConstructs = list
        constructIndex = 0
        return handleConstruct(list[constructIndex])
      }

      function handleConstruct(construct) {
        return start

        function start(code) {
          // To do: not nede to store if there is no bogus state, probably?
          // Currently doesn’t work because `inspect` in document does a check
          // w/o a bogus, which doesn’t make sense. But it does seem to help perf
          // by not storing.
          info = store()
          currentConstruct = construct

          if (!construct.partial) {
            context.currentConstruct = construct
          }

          if (
            construct.name &&
            context.parser.constructs.disable.null.indexOf(construct.name) > -1
          ) {
            return nok()
          }

          return construct.tokenize.call(
            fields ? assign({}, context, fields) : context,
            effects,
            ok,
            nok
          )(code)
        }
      }

      function ok(code) {
        onreturn(currentConstruct, info)
        return returnState
      }

      function nok(code) {
        info.restore()

        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex])
        }

        return bogusState
      }
    }
  }

  function addResult(construct, from) {
    if (construct.resolveAll && resolveAllConstructs.indexOf(construct) < 0) {
      resolveAllConstructs.push(construct)
    }

    if (construct.resolve) {
      chunkedSplice(
        context.events,
        from,
        context.events.length - from,
        construct.resolve(context.events.slice(from), context)
      )
    }

    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context)
    }
  }

  function store() {
    var startPoint = now()
    var startPrevious = context.previous
    var startCurrentConstruct = context.currentConstruct
    var startEventsIndex = context.events.length
    var startStack = Array.from(stack)
    return {
      restore: restore,
      from: startEventsIndex
    }

    function restore() {
      point = startPoint
      context.previous = startPrevious
      context.currentConstruct = startCurrentConstruct
      context.events.length = startEventsIndex
      stack = startStack
      accountForPotentialSkip()
    }
  }

  function accountForPotentialSkip() {
    if (point.line in columnStart && point.column < 2) {
      point.column = columnStart[point.line]
      point.offset += columnStart[point.line] - 1
    }
  }
}

module.exports = createTokenizer


/***/ }),

/***/ 9042:
/***/ ((module) => {

"use strict";


function miniflat(value) {
  return value === null || value === undefined
    ? []
    : 'length' in value
    ? value
    : [value]
}

module.exports = miniflat


/***/ }),

/***/ 6985:
/***/ ((module) => {

"use strict";


// chunks (replacement characters, tabs, or line endings).

function movePoint(point, offset) {
  point.column += offset
  point.offset += offset
  point._bufferIndex += offset
  return point
}

module.exports = movePoint


/***/ }),

/***/ 712:
/***/ ((module) => {

"use strict";


function normalizeIdentifier(value) {
  return (
    value // Collapse Markdown whitespace.
      .replace(/[\t\n\r ]+/g, ' ') // Trim.
      .replace(/^ | $/g, '') // Some characters are considered “uppercase”, but if their lowercase
      // counterpart is uppercased will result in a different uppercase
      // character.
      // Hence, to get that form, we perform both lower- and uppercase.
      // Upper case makes sure keys will not interact with default prototypal
      // methods: no object method is uppercase.
      .toLowerCase()
      .toUpperCase()
  )
}

module.exports = normalizeIdentifier


/***/ }),

/***/ 3722:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var sizeChunks = __webpack_require__(5041)

function prefixSize(events, type) {
  var tail = events[events.length - 1]
  if (!tail || tail[1].type !== type) return 0
  return sizeChunks(tail[2].sliceStream(tail[1]))
}

module.exports = prefixSize


/***/ }),

/***/ 1028:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fromCharCode = __webpack_require__(3531)

function regexCheck(regex) {
  return check

  function check(code) {
    return regex.test(fromCharCode(code))
  }
}

module.exports = regexCheck


/***/ }),

/***/ 2004:
/***/ ((module) => {

"use strict";


function resolveAll(constructs, events, context) {
  var called = []
  var index = -1
  var resolve

  while (++index < constructs.length) {
    resolve = constructs[index].resolveAll

    if (resolve && called.indexOf(resolve) < 0) {
      events = resolve(events, context)
      called.push(resolve)
    }
  }

  return events
}

module.exports = resolveAll


/***/ }),

/***/ 6214:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fromCharCode = __webpack_require__(3531)

function safeFromInt(value, base) {
  var code = parseInt(value, base)

  if (
    // C0 except for HT, LF, FF, CR, space
    code < 9 ||
    code === 11 ||
    (code > 13 && code < 32) || // Control character (DEL) of the basic block and C1 controls.
    (code > 126 && code < 160) || // Lone high surrogates and low surrogates.
    (code > 55295 && code < 57344) || // Noncharacters.
    (code > 64975 && code < 65008) ||
    (code & 65535) === 65535 ||
    (code & 65535) === 65534 || // Out of range
    code > 1114111
  ) {
    return '\uFFFD'
  }

  return fromCharCode(code)
}

module.exports = safeFromInt


/***/ }),

/***/ 4363:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fromCharCode = __webpack_require__(3531)

function serializeChunks(chunks) {
  var index = -1
  var result = []
  var chunk
  var value
  var atTab

  while (++index < chunks.length) {
    chunk = chunks[index]

    if (typeof chunk === 'string') {
      value = chunk
    } else if (chunk === -5) {
      value = '\r'
    } else if (chunk === -4) {
      value = '\n'
    } else if (chunk === -3) {
      value = '\r' + '\n'
    } else if (chunk === -2) {
      value = '\t'
    } else if (chunk === -1) {
      if (atTab) continue
      value = ' '
    } else {
      // Currently only replacement character.
      value = fromCharCode(chunk)
    }

    atTab = chunk === -2
    result.push(value)
  }

  return result.join('')
}

module.exports = serializeChunks


/***/ }),

/***/ 1479:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(3512)

function shallow(object) {
  return assign({}, object)
}

module.exports = shallow


/***/ }),

/***/ 5041:
/***/ ((module) => {

"use strict";


// Counts tabs based on their expanded size, and CR+LF as one character.

function sizeChunks(chunks) {
  var index = -1
  var size = 0

  while (++index < chunks.length) {
    size += typeof chunks[index] === 'string' ? chunks[index].length : 1
  }

  return size
}

module.exports = sizeChunks


/***/ }),

/***/ 7271:
/***/ ((module) => {

"use strict";


function sliceChunks(chunks, token) {
  var startIndex = token.start._index
  var startBufferIndex = token.start._bufferIndex
  var endIndex = token.end._index
  var endBufferIndex = token.end._bufferIndex
  var view

  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]
  } else {
    view = chunks.slice(startIndex, endIndex)

    if (startBufferIndex > -1) {
      view[0] = view[0].slice(startBufferIndex)
    }

    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex))
    }
  }

  return view
}

module.exports = sliceChunks


/***/ }),

/***/ 14:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(3512)
var chunkedSplice = __webpack_require__(778)
var shallow = __webpack_require__(1479)

function subtokenize(events) {
  var jumps = {}
  var index = -1
  var event
  var lineIndex
  var otherIndex
  var otherEvent
  var parameters
  var subevents
  var more

  while (++index < events.length) {
    while (index in jumps) {
      index = jumps[index]
    }

    event = events[index] // Add a hook for the GFM tasklist extension, which needs to know if text
    // is in the first content of a list item.

    if (
      index &&
      event[1].type === 'chunkFlow' &&
      events[index - 1][1].type === 'listItemPrefix'
    ) {
      subevents = event[1]._tokenizer.events
      otherIndex = 0

      if (
        otherIndex < subevents.length &&
        subevents[otherIndex][1].type === 'lineEndingBlank'
      ) {
        otherIndex += 2
      }

      if (
        otherIndex < subevents.length &&
        subevents[otherIndex][1].type === 'content'
      ) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === 'content') {
            break
          }

          if (subevents[otherIndex][1].type === 'chunkText') {
            subevents[otherIndex][1].isInFirstContentOfListItem = true
            otherIndex++
          }
        }
      }
    } // Enter.

    if (event[0] === 'enter') {
      if (event[1].contentType) {
        assign(jumps, subcontent(events, index))
        index = jumps[index]
        more = true
      }
    } // Exit.
    else if (event[1]._container || event[1]._movePreviousLineEndings) {
      otherIndex = index
      lineIndex = undefined

      while (otherIndex--) {
        otherEvent = events[otherIndex]

        if (
          otherEvent[1].type === 'lineEnding' ||
          otherEvent[1].type === 'lineEndingBlank'
        ) {
          if (otherEvent[0] === 'enter') {
            if (lineIndex) {
              events[lineIndex][1].type = 'lineEndingBlank'
            }

            otherEvent[1].type = 'lineEnding'
            lineIndex = otherIndex
          }
        } else {
          break
        }
      }

      if (lineIndex) {
        // Fix position.
        event[1].end = shallow(events[lineIndex][1].start) // Switch container exit w/ line endings.

        parameters = events.slice(lineIndex, index)
        parameters.unshift(event)
        chunkedSplice(events, lineIndex, index - lineIndex + 1, parameters)
      }
    }
  }

  return !more
}

function subcontent(events, eventIndex) {
  var token = events[eventIndex][1]
  var context = events[eventIndex][2]
  var startPosition = eventIndex - 1
  var startPositions = []
  var tokenizer =
    token._tokenizer || context.parser[token.contentType](token.start)
  var childEvents = tokenizer.events
  var jumps = []
  var gaps = {}
  var stream
  var previous
  var index
  var entered
  var end
  var adjust // Loop forward through the linked tokens to pass them in order to the
  // subtokenizer.

  while (token) {
    // Find the position of the event for this token.
    while (events[++startPosition][1] !== token) {
      // Empty.
    }

    startPositions.push(startPosition)

    if (!token._tokenizer) {
      stream = context.sliceStream(token)

      if (!token.next) {
        stream.push(null)
      }

      if (previous) {
        tokenizer.defineSkip(token.start)
      }

      if (token.isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true
      }

      tokenizer.write(stream)

      if (token.isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = undefined
      }
    } // Unravel the next token.

    previous = token
    token = token.next
  } // Now, loop back through all events (and linked tokens), to figure out which
  // parts belong where.

  token = previous
  index = childEvents.length

  while (index--) {
    // Make sure we’ve at least seen something (final eol is part of the last
    // token).
    if (childEvents[index][0] === 'enter') {
      entered = true
    } else if (
      // Find a void token that includes a break.
      entered &&
      childEvents[index][1].type === childEvents[index - 1][1].type &&
      childEvents[index][1].start.line !== childEvents[index][1].end.line
    ) {
      add(childEvents.slice(index + 1, end))
      // Help GC.
      token._tokenizer = token.next = undefined
      token = token.previous
      end = index + 1
    }
  }

  // Help GC.
  tokenizer.events = token._tokenizer = token.next = undefined // Do head:

  add(childEvents.slice(0, end))
  index = -1
  adjust = 0

  while (++index < jumps.length) {
    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1]
    adjust += jumps[index][1] - jumps[index][0] - 1
  }

  return gaps

  function add(slice) {
    var start = startPositions.pop()
    jumps.unshift([start, start + slice.length - 1])
    chunkedSplice(events, start, 2, slice)
  }
}

module.exports = subtokenize


/***/ }),

/***/ 3973:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: '/' }
try {
  path = __webpack_require__(5622)
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __webpack_require__(3717)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ 467:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Stream = _interopDefault(__webpack_require__(2413));
var http = _interopDefault(__webpack_require__(8605));
var Url = _interopDefault(__webpack_require__(8835));
var https = _interopDefault(__webpack_require__(7211));
var zlib = _interopDefault(__webpack_require__(8761));

// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

// fix for "Readable" isn't a named export issue
const Readable = Stream.Readable;

const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');

class Blob {
	constructor() {
		this[TYPE] = '';

		const blobParts = arguments[0];
		const options = arguments[1];

		const buffers = [];
		let size = 0;

		if (blobParts) {
			const a = blobParts;
			const length = Number(a.length);
			for (let i = 0; i < length; i++) {
				const element = a[i];
				let buffer;
				if (element instanceof Buffer) {
					buffer = element;
				} else if (ArrayBuffer.isView(element)) {
					buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
				} else if (element instanceof ArrayBuffer) {
					buffer = Buffer.from(element);
				} else if (element instanceof Blob) {
					buffer = element[BUFFER];
				} else {
					buffer = Buffer.from(typeof element === 'string' ? element : String(element));
				}
				size += buffer.length;
				buffers.push(buffer);
			}
		}

		this[BUFFER] = Buffer.concat(buffers);

		let type = options && options.type !== undefined && String(options.type).toLowerCase();
		if (type && !/[^\u0020-\u007E]/.test(type)) {
			this[TYPE] = type;
		}
	}
	get size() {
		return this[BUFFER].length;
	}
	get type() {
		return this[TYPE];
	}
	text() {
		return Promise.resolve(this[BUFFER].toString());
	}
	arrayBuffer() {
		const buf = this[BUFFER];
		const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		return Promise.resolve(ab);
	}
	stream() {
		const readable = new Readable();
		readable._read = function () {};
		readable.push(this[BUFFER]);
		readable.push(null);
		return readable;
	}
	toString() {
		return '[object Blob]';
	}
	slice() {
		const size = this.size;

		const start = arguments[0];
		const end = arguments[1];
		let relativeStart, relativeEnd;
		if (start === undefined) {
			relativeStart = 0;
		} else if (start < 0) {
			relativeStart = Math.max(size + start, 0);
		} else {
			relativeStart = Math.min(start, size);
		}
		if (end === undefined) {
			relativeEnd = size;
		} else if (end < 0) {
			relativeEnd = Math.max(size + end, 0);
		} else {
			relativeEnd = Math.min(end, size);
		}
		const span = Math.max(relativeEnd - relativeStart, 0);

		const buffer = this[BUFFER];
		const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
		const blob = new Blob([], { type: arguments[2] });
		blob[BUFFER] = slicedBuffer;
		return blob;
	}
}

Object.defineProperties(Blob.prototype, {
	size: { enumerable: true },
	type: { enumerable: true },
	slice: { enumerable: true }
});

Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
	value: 'Blob',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */

/**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */
function FetchError(message, type, systemError) {
  Error.call(this, message);

  this.message = message;
  this.type = type;

  // when err.type is `system`, err.code contains system error code
  if (systemError) {
    this.code = this.errno = systemError.code;
  }

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';

let convert;
try {
	convert = __webpack_require__(2877).convert;
} catch (e) {}

const INTERNALS = Symbol('Body internals');

// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = Stream.PassThrough;

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
function Body(body) {
	var _this = this;

	var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref$size = _ref.size;

	let size = _ref$size === undefined ? 0 : _ref$size;
	var _ref$timeout = _ref.timeout;
	let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

	if (body == null) {
		// body is undefined or null
		body = null;
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		body = Buffer.from(body.toString());
	} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		body = Buffer.from(body);
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
	} else if (body instanceof Stream) ; else {
		// none of the above
		// coerce to string then buffer
		body = Buffer.from(String(body));
	}
	this[INTERNALS] = {
		body,
		disturbed: false,
		error: null
	};
	this.size = size;
	this.timeout = timeout;

	if (body instanceof Stream) {
		body.on('error', function (err) {
			const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
			_this[INTERNALS].error = error;
		});
	}
}

Body.prototype = {
	get body() {
		return this[INTERNALS].body;
	},

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	},

	/**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */
	arrayBuffer() {
		return consumeBody.call(this).then(function (buf) {
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		});
	},

	/**
  * Return raw response as Blob
  *
  * @return Promise
  */
	blob() {
		let ct = this.headers && this.headers.get('content-type') || '';
		return consumeBody.call(this).then(function (buf) {
			return Object.assign(
			// Prevent copying
			new Blob([], {
				type: ct.toLowerCase()
			}), {
				[BUFFER]: buf
			});
		});
	},

	/**
  * Decode response as json
  *
  * @return  Promise
  */
	json() {
		var _this2 = this;

		return consumeBody.call(this).then(function (buffer) {
			try {
				return JSON.parse(buffer.toString());
			} catch (err) {
				return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
			}
		});
	},

	/**
  * Decode response as text
  *
  * @return  Promise
  */
	text() {
		return consumeBody.call(this).then(function (buffer) {
			return buffer.toString();
		});
	},

	/**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */
	buffer() {
		return consumeBody.call(this);
	},

	/**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */
	textConverted() {
		var _this3 = this;

		return consumeBody.call(this).then(function (buffer) {
			return convertBody(buffer, _this3.headers);
		});
	}
};

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: { enumerable: true },
	bodyUsed: { enumerable: true },
	arrayBuffer: { enumerable: true },
	blob: { enumerable: true },
	json: { enumerable: true },
	text: { enumerable: true }
});

Body.mixIn = function (proto) {
	for (const name of Object.getOwnPropertyNames(Body.prototype)) {
		// istanbul ignore else: future proof
		if (!(name in proto)) {
			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
			Object.defineProperty(proto, name, desc);
		}
	}
};

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */
function consumeBody() {
	var _this4 = this;

	if (this[INTERNALS].disturbed) {
		return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
	}

	this[INTERNALS].disturbed = true;

	if (this[INTERNALS].error) {
		return Body.Promise.reject(this[INTERNALS].error);
	}

	let body = this.body;

	// body is null
	if (body === null) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is blob
	if (isBlob(body)) {
		body = body.stream();
	}

	// body is buffer
	if (Buffer.isBuffer(body)) {
		return Body.Promise.resolve(body);
	}

	// istanbul ignore if: should never happen
	if (!(body instanceof Stream)) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is stream
	// get ready to actually consume the body
	let accum = [];
	let accumBytes = 0;
	let abort = false;

	return new Body.Promise(function (resolve, reject) {
		let resTimeout;

		// allow timeout on slow response body
		if (_this4.timeout) {
			resTimeout = setTimeout(function () {
				abort = true;
				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
			}, _this4.timeout);
		}

		// handle stream errors
		body.on('error', function (err) {
			if (err.name === 'AbortError') {
				// if the request was aborted, reject with this Error
				abort = true;
				reject(err);
			} else {
				// other errors, such as incorrect content-encoding
				reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
			}
		});

		body.on('data', function (chunk) {
			if (abort || chunk === null) {
				return;
			}

			if (_this4.size && accumBytes + chunk.length > _this4.size) {
				abort = true;
				reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
				return;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		});

		body.on('end', function () {
			if (abort) {
				return;
			}

			clearTimeout(resTimeout);

			try {
				resolve(Buffer.concat(accum, accumBytes));
			} catch (err) {
				// handle streams that have accumulated too much data (issue #414)
				reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
			}
		});
	});
}

/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */
function convertBody(buffer, headers) {
	if (typeof convert !== 'function') {
		throw new Error('The package `encoding` must be installed to use the textConverted() function');
	}

	const ct = headers.get('content-type');
	let charset = 'utf-8';
	let res, str;

	// header
	if (ct) {
		res = /charset=([^;]*)/i.exec(ct);
	}

	// no charset in content type, peek at response body for at most 1024 bytes
	str = buffer.slice(0, 1024).toString();

	// html5
	if (!res && str) {
		res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
	}

	// html4
	if (!res && str) {
		res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
		if (!res) {
			res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
			if (res) {
				res.pop(); // drop last quote
			}
		}

		if (res) {
			res = /charset=(.*)/i.exec(res.pop());
		}
	}

	// xml
	if (!res && str) {
		res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
	}

	// found charset
	if (res) {
		charset = res.pop();

		// prevent decode issues when sites use incorrect encoding
		// ref: https://hsivonen.fi/encoding-menu/
		if (charset === 'gb2312' || charset === 'gbk') {
			charset = 'gb18030';
		}
	}

	// turn raw buffers into a single utf-8 buffer
	return convert(buffer, 'UTF-8', charset).toString();
}

/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */
function isURLSearchParams(obj) {
	// Duck-typing as a necessary condition.
	if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
		return false;
	}

	// Brand-checking and more duck-typing as optional condition.
	return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob(obj) {
	return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */
function clone(instance) {
	let p1, p2;
	let body = instance.body;

	// don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if (body instanceof Stream && typeof body.getBoundary !== 'function') {
		// tee instance body
		p1 = new PassThrough();
		p2 = new PassThrough();
		body.pipe(p1);
		body.pipe(p2);
		// set instance body to teed body and return the other teed body
		instance[INTERNALS].body = p1;
		body = p2;
	}

	return body;
}

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */
function extractContentType(body) {
	if (body === null) {
		// body is null
		return null;
	} else if (typeof body === 'string') {
		// body is string
		return 'text/plain;charset=UTF-8';
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	} else if (isBlob(body)) {
		// body is blob
		return body.type || null;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return null;
	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		return null;
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		return null;
	} else if (typeof body.getBoundary === 'function') {
		// detect form data input from form-data module
		return `multipart/form-data;boundary=${body.getBoundary()}`;
	} else if (body instanceof Stream) {
		// body is stream
		// can't really do much about this
		return null;
	} else {
		// Body constructor defaults other things to string
		return 'text/plain;charset=UTF-8';
	}
}

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */
function getTotalBytes(instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		return 0;
	} else if (isBlob(body)) {
		return body.size;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return body.length;
	} else if (body && typeof body.getLengthSync === 'function') {
		// detect form data input from form-data module
		if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
		body.hasKnownLength && body.hasKnownLength()) {
			// 2.x
			return body.getLengthSync();
		}
		return null;
	} else {
		// body is stream
		return null;
	}
}

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */
function writeToStream(dest, instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		dest.end();
	} else if (isBlob(body)) {
		body.stream().pipe(dest);
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		dest.write(body);
		dest.end();
	} else {
		// body is stream
		body.pipe(dest);
	}
}

// expose Promise
Body.Promise = global.Promise;

/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */

const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

function validateName(name) {
	name = `${name}`;
	if (invalidTokenRegex.test(name) || name === '') {
		throw new TypeError(`${name} is not a legal HTTP header name`);
	}
}

function validateValue(value) {
	value = `${value}`;
	if (invalidHeaderCharRegex.test(value)) {
		throw new TypeError(`${value} is not a legal HTTP header value`);
	}
}

/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */
function find(map, name) {
	name = name.toLowerCase();
	for (const key in map) {
		if (key.toLowerCase() === name) {
			return key;
		}
	}
	return undefined;
}

const MAP = Symbol('map');
class Headers {
	/**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */
	constructor() {
		let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

		this[MAP] = Object.create(null);

		if (init instanceof Headers) {
			const rawHeaders = init.raw();
			const headerNames = Object.keys(rawHeaders);

			for (const headerName of headerNames) {
				for (const value of rawHeaders[headerName]) {
					this.append(headerName, value);
				}
			}

			return;
		}

		// We don't worry about converting prop to ByteString here as append()
		// will handle it.
		if (init == null) ; else if (typeof init === 'object') {
			const method = init[Symbol.iterator];
			if (method != null) {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				const pairs = [];
				for (const pair of init) {
					if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
						throw new TypeError('Each header pair must be iterable');
					}
					pairs.push(Array.from(pair));
				}

				for (const pair of pairs) {
					if (pair.length !== 2) {
						throw new TypeError('Each header pair must be a name/value tuple');
					}
					this.append(pair[0], pair[1]);
				}
			} else {
				// record<ByteString, ByteString>
				for (const key of Object.keys(init)) {
					const value = init[key];
					this.append(key, value);
				}
			}
		} else {
			throw new TypeError('Provided initializer must be an object');
		}
	}

	/**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */
	get(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key === undefined) {
			return null;
		}

		return this[MAP][key].join(', ');
	}

	/**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */
	forEach(callback) {
		let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

		let pairs = getHeaders(this);
		let i = 0;
		while (i < pairs.length) {
			var _pairs$i = pairs[i];
			const name = _pairs$i[0],
			      value = _pairs$i[1];

			callback.call(thisArg, value, name, this);
			pairs = getHeaders(this);
			i++;
		}
	}

	/**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	set(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		this[MAP][key !== undefined ? key : name] = [value];
	}

	/**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	append(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			this[MAP][key].push(value);
		} else {
			this[MAP][name] = [value];
		}
	}

	/**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */
	has(name) {
		name = `${name}`;
		validateName(name);
		return find(this[MAP], name) !== undefined;
	}

	/**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */
	delete(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			delete this[MAP][key];
		}
	}

	/**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */
	raw() {
		return this[MAP];
	}

	/**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */
	keys() {
		return createHeadersIterator(this, 'key');
	}

	/**
  * Get an iterator on values.
  *
  * @return  Iterator
  */
	values() {
		return createHeadersIterator(this, 'value');
	}

	/**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */
	[Symbol.iterator]() {
		return createHeadersIterator(this, 'key+value');
	}
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];

Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
	value: 'Headers',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Headers.prototype, {
	get: { enumerable: true },
	forEach: { enumerable: true },
	set: { enumerable: true },
	append: { enumerable: true },
	has: { enumerable: true },
	delete: { enumerable: true },
	keys: { enumerable: true },
	values: { enumerable: true },
	entries: { enumerable: true }
});

function getHeaders(headers) {
	let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';

	const keys = Object.keys(headers[MAP]).sort();
	return keys.map(kind === 'key' ? function (k) {
		return k.toLowerCase();
	} : kind === 'value' ? function (k) {
		return headers[MAP][k].join(', ');
	} : function (k) {
		return [k.toLowerCase(), headers[MAP][k].join(', ')];
	});
}

const INTERNAL = Symbol('internal');

function createHeadersIterator(target, kind) {
	const iterator = Object.create(HeadersIteratorPrototype);
	iterator[INTERNAL] = {
		target,
		kind,
		index: 0
	};
	return iterator;
}

const HeadersIteratorPrototype = Object.setPrototypeOf({
	next() {
		// istanbul ignore if
		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
			throw new TypeError('Value of `this` is not a HeadersIterator');
		}

		var _INTERNAL = this[INTERNAL];
		const target = _INTERNAL.target,
		      kind = _INTERNAL.kind,
		      index = _INTERNAL.index;

		const values = getHeaders(target, kind);
		const len = values.length;
		if (index >= len) {
			return {
				value: undefined,
				done: true
			};
		}

		this[INTERNAL].index = index + 1;

		return {
			value: values[index],
			done: false
		};
	}
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
	value: 'HeadersIterator',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */
function exportNodeCompatibleHeaders(headers) {
	const obj = Object.assign({ __proto__: null }, headers[MAP]);

	// http.request() only supports string as Host header. This hack makes
	// specifying custom Host header possible.
	const hostHeaderKey = find(headers[MAP], 'Host');
	if (hostHeaderKey !== undefined) {
		obj[hostHeaderKey] = obj[hostHeaderKey][0];
	}

	return obj;
}

/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */
function createHeadersLenient(obj) {
	const headers = new Headers();
	for (const name of Object.keys(obj)) {
		if (invalidTokenRegex.test(name)) {
			continue;
		}
		if (Array.isArray(obj[name])) {
			for (const val of obj[name]) {
				if (invalidHeaderCharRegex.test(val)) {
					continue;
				}
				if (headers[MAP][name] === undefined) {
					headers[MAP][name] = [val];
				} else {
					headers[MAP][name].push(val);
				}
			}
		} else if (!invalidHeaderCharRegex.test(obj[name])) {
			headers[MAP][name] = [obj[name]];
		}
	}
	return headers;
}

const INTERNALS$1 = Symbol('Response internals');

// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = http.STATUS_CODES;

/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response {
	constructor() {
		let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		Body.call(this, body, opts);

		const status = opts.status || 200;
		const headers = new Headers(opts.headers);

		if (body != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(body);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[INTERNALS$1] = {
			url: opts.url,
			status,
			statusText: opts.statusText || STATUS_CODES[status],
			headers,
			counter: opts.counter
		};
	}

	get url() {
		return this[INTERNALS$1].url || '';
	}

	get status() {
		return this[INTERNALS$1].status;
	}

	/**
  * Convenience property representing if the request ended normally
  */
	get ok() {
		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
	}

	get redirected() {
		return this[INTERNALS$1].counter > 0;
	}

	get statusText() {
		return this[INTERNALS$1].statusText;
	}

	get headers() {
		return this[INTERNALS$1].headers;
	}

	/**
  * Clone this response
  *
  * @return  Response
  */
	clone() {
		return new Response(clone(this), {
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected
		});
	}
}

Body.mixIn(Response.prototype);

Object.defineProperties(Response.prototype, {
	url: { enumerable: true },
	status: { enumerable: true },
	ok: { enumerable: true },
	redirected: { enumerable: true },
	statusText: { enumerable: true },
	headers: { enumerable: true },
	clone: { enumerable: true }
});

Object.defineProperty(Response.prototype, Symbol.toStringTag, {
	value: 'Response',
	writable: false,
	enumerable: false,
	configurable: true
});

const INTERNALS$2 = Symbol('Request internals');

// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = Url.parse;
const format_url = Url.format;

const streamDestructionSupported = 'destroy' in Stream.Readable.prototype;

/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */
function isRequest(input) {
	return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}

function isAbortSignal(signal) {
	const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
	return !!(proto && proto.constructor.name === 'AbortSignal');
}

/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request {
	constructor(input) {
		let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		let parsedURL;

		// normalize input
		if (!isRequest(input)) {
			if (input && input.href) {
				// in order to support Node.js' Url objects; though WHATWG's URL objects
				// will fall into this branch also (since their `toString()` will return
				// `href` property anyway)
				parsedURL = parse_url(input.href);
			} else {
				// coerce input to a string before attempting to parse
				parsedURL = parse_url(`${input}`);
			}
			input = {};
		} else {
			parsedURL = parse_url(input.url);
		}

		let method = init.method || input.method || 'GET';
		method = method.toUpperCase();

		if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;

		Body.call(this, inputBody, {
			timeout: init.timeout || input.timeout || 0,
			size: init.size || input.size || 0
		});

		const headers = new Headers(init.headers || input.headers || {});

		if (inputBody != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(inputBody);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ? input.signal : null;
		if ('signal' in init) signal = init.signal;

		if (signal != null && !isAbortSignal(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal');
		}

		this[INTERNALS$2] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal
		};

		// node-fetch-only options
		this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
		this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
	}

	get method() {
		return this[INTERNALS$2].method;
	}

	get url() {
		return format_url(this[INTERNALS$2].parsedURL);
	}

	get headers() {
		return this[INTERNALS$2].headers;
	}

	get redirect() {
		return this[INTERNALS$2].redirect;
	}

	get signal() {
		return this[INTERNALS$2].signal;
	}

	/**
  * Clone this request
  *
  * @return  Request
  */
	clone() {
		return new Request(this);
	}
}

Body.mixIn(Request.prototype);

Object.defineProperty(Request.prototype, Symbol.toStringTag, {
	value: 'Request',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Request.prototype, {
	method: { enumerable: true },
	url: { enumerable: true },
	headers: { enumerable: true },
	redirect: { enumerable: true },
	clone: { enumerable: true },
	signal: { enumerable: true }
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */
function getNodeRequestOptions(request) {
	const parsedURL = request[INTERNALS$2].parsedURL;
	const headers = new Headers(request[INTERNALS$2].headers);

	// fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// Basic fetch
	if (!parsedURL.protocol || !parsedURL.hostname) {
		throw new TypeError('Only absolute URLs are supported');
	}

	if (!/^https?:$/.test(parsedURL.protocol)) {
		throw new TypeError('Only HTTP(S) protocols are supported');
	}

	if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
		throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
		contentLengthValue = '0';
	}
	if (request.body != null) {
		const totalBytes = getTotalBytes(request);
		if (typeof totalBytes === 'number') {
			contentLengthValue = String(totalBytes);
		}
	}
	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip,deflate');
	}

	let agent = request.agent;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	if (!headers.has('Connection') && !agent) {
		headers.set('Connection', 'close');
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	return Object.assign({}, parsedURL, {
		method: request.method,
		headers: exportNodeCompatibleHeaders(headers),
		agent
	});
}

/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */

/**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */
function AbortError(message) {
  Error.call(this, message);

  this.type = 'aborted';
  this.message = message;

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';

// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = Stream.PassThrough;
const resolve_url = Url.resolve;

/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */
function fetch(url, opts) {

	// allow custom promise
	if (!fetch.Promise) {
		throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
	}

	Body.Promise = fetch.Promise;

	// wrap http.request into fetch
	return new fetch.Promise(function (resolve, reject) {
		// build request object
		const request = new Request(url, opts);
		const options = getNodeRequestOptions(request);

		const send = (options.protocol === 'https:' ? https : http).request;
		const signal = request.signal;

		let response = null;

		const abort = function abort() {
			let error = new AbortError('The user aborted a request.');
			reject(error);
			if (request.body && request.body instanceof Stream.Readable) {
				request.body.destroy(error);
			}
			if (!response || !response.body) return;
			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = function abortAndFinalize() {
			abort();
			finalize();
		};

		// send request
		const req = send(options);
		let reqTimeout;

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		function finalize() {
			req.abort();
			if (signal) signal.removeEventListener('abort', abortAndFinalize);
			clearTimeout(reqTimeout);
		}

		if (request.timeout) {
			req.once('socket', function (socket) {
				reqTimeout = setTimeout(function () {
					reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
					finalize();
				}, request.timeout);
			});
		}

		req.on('error', function (err) {
			reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
			finalize();
		});

		req.on('response', function (res) {
			clearTimeout(reqTimeout);

			const headers = createHeadersLenient(res.headers);

			// HTTP fetch step 5
			if (fetch.isRedirect(res.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				const locationURL = location === null ? null : resolve_url(request.url, location);

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
						if (locationURL !== null) {
							// handle corrupted header
							try {
								headers.set('Location', locationURL);
							} catch (err) {
								// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
								reject(err);
							}
						}
						break;
					case 'follow':
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOpts = {
							headers: new Headers(request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: request.body,
							signal: request.signal,
							timeout: request.timeout,
							size: request.size
						};

						// HTTP-redirect fetch step 9
						if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
							requestOpts.method = 'GET';
							requestOpts.body = undefined;
							requestOpts.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 15
						resolve(fetch(new Request(locationURL, requestOpts)));
						finalize();
						return;
				}
			}

			// prepare response
			res.once('end', function () {
				if (signal) signal.removeEventListener('abort', abortAndFinalize);
			});
			let body = res.pipe(new PassThrough$1());

			const response_options = {
				url: request.url,
				status: res.statusCode,
				statusText: res.statusMessage,
				headers: headers,
				size: request.size,
				timeout: request.timeout,
				counter: request.counter
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: zlib.Z_SYNC_FLUSH,
				finishFlush: zlib.Z_SYNC_FLUSH
			};

			// for gzip
			if (codings == 'gzip' || codings == 'x-gzip') {
				body = body.pipe(zlib.createGunzip(zlibOptions));
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// for deflate
			if (codings == 'deflate' || codings == 'x-deflate') {
				// handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = res.pipe(new PassThrough$1());
				raw.once('data', function (chunk) {
					// see http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = body.pipe(zlib.createInflate());
					} else {
						body = body.pipe(zlib.createInflateRaw());
					}
					response = new Response(body, response_options);
					resolve(response);
				});
				return;
			}

			// for br
			if (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {
				body = body.pipe(zlib.createBrotliDecompress());
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// otherwise, use response as-is
			response = new Response(body, response_options);
			resolve(response);
		});

		writeToStream(req, request);
	});
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */
fetch.isRedirect = function (code) {
	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};

// expose Promise
fetch.Promise = global.Promise;

module.exports = exports = fetch;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.default = exports;
exports.Headers = Headers;
exports.Request = Request;
exports.Response = Response;
exports.FetchError = FetchError;


/***/ }),

/***/ 1223:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(2940)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ 3485:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var characterEntities = __webpack_require__(3407)

module.exports = decodeEntity

var own = {}.hasOwnProperty

function decodeEntity(characters) {
  return own.call(characterEntities, characters)
    ? characterEntities[characters]
    : false
}


/***/ }),

/***/ 8714:
/***/ ((module) => {

"use strict";


function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;


/***/ }),

/***/ 5881:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// full library entry point.


module.exports = __webpack_require__(5360);


/***/ }),

/***/ 6916:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// minimal library entry point.


module.exports = __webpack_require__(3242);


/***/ }),

/***/ 2134:
/***/ ((module) => {

"use strict";

module.exports = common;

var commonRe = /\/|\./;

/**
 * Provides common type definitions.
 * Can also be used to provide additional google types or your own custom types.
 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
 * @returns {undefined}
 * @property {INamespace} google/protobuf/any.proto Any
 * @property {INamespace} google/protobuf/duration.proto Duration
 * @property {INamespace} google/protobuf/empty.proto Empty
 * @property {INamespace} google/protobuf/field_mask.proto FieldMask
 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
 * @example
 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
 * protobuf.common("descriptor", descriptorJson);
 *
 * // manually provides a custom definition (uses my.foo namespace)
 * protobuf.common("my/foo/bar.proto", myFooBarJson);
 */
function common(name, json) {
    if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
    }
    common[name] = json;
}

// Not provided because of limited use (feel free to discuss or to provide yourself):
//
// google/protobuf/descriptor.proto
// google/protobuf/source_context.proto
// google/protobuf/type.proto
//
// Stripped and pre-parsed versions of these non-bundled files are instead available as part of
// the repository or package within the google/protobuf directory.

common("any", {

    /**
     * Properties of a google.protobuf.Any message.
     * @interface IAny
     * @type {Object}
     * @property {string} [typeUrl]
     * @property {Uint8Array} [bytes]
     * @memberof common
     */
    Any: {
        fields: {
            type_url: {
                type: "string",
                id: 1
            },
            value: {
                type: "bytes",
                id: 2
            }
        }
    }
});

var timeType;

common("duration", {

    /**
     * Properties of a google.protobuf.Duration message.
     * @interface IDuration
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Duration: timeType = {
        fields: {
            seconds: {
                type: "int64",
                id: 1
            },
            nanos: {
                type: "int32",
                id: 2
            }
        }
    }
});

common("timestamp", {

    /**
     * Properties of a google.protobuf.Timestamp message.
     * @interface ITimestamp
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Timestamp: timeType
});

common("empty", {

    /**
     * Properties of a google.protobuf.Empty message.
     * @interface IEmpty
     * @memberof common
     */
    Empty: {
        fields: {}
    }
});

common("struct", {

    /**
     * Properties of a google.protobuf.Struct message.
     * @interface IStruct
     * @type {Object}
     * @property {Object.<string,IValue>} [fields]
     * @memberof common
     */
    Struct: {
        fields: {
            fields: {
                keyType: "string",
                type: "Value",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Value message.
     * @interface IValue
     * @type {Object}
     * @property {string} [kind]
     * @property {0} [nullValue]
     * @property {number} [numberValue]
     * @property {string} [stringValue]
     * @property {boolean} [boolValue]
     * @property {IStruct} [structValue]
     * @property {IListValue} [listValue]
     * @memberof common
     */
    Value: {
        oneofs: {
            kind: {
                oneof: [
                    "nullValue",
                    "numberValue",
                    "stringValue",
                    "boolValue",
                    "structValue",
                    "listValue"
                ]
            }
        },
        fields: {
            nullValue: {
                type: "NullValue",
                id: 1
            },
            numberValue: {
                type: "double",
                id: 2
            },
            stringValue: {
                type: "string",
                id: 3
            },
            boolValue: {
                type: "bool",
                id: 4
            },
            structValue: {
                type: "Struct",
                id: 5
            },
            listValue: {
                type: "ListValue",
                id: 6
            }
        }
    },

    NullValue: {
        values: {
            NULL_VALUE: 0
        }
    },

    /**
     * Properties of a google.protobuf.ListValue message.
     * @interface IListValue
     * @type {Object}
     * @property {Array.<IValue>} [values]
     * @memberof common
     */
    ListValue: {
        fields: {
            values: {
                rule: "repeated",
                type: "Value",
                id: 1
            }
        }
    }
});

common("wrappers", {

    /**
     * Properties of a google.protobuf.DoubleValue message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    DoubleValue: {
        fields: {
            value: {
                type: "double",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.FloatValue message.
     * @interface IFloatValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FloatValue: {
        fields: {
            value: {
                type: "float",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int64Value message.
     * @interface IInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    Int64Value: {
        fields: {
            value: {
                type: "int64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt64Value message.
     * @interface IUInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    UInt64Value: {
        fields: {
            value: {
                type: "uint64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int32Value message.
     * @interface IInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    Int32Value: {
        fields: {
            value: {
                type: "int32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt32Value message.
     * @interface IUInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    UInt32Value: {
        fields: {
            value: {
                type: "uint32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BoolValue message.
     * @interface IBoolValue
     * @type {Object}
     * @property {boolean} [value]
     * @memberof common
     */
    BoolValue: {
        fields: {
            value: {
                type: "bool",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.StringValue message.
     * @interface IStringValue
     * @type {Object}
     * @property {string} [value]
     * @memberof common
     */
    StringValue: {
        fields: {
            value: {
                type: "string",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BytesValue message.
     * @interface IBytesValue
     * @type {Object}
     * @property {Uint8Array} [value]
     * @memberof common
     */
    BytesValue: {
        fields: {
            value: {
                type: "bytes",
                id: 1
            }
        }
    }
});

common("field_mask", {

    /**
     * Properties of a google.protobuf.FieldMask message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FieldMask: {
        fields: {
            paths: {
                rule: "repeated",
                type: "string",
                id: 1
            }
        }
    }
});

/**
 * Gets the root definition of the specified common proto file.
 *
 * Bundled definitions are:
 * - google/protobuf/any.proto
 * - google/protobuf/duration.proto
 * - google/protobuf/empty.proto
 * - google/protobuf/field_mask.proto
 * - google/protobuf/struct.proto
 * - google/protobuf/timestamp.proto
 * - google/protobuf/wrappers.proto
 *
 * @param {string} file Proto file name
 * @returns {INamespace|null} Root definition or `null` if not defined
 */
common.get = function get(file) {
    return common[file] || null;
};


/***/ }),

/***/ 3617:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Runtime message from/to plain object converters.
 * @namespace
 */
var converter = exports;

var Enum = __webpack_require__(7732),
    util = __webpack_require__(7174);

/**
 * Generates a partial value fromObject conveter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                if (field.repeated && values[keys[i]] === field.typeDefault) gen
                ("default:");
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.fromObject = function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined && !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

/**
 * Generates a partial value toObject converter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.toObject = function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) {
                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
                gen
        ("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))
        ("else{")
            ("d%s=%s", prop, arrayDefault)
            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
        ("}");
            } else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&&m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};


/***/ }),

/***/ 5871:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = decoder;

var Enum    = __webpack_require__(7732),
    types   = __webpack_require__(6581),
    util    = __webpack_require__(7174);

function missing(field) {
    return "missing required '" + field.name + "'";
}

/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k,value" : ""))
    ("while(r.pos<c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&7)===4)")
            ("break");
    gen
        ("switch(t>>>3){");

    var i = 0;
    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %i:", field.id);

        // Map fields
        if (field.map) { gen
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("var c2 = r.uint32()+r.pos");

            if (types.defaults[field.keyType] !== undefined) gen
                ("k=%j", types.defaults[field.keyType]);
            else gen
                ("k=null");

            if (types.defaults[type] !== undefined) gen
                ("value=%j", types.defaults[type]);
            else gen
                ("value=null");

            gen
                ("while(r.pos<c2){")
                    ("var tag2=r.uint32()")
                    ("switch(tag2>>>3){")
                        ("case 1: k=r.%s(); break", field.keyType)
                        ("case 2:");

            if (types.basic[type] === undefined) gen
                            ("value=types[%i].decode(r,r.uint32())", i); // can't be groups
            else gen
                            ("value=r.%s()", type);

            gen
                            ("break")
                        ("default:")
                            ("r.skipType(tag2&7)")
                            ("break")
                    ("}")
                ("}");

            if (types.long[field.keyType] !== undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=value", ref);
            else gen
                ("%s[k]=value", ref);

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&&%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos<c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%i].decode(r))"
                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break");
    // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}


/***/ }),

/***/ 3072:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = encoder;

var Enum     = __webpack_require__(7732),
    types    = __webpack_require__(6581),
    util     = __webpack_require__(7174);

/**
 * Generates a partial message type encoder.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
}

/**
 * Generates an encoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) { gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}


/***/ }),

/***/ 7732:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(3575);
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var Namespace = __webpack_require__(6189),
    util = __webpack_require__(7174);

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {Object.<string,number>} [values] Enum values as an object, by name
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this enum
 * @param {Object.<string,string>} [comments] The value comments for this enum
 */
function Enum(name, values, options, comment, comments) {
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.<number,string>}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.<string,number>}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Enum comment text.
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Value comment texts, if any.
     * @type {Object.<string,string>}
     */
    this.comments = comments || {};

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}

/**
 * Enum descriptor.
 * @interface IEnum
 * @property {Object.<string,number>} values Enum values
 * @property {Object.<string,*>} [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param {string} name Enum name
 * @param {IEnum} json Enum descriptor
 * @returns {Enum} Created enum
 * @throws {TypeError} If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
};

/**
 * Converts this enum to an enum descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IEnum} Enum descriptor
 */
Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"  , this.options,
        "values"   , this.values,
        "reserved" , this.reserved && this.reserved.length ? this.reserved : undefined,
        "comment"  , keepComments ? this.comment : undefined,
        "comments" , keepComments ? this.comments : undefined
    ]);
};

/**
 * Adds a value to this enum.
 * @param {string} name Value name
 * @param {number} id Value id
 * @param {string} [comment] Comment, if any
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a value with this name or id
 */
Enum.prototype.add = function add(name, id, comment) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name '" + name + "' in " + this);

    if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);

    if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);

    if (this.valuesById[id] !== undefined) {
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    this.comments[name] = comment || null;
    return this;
};

/**
 * Removes a value from this enum
 * @param {string} name Value name
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `name` is not a name of this enum
 */
Enum.prototype.remove = function remove(name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];

    return this;
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};


/***/ }),

/***/ 8213:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Field;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(3575);
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = __webpack_require__(7732),
    types = __webpack_require__(6581),
    util  = __webpack_require__(7174);

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function Field(name, id, type, rule, extend, options, comment) {

    if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {boolean|null}
     * @private
     */
    this._packed = null;

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        // defaults to packed=true if not explicity set to false
        if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
        return this._packed;
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    }

    // use explicitly set default value if present
    if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary options
    if (this.options) {
        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
        if (!Object.keys(this.options).length)
            this.options = undefined;
    }

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

    } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    // ensure proper value on prototype
    if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;

    return ReflectionObject.prototype.resolve.call(this);
};

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @typedef FieldDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} fieldName Field name
 * @returns {undefined}
 */

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

// Sets up cyclic dependencies (called in index-light)
Field._configure = function configure(Type_) {
    Type = Type_;
};


/***/ }),

/***/ 6119:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var protobuf = module.exports = __webpack_require__(3242);

protobuf.build = "light";

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @typedef LoadCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Root} [root] Root, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} root Root namespace, defaults to create a new one if omitted.
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 */
function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Promise<Root>} Promise
 * @see {@link Root#load}
 * @variation 3
 */
// function load(filename:string, [root:Root]):Promise<Root>

protobuf.load = load;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}

protobuf.loadSync = loadSync;

// Serialization
protobuf.encoder          = __webpack_require__(3072);
protobuf.decoder          = __webpack_require__(5871);
protobuf.verifier         = __webpack_require__(4334);
protobuf.converter        = __webpack_require__(3617);

// Reflection
protobuf.ReflectionObject = __webpack_require__(3575);
protobuf.Namespace        = __webpack_require__(6189);
protobuf.Root             = __webpack_require__(2614);
protobuf.Enum             = __webpack_require__(7732);
protobuf.Type             = __webpack_require__(8520);
protobuf.Field            = __webpack_require__(8213);
protobuf.OneOf            = __webpack_require__(4408);
protobuf.MapField         = __webpack_require__(7777);
protobuf.Service          = __webpack_require__(6178);
protobuf.Method           = __webpack_require__(7771);

// Runtime
protobuf.Message          = __webpack_require__(8027);
protobuf.wrappers         = __webpack_require__(3216);

// Utility
protobuf.types            = __webpack_require__(6581);
protobuf.util             = __webpack_require__(7174);

// Set up possibly cyclic reflection dependencies
protobuf.ReflectionObject._configure(protobuf.Root);
protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
protobuf.Root._configure(protobuf.Type);
protobuf.Field._configure(protobuf.Type);


/***/ }),

/***/ 3242:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(3098);
protobuf.BufferWriter = __webpack_require__(1863);
protobuf.Reader       = __webpack_require__(1011);
protobuf.BufferReader = __webpack_require__(339);

// Utility
protobuf.util         = __webpack_require__(1241);
protobuf.rpc          = __webpack_require__(6444);
protobuf.roots        = __webpack_require__(73);
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ 5360:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var protobuf = module.exports = __webpack_require__(6119);

protobuf.build = "full";

// Parser
protobuf.tokenize         = __webpack_require__(1157);
protobuf.parse            = __webpack_require__(2137);
protobuf.common           = __webpack_require__(2134);

// Configure parser
protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);


/***/ }),

/***/ 7777:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = MapField;

// extends Field
var Field = __webpack_require__(8213);
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = __webpack_require__(6581),
    util    = __webpack_require__(7174);

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} keyType Key type
 * @param {string} type Value type
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, undefined, undefined, options, comment);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {ReflectionObject|null}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends {IField}
 * @property {string} keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property {string} extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param {string} name Field name
 * @param {IMapField} json Map field descriptor
 * @returns {MapField} Created map field
 * @throws {TypeError} If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
};

/**
 * Converts this map field to a map field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMapField} Map field descriptor
 */
MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
MapField.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
};

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param {number} fieldId Field id
 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
 * @returns {FieldDecorator} Decorator function
 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
};


/***/ }),

/***/ 8027:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Message;

var util = __webpack_require__(1241);

/**
 * Constructs a new message instance.
 * @classdesc Abstract runtime message.
 * @constructor
 * @param {Properties<T>} [properties] Properties to set
 * @template T extends object = object
 */
function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/*eslint-disable valid-jsdoc*/

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<T>} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.create = function create(properties) {
    return this.$type.create(properties);
};

/**
 * Encodes a message of this type.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decode = function decode(reader) {
    return this.$type.decode(reader);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {string|null} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object
 * @returns {T} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
};

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {T} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
};

/**
 * Converts this message to JSON.
 * @returns {Object.<string,*>} JSON object
 */
Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
};

/*eslint-enable valid-jsdoc*/

/***/ }),

/***/ 7771:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Method;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(3575);
((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

var util = __webpack_require__(7174);

/**
 * Constructs a new service method instance.
 * @classdesc Reflected service method.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Method name
 * @param {string|undefined} type Method type, usually `"rpc"`
 * @param {string} requestType Request message type
 * @param {string} responseType Response message type
 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this method
 * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object
 */
function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {Type|null}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {Type|null}
     */
    this.resolvedResponseType = null;

    /**
     * Comment for this method
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Options properly parsed into an object
     */
    this.parsedOptions = parsedOptions;
}

/**
 * Method descriptor.
 * @interface IMethod
 * @property {string} [type="rpc"] Method type
 * @property {string} requestType Request type
 * @property {string} responseType Response type
 * @property {boolean} [requestStream=false] Whether requests are streamed
 * @property {boolean} [responseStream=false] Whether responses are streamed
 * @property {Object.<string,*>} [options] Method options
 * @property {string} comment Method comments
 * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object
 */

/**
 * Constructs a method from a method descriptor.
 * @param {string} name Method name
 * @param {IMethod} json Method descriptor
 * @returns {Method} Created method
 * @throws {TypeError} If arguments are invalid
 */
Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
};

/**
 * Converts this method to a method descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMethod} Method descriptor
 */
Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
        "requestType"    , this.requestType,
        "requestStream"  , this.requestStream,
        "responseType"   , this.responseType,
        "responseStream" , this.responseStream,
        "options"        , this.options,
        "comment"        , keepComments ? this.comment : undefined,
        "parsedOptions"  , this.parsedOptions,
    ]);
};

/**
 * @override
 */
Method.prototype.resolve = function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
};


/***/ }),

/***/ 6189:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Namespace;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(3575);
((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

var Field    = __webpack_require__(8213),
    util     = __webpack_require__(7174);

var Type,    // cyclic
    Service,
    Enum;

/**
 * Constructs a new namespace instance.
 * @name Namespace
 * @classdesc Reflected namespace.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a namespace from JSON.
 * @memberof Namespace
 * @function
 * @param {string} name Namespace name
 * @param {Object.<string,*>} json JSON object
 * @returns {Namespace} Created namespace
 * @throws {TypeError} If arguments are invalid
 */
Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
};

/**
 * Converts an array of reflection objects to JSON.
 * @memberof Namespace
 * @param {ReflectionObject[]} array Object array
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
 */
function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
}

Namespace.arrayToJSON = arrayToJSON;

/**
 * Tests if the specified id is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
                return true;
    return false;
};

/**
 * Tests if the specified name is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name)
                return true;
    return false;
};

/**
 * Not an actual constructor. Use {@link Namespace} instead.
 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports NamespaceBase
 * @extends ReflectionObject
 * @abstract
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 * @see {@link Namespace}
 */
function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.<string,ReflectionObject>|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {ReflectionObject[]|null}
     * @private
     */
    this._nestedArray = null;
}

function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
}

/**
 * Nested objects of this namespace as an array for iteration.
 * @name NamespaceBase#nestedArray
 * @type {ReflectionObject[]}
 * @readonly
 */
Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
});

/**
 * Namespace descriptor.
 * @interface INamespace
 * @property {Object.<string,*>} [options] Namespace options
 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
 */

/**
 * Any extension field descriptor.
 * @typedef AnyExtensionField
 * @type {IExtensionField|IExtensionMapField}
 */

/**
 * Any nested object descriptor.
 * @typedef AnyNestedObject
 * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
 */
// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

/**
 * Converts this namespace to a namespace descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {INamespace} Namespace descriptor
 */
Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
        "options" , this.options,
        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
};

/**
 * Adds nested objects to this namespace from nested object descriptors.
 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
 * @returns {Namespace} `this`
 */
Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
};

/**
 * Gets the nested object of the specified name.
 * @param {string} name Nested object name
 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
 */
Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name]
        || null;
};

/**
 * Gets the values of the nested {@link Enum|enum} of the specified name.
 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
 * @param {string} name Nested enum name
 * @returns {Object.<string,number>} Enum values
 * @throws {Error} If there is no such enum
 */
Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum: " + name);
};

/**
 * Adds a nested object to this namespace.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name
 */
Namespace.prototype.add = function add(object) {

    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i < nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
};

/**
 * Removes a nested object from this namespace.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this namespace
 */
Namespace.prototype.remove = function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
};

/**
 * Defines additial namespaces within this one if not yet existing.
 * @param {string|string[]} path Path to create
 * @param {*} [json] Nested types to create from JSON
 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
 */
Namespace.prototype.define = function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
};

/**
 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
 * @returns {Namespace} `this`
 */
Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
};

/**
 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
 * @param {string|string[]} path Path to look up
 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 */
Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore next */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) && path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);

    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;

    // Otherwise try each nested namespace
    } else
        for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
                return found;

    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
};

/**
 * Looks up the reflection object at the specified path, relative to this namespace.
 * @name NamespaceBase#lookup
 * @function
 * @param {string|string[]} path Path to look up
 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 * @variation 2
 */
// lookup(path: string, [parentAlreadyChecked: boolean])

/**
 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type
 * @throws {Error} If `path` does not point to a type
 */
Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type: " + path);
    return found;
};

/**
 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Enum} Looked up enum
 * @throws {Error} If `path` does not point to an enum
 */
Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type or enum
 * @throws {Error} If `path` does not point to a type or enum
 */
Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Service} Looked up service
 * @throws {Error} If `path` does not point to a service
 */
Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
};

// Sets up cyclic dependencies (called in index-light)
Namespace._configure = function(Type_, Service_, Enum_) {
    Type    = Type_;
    Service = Service_;
    Enum    = Enum_;
};


/***/ }),

/***/ 3575:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = __webpack_require__(7174);

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param {string} name Object name
 * @param {Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Parsed Options.
     * @type {Array.<Object.<string,*>>|undefined}
     */
    this.parsedOptions = null;

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, {

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
        get: function() {
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        }
    },

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
        get: function() {
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
            }
            return path.join(".");
        }
    }
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns {Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param {ReflectionObject} parent Parent added to
 * @returns {undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param {ReflectionObject} parent Parent removed from
 * @returns {undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param {string} name Option name
 * @returns {*} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param {string} name Option name
 * @param {*} value Option value
 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
};

/**
 * Sets a parsed option.
 * @param {string} name parsed Option name
 * @param {*} value Option value
 * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
    if (!this.parsedOptions) {
        this.parsedOptions = [];
    }
    var parsedOptions = this.parsedOptions;
    if (propName) {
        // If setting a sub property of an option then try to merge it
        // with an existing option
        var opt = parsedOptions.find(function (opt) {
            return Object.prototype.hasOwnProperty.call(opt, name);
        });
        if (opt) {
            // If we found an existing option - just merge the property value
            var newValue = opt[name];
            util.setProperty(newValue, propName, value);
        } else {
            // otherwise, create a new option, set it's property and add it to the list
            opt = {};
            opt[name] = util.setProperty({}, propName, value);
            parsedOptions.push(opt);
        }
    } else {
        // Always create a new option when setting the value of the option itself
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
    }
    return this;
};

/**
 * Sets multiple options.
 * @param {Object.<string,*>} options Options to set
 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns {string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

// Sets up cyclic dependencies (called in index-light)
ReflectionObject._configure = function(Root_) {
    Root = Root_;
};


/***/ }),

/***/ 4408:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = OneOf;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(3575);
((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

var Field = __webpack_require__(8213),
    util  = __webpack_require__(7174);

/**
 * Constructs a new oneof instance.
 * @classdesc Reflected oneof.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Oneof name
 * @param {string[]|Object.<string,*>} [fieldNames] Field names
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Oneof descriptor.
 * @interface IOneOf
 * @property {Array.<string>} oneof Oneof field names
 * @property {Object.<string,*>} [options] Oneof options
 */

/**
 * Constructs a oneof from a oneof descriptor.
 * @param {string} name Oneof name
 * @param {IOneOf} json Oneof descriptor
 * @returns {OneOf} Created oneof
 * @throws {TypeError} If arguments are invalid
 */
OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
};

/**
 * Converts this oneof to a oneof descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IOneOf} Oneof descriptor
 */
OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , this.options,
        "oneof"   , this.oneof,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Adds the fields of the specified oneof to the parent if not already done so.
 * @param {OneOf} oneof The oneof
 * @returns {undefined}
 * @inner
 * @ignore
 */
function addFieldsToParent(oneof) {
    if (oneof.parent)
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
                oneof.parent.add(oneof.fieldsArray[i]);
}

/**
 * Adds a field to this oneof and removes it from its current parent, if any.
 * @param {Field} field Field to add
 * @returns {OneOf} `this`
 */
OneOf.prototype.add = function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
};

/**
 * Removes a field from this oneof and puts it back to the oneof's parent.
 * @param {Field} field Field to remove
 * @returns {OneOf} `this`
 */
OneOf.prototype.remove = function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index < 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index > -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
};

/**
 * @override
 */
OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
};

/**
 * @override
 */
OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
};

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @typedef OneOfDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} oneofName OneOf name
 * @returns {undefined}
 */

/**
 * OneOf decorator (TypeScript).
 * @function
 * @param {...string} fieldNames Field names
 * @returns {OneOfDecorator} Decorator function
 * @template T extends string
 */
OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length),
        index = 0;
    while (index < arguments.length)
        fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
        });
    };
};


/***/ }),

/***/ 2137:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = parse;

parse.filename = null;
parse.defaults = { keepCase: false };

var tokenize  = __webpack_require__(1157),
    Root      = __webpack_require__(2614),
    Type      = __webpack_require__(8520),
    Field     = __webpack_require__(8213),
    MapField  = __webpack_require__(7777),
    OneOf     = __webpack_require__(4408),
    Enum      = __webpack_require__(7732),
    Service   = __webpack_require__(6178),
    Method    = __webpack_require__(7771),
    types     = __webpack_require__(6581),
    util      = __webpack_require__(7174);

var base10Re    = /^[1-9][0-9]*$/,
    base10NegRe = /^-?[1-9][0-9]*$/,
    base16Re    = /^0[x][0-9a-fA-F]+$/,
    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
    base8Re     = /^0[0-7]+$/,
    base8NegRe  = /^-?0[0-7]+$/,
    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
    fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

/**
 * Result object returned from {@link parse}.
 * @interface IParserResult
 * @property {string|undefined} package Package name, if declared
 * @property {string[]|undefined} imports Imports, if any
 * @property {string[]|undefined} weakImports Weak imports, if any
 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
 * @property {Root} root Populated root instance
 */

/**
 * Options modifying the behavior of {@link parse}.
 * @interface IParseOptions
 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
 * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
 * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.
 */

/**
 * Options modifying the behavior of JSON serialization.
 * @interface IToJSONOptions
 * @property {boolean} [keepComments=false] Serializes comments.
 */

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param {string} source Source contents
 * @param {Root} root Root to populate
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 */
function parse(source, root, options) {
    /* eslint-disable callback-return */
    if (!(root instanceof Root)) {
        options = root;
        root = new Root();
    }
    if (!options)
        options = parse.defaults;

    var preferTrailingComment = options.preferTrailingComment || false;
    var tn = tokenize(source, options.alternateCommentMode || false),
        next = tn.next,
        push = tn.push,
        peek = tn.peek,
        skip = tn.skip,
        cmnt = tn.cmnt;

    var head = true,
        pkg,
        imports,
        weakImports,
        syntax,
        isProto3 = false;

    var ptr = root;

    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

    /* istanbul ignore next */
    function illegal(token, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
            parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }

    function readString() {
        var values = [],
            token;
        do {
            /* istanbul ignore if */
            if ((token = next()) !== "\"" && token !== "'")
                throw illegal(token);

            values.push(next());
            skip(token);
            token = peek();
        } while (token === "\"" || token === "'");
        return values.join("");
    }

    function readValue(acceptTypeRef) {
        var token = next();
        switch (token) {
            case "'":
            case "\"":
                push(token);
                return readString();
            case "true": case "TRUE":
                return true;
            case "false": case "FALSE":
                return false;
        }
        try {
            return parseNumber(token, /* insideTryCatch */ true);
        } catch (e) {

            /* istanbul ignore else */
            if (acceptTypeRef && typeRefRe.test(token))
                return token;

            /* istanbul ignore next */
            throw illegal(token, "value");
        }
    }

    function readRanges(target, acceptStrings) {
        var token, start;
        do {
            if (acceptStrings && ((token = peek()) === "\"" || token === "'"))
                target.push(readString());
            else
                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
        } while (skip(",", true));
        skip(";");
    }

    function parseNumber(token, insideTryCatch) {
        var sign = 1;
        if (token.charAt(0) === "-") {
            sign = -1;
            token = token.substring(1);
        }
        switch (token) {
            case "inf": case "INF": case "Inf":
                return sign * Infinity;
            case "nan": case "NAN": case "Nan": case "NaN":
                return NaN;
            case "0":
                return 0;
        }
        if (base10Re.test(token))
            return sign * parseInt(token, 10);
        if (base16Re.test(token))
            return sign * parseInt(token, 16);
        if (base8Re.test(token))
            return sign * parseInt(token, 8);

        /* istanbul ignore else */
        if (numberRe.test(token))
            return sign * parseFloat(token);

        /* istanbul ignore next */
        throw illegal(token, "number", insideTryCatch);
    }

    function parseId(token, acceptNegative) {
        switch (token) {
            case "max": case "MAX": case "Max":
                return 536870911;
            case "0":
                return 0;
        }

        /* istanbul ignore if */
        if (!acceptNegative && token.charAt(0) === "-")
            throw illegal(token, "id");

        if (base10NegRe.test(token))
            return parseInt(token, 10);
        if (base16NegRe.test(token))
            return parseInt(token, 16);

        /* istanbul ignore else */
        if (base8NegRe.test(token))
            return parseInt(token, 8);

        /* istanbul ignore next */
        throw illegal(token, "id");
    }

    function parsePackage() {

        /* istanbul ignore if */
        if (pkg !== undefined)
            throw illegal("package");

        pkg = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(pkg))
            throw illegal(pkg, "name");

        ptr = ptr.define(pkg);
        skip(";");
    }

    function parseImport() {
        var token = peek();
        var whichImports;
        switch (token) {
            case "weak":
                whichImports = weakImports || (weakImports = []);
                next();
                break;
            case "public":
                next();
                // eslint-disable-line no-fallthrough
            default:
                whichImports = imports || (imports = []);
                break;
        }
        token = readString();
        skip(";");
        whichImports.push(token);
    }

    function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";

        /* istanbul ignore if */
        if (!isProto3 && syntax !== "proto2")
            throw illegal(syntax, "syntax");

        skip(";");
    }

    function parseCommon(parent, token) {
        switch (token) {

            case "option":
                parseOption(parent, token);
                skip(";");
                return true;

            case "message":
                parseType(parent, token);
                return true;

            case "enum":
                parseEnum(parent, token);
                return true;

            case "service":
                parseService(parent, token);
                return true;

            case "extend":
                parseExtension(parent, token);
                return true;
        }
        return false;
    }

    function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
            if(typeof obj.comment !== "string") {
              obj.comment = cmnt(); // try block-type comment
            }
            obj.filename = parse.filename;
        }
        if (skip("{", true)) {
            var token;
            while ((token = next()) !== "}")
                fnIf(token);
            skip(";", true);
        } else {
            if (fnElse)
                fnElse();
            skip(";");
            if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment
        }
    }

    function parseType(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "type name");

        var type = new Type(token);
        ifBlock(type, function parseType_block(token) {
            if (parseCommon(type, token))
                return;

            switch (token) {

                case "map":
                    parseMapField(type, token);
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                case "oneof":
                    parseOneOf(type, token);
                    break;

                case "extensions":
                    readRanges(type.extensions || (type.extensions = []));
                    break;

                case "reserved":
                    readRanges(type.reserved || (type.reserved = []), true);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);

                    push(token);
                    parseField(type, "optional");
                    break;
            }
        });
        parent.add(type);
    }

    function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
            parseGroup(parent, rule);
            return;
        }

        /* istanbul ignore if */
        if (!typeRefRe.test(type))
            throw illegal(type, "type");

        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        name = applyCase(name);
        skip("=");

        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);

        // JSON defaults to packed=true if not set so we have to set packed=false explicity when
        // parsing proto2 descriptors without the option, where applicable. This must be done for
        // all known packable types and anything that could be an enum (= is not a basic type).
        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))
            field.setOption("packed", false, /* ifNotSet */ true);
    }

    function parseGroup(parent, rule) {
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        var fieldName = util.lcFirst(name);
        if (name === fieldName)
            name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token) {
            switch (token) {

                case "option":
                    parseOption(type, token);
                    skip(";");
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                /* istanbul ignore next */
                default:
                    throw illegal(token); // there are no groups with proto3 semantics
            }
        });
        parent.add(type)
              .add(field);
    }

    function parseMapField(parent) {
        skip("<");
        var keyType = next();

        /* istanbul ignore if */
        if (types.mapKey[keyType] === undefined)
            throw illegal(keyType, "type");

        skip(",");
        var valueType = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(valueType))
            throw illegal(valueType, "type");

        skip(">");
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseMapField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);
    }

    function parseOneOf(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var oneof = new OneOf(applyCase(token));
        ifBlock(oneof, function parseOneOf_block(token) {
            if (token === "option") {
                parseOption(oneof, token);
                skip(";");
            } else {
                push(token);
                parseField(oneof, "optional");
            }
        });
        parent.add(oneof);
    }

    function parseEnum(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var enm = new Enum(token);
        ifBlock(enm, function parseEnum_block(token) {
          switch(token) {
            case "option":
              parseOption(enm, token);
              skip(";");
              break;

            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;

            default:
              parseEnumValue(enm, token);
          }
        });
        parent.add(enm);
    }

    function parseEnumValue(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token))
            throw illegal(token, "name");

        skip("=");
        var value = parseId(next(), true),
            dummy = {};
        ifBlock(dummy, function parseEnumValue_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(dummy, token); // skip
                skip(";");
            } else
                throw illegal(token);

        }, function parseEnumValue_line() {
            parseInlineOptions(dummy); // skip
        });
        parent.add(token, value, dummy.comment);
    }

    function parseOption(parent, token) {
        var isCustom = skip("(", true);

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "name");

        var name = token;
        var option = name;
        var propName;

        if (isCustom) {
            skip(")");
            name = "(" + name + ")";
            option = name;
            token = peek();
            if (fqTypeRefRe.test(token)) {
                propName = token.substr(1); //remove '.' before property name
                name += token;
                next();
            }
        }
        skip("=");
        var optionValue = parseOptionValue(parent, name);
        setParsedOption(parent, option, optionValue, propName);
    }

    function parseOptionValue(parent, name) {
        if (skip("{", true)) { // { a: "foo" b { c: "bar" } }
            var result = {};
            while (!skip("}", true)) {
                /* istanbul ignore if */
                if (!nameRe.test(token = next()))
                    throw illegal(token, "name");

                var value;
                var propName = token;
                if (peek() === "{")
                    value = parseOptionValue(parent, name + "." + token);
                else {
                    skip(":");
                    if (peek() === "{")
                        value = parseOptionValue(parent, name + "." + token);
                    else {
                        value = readValue(true);
                        setOption(parent, name + "." + token, value);
                    }
                }
                var prevValue = result[propName];
                if (prevValue)
                    value = [].concat(prevValue).concat(value);
                result[propName] = value;
                skip(",", true);
            }
            return result;
        }

        var simpleValue = readValue(true);
        setOption(parent, name, simpleValue);
        return simpleValue;
        // Does not enforce a delimiter to be universal
    }

    function setOption(parent, name, value) {
        if (parent.setOption)
            parent.setOption(name, value);
    }

    function setParsedOption(parent, name, value, propName) {
        if (parent.setParsedOption)
            parent.setParsedOption(name, value, propName);
    }

    function parseInlineOptions(parent) {
        if (skip("[", true)) {
            do {
                parseOption(parent, "option");
            } while (skip(",", true));
            skip("]");
        }
        return parent;
    }

    function parseService(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "service name");

        var service = new Service(token);
        ifBlock(service, function parseService_block(token) {
            if (parseCommon(service, token))
                return;

            /* istanbul ignore else */
            if (token === "rpc")
                parseMethod(service, token);
            else
                throw illegal(token);
        });
        parent.add(service);
    }

    function parseMethod(parent, token) {
        // Get the comment of the preceding line now (if one exists) in case the
        // method is defined across multiple lines.
        var commentText = cmnt();

        var type = token;

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var name = token,
            requestType, requestStream,
            responseType, responseStream;

        skip("(");
        if (skip("stream", true))
            requestStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        requestType = token;
        skip(")"); skip("returns"); skip("(");
        if (skip("stream", true))
            responseStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        responseType = token;
        skip(")");

        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(method, token);
                skip(";");
            } else
                throw illegal(token);

        });
        parent.add(method);
    }

    function parseExtension(parent, token) {

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "reference");

        var reference = token;
        ifBlock(null, function parseExtension_block(token) {
            switch (token) {

                case "required":
                case "repeated":
                case "optional":
                    parseField(parent, token, reference);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);
                    push(token);
                    parseField(parent, "optional", reference);
                    break;
            }
        });
    }

    var token;
    while ((token = next()) !== null) {
        switch (token) {

            case "package":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parsePackage();
                break;

            case "import":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseImport();
                break;

            case "syntax":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseSyntax();
                break;

            case "option":

                parseOption(ptr, token);
                skip(";");
                break;

            default:

                /* istanbul ignore else */
                if (parseCommon(ptr, token)) {
                    head = false;
                    continue;
                }

                /* istanbul ignore next */
                throw illegal(token);
        }
    }

    parse.filename = null;
    return {
        "package"     : pkg,
        "imports"     : imports,
         weakImports  : weakImports,
         syntax       : syntax,
         root         : root
    };
}

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @name parse
 * @function
 * @param {string} source Source contents
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 * @variation 2
 */


/***/ }),

/***/ 1011:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(1241);

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ 339:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(1011);
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(1241);

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ 2614:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Root;

// extends Namespace
var Namespace = __webpack_require__(6189);
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = __webpack_require__(8213),
    Enum    = __webpack_require__(7732),
    OneOf   = __webpack_require__(4408),
    util    = __webpack_require__(7174);

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param {Object.<string,*>} [options] Top level options
 */
function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param {INamespace} json Nameespace descriptor
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns {Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param {string} origin The file name of the importing file
 * @param {string} target The file name being imported
 * @returns {string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

/**
 * Fetch content from file path or url
 * This method exists so you can override it with your own logic.
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.fetch = util.fetch;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() {} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} options Parse options
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        var cb = callback;
        callback = null;
        if (sync)
            throw err;
        cb(err, root);
    }

    // Bundled definition existence checking
    function getBundledFileName(filename) {
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common) return altname;
        }
        return null;
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) && source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync && !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            self.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param {Root} root Root instance
 * @param {Field} field Declaring extension field witin the declaring type
 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
    }
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param {ReflectionObject} object Object added
 * @returns {undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param {ReflectionObject} object Object removed
 * @returns {undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
};

// Sets up cyclic dependencies (called in index-light)
Root._configure = function(Type_, parse_, common_) {
    Type   = Type_;
    parse  = parse_;
    common = common_;
};


/***/ }),

/***/ 73:
/***/ ((module) => {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ 6444:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(2439);


/***/ }),

/***/ 2439:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Service;

var util = __webpack_require__(1241);

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ 6178:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Service;

// extends Namespace
var Namespace = __webpack_require__(6189);
((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

var Method = __webpack_require__(7771),
    util   = __webpack_require__(7174),
    rpc    = __webpack_require__(6444);

/**
 * Constructs a new service instance.
 * @classdesc Reflected service.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Service name
 * @param {Object.<string,*>} [options] Service options
 * @throws {TypeError} If arguments are invalid
 */
function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.<string,Method>}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {Method[]|null}
     * @private
     */
    this._methodsArray = null;
}

/**
 * Service descriptor.
 * @interface IService
 * @extends INamespace
 * @property {Object.<string,IMethod>} methods Method descriptors
 */

/**
 * Constructs a service from a service descriptor.
 * @param {string} name Service name
 * @param {IService} json Service descriptor
 * @returns {Service} Created service
 * @throws {TypeError} If arguments are invalid
 */
Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    service.comment = json.comment;
    return service;
};

/**
 * Converts this service to a service descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IService} Service descriptor
 */
Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , inherited && inherited.options || undefined,
        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
        "nested"  , inherited && inherited.nested || undefined,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Methods of this service as an array for iteration.
 * @name Service#methodsArray
 * @type {Method[]}
 * @readonly
 */
Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
});

function clearCache(service) {
    service._methodsArray = null;
    return service;
}

/**
 * @override
 */
Service.prototype.get = function get(name) {
    return this.methods[name]
        || Namespace.prototype.get.call(this, name);
};

/**
 * @override
 */
Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
};

/**
 * @override
 */
Service.prototype.add = function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * @override
 */
Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Creates a runtime service using the specified rpc implementation.
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
 */
Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
        });
    }
    return rpcService;
};


/***/ }),

/***/ 1157:
/***/ ((module) => {

"use strict";

module.exports = tokenize;

var delimRe        = /[\s{}=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

var setCommentRe = /^ *[*/]+ */,
    setCommentAltRe = /^\s*\*?\/*/,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g;

var unescapeMap = {
    "0": "\0",
    "r": "\r",
    "n": "\n",
    "t": "\t"
};

/**
 * Unescapes a string.
 * @param {string} str String to unescape
 * @returns {string} Unescaped string
 * @property {Object.<string,string>} map Special characters map
 * @memberof tokenize
 */
function unescape(str) {
    return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
        }
    });
}

tokenize.unescape = unescape;

/**
 * Gets the next token and advances.
 * @typedef TokenizerHandleNext
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Peeks for the next token.
 * @typedef TokenizerHandlePeek
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Pushes a token back to the stack.
 * @typedef TokenizerHandlePush
 * @type {function}
 * @param {string} token Token
 * @returns {undefined}
 */

/**
 * Skips the next token.
 * @typedef TokenizerHandleSkip
 * @type {function}
 * @param {string} expected Expected token
 * @param {boolean} [optional=false] If optional
 * @returns {boolean} Whether the token matched
 * @throws {Error} If the token didn't match and is not optional
 */

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @typedef TokenizerHandleCmnt
 * @type {function}
 * @param {number} [line] Line number
 * @returns {string|null} Comment text or `null` if none
 */

/**
 * Handle object returned from {@link tokenize}.
 * @interface ITokenizerHandle
 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
 * @property {TokenizerHandlePush} push Pushes a token back to the stack
 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
 * @property {number} line Current line number
 */

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param {string} source Source contents
 * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
 * @returns {ITokenizerHandle} Tokenizer handle
 */
function tokenize(source, alternateCommentMode) {
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        commentType = null,
        commentText = null,
        commentLine = 0,
        commentLineEmpty = false,
        commentIsLeading = false;

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param {string} subject Subject
     * @returns {Error} Error created
     * @inner
     */
    function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
    }

    /**
     * Reads a string till its end.
     * @returns {string} String read
     * @inner
     */
    function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
    }

    /**
     * Gets the character at `pos` within the source.
     * @param {number} pos Position
     * @returns {string} Character
     * @inner
     */
    function charAt(pos) {
        return source.charAt(pos);
    }

    /**
     * Sets the current comment text.
     * @param {number} start Start offset
     * @param {number} end End offset
     * @param {boolean} isLeading set if a leading comment
     * @returns {undefined}
     * @inner
     */
    function setComment(start, end, isLeading) {
        commentType = source.charAt(start++);
        commentLine = line;
        commentLineEmpty = false;
        commentIsLeading = isLeading;
        var lookback;
        if (alternateCommentMode) {
            lookback = 2;  // alternate comment parsing: "//" or "/*"
        } else {
            lookback = 3;  // "///" or "/**"
        }
        var commentOffset = start - lookback,
            c;
        do {
            if (--commentOffset < 0 ||
                    (c = source.charAt(commentOffset)) === "\n") {
                commentLineEmpty = true;
                break;
            }
        } while (c === " " || c === "\t");
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i]
                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
                .trim();
        commentText = lines
            .join("\n")
            .trim();
    }

    function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);

        // see if remaining line matches comment pattern
        var lineText = source.substring(startOffset, endOffset);
        // look for 1 or 2 slashes since startOffset would already point past
        // the first slash that started the comment.
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
    }

    function findEndOfLine(cursor) {
        // find end of cursor's line
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
            endOffset++;
        }
        return endOffset;
    }

    /**
     * Obtains the next token.
     * @returns {string|null} Next token or `null` on eof
     * @inner
     */
    function next() {
        if (stack.length > 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isDoc,
            isLeadingComment = offset === 0;
        do {
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n") {
                    isLeadingComment = true;
                    ++line;
                }
                if (++offset === length)
                    return null;
            }

            if (charAt(offset) === "/") {
                if (++offset === length) {
                    throw illegal("comment");
                }
                if (charAt(offset) === "/") { // Line
                    if (!alternateCommentMode) {
                        // check for triple-slash comment
                        isDoc = charAt(start = offset + 1) === "/";

                        while (charAt(++offset) !== "\n") {
                            if (offset === length) {
                                return null;
                            }
                        }
                        ++offset;
                        if (isDoc) {
                            setComment(start, offset - 1, isLeadingComment);
                        }
                        ++line;
                        repeat = true;
                    } else {
                        // check for double-slash comments, consolidating consecutive lines
                        start = offset;
                        isDoc = false;
                        if (isDoubleSlashCommentLine(offset)) {
                            isDoc = true;
                            do {
                                offset = findEndOfLine(offset);
                                if (offset === length) {
                                    break;
                                }
                                offset++;
                            } while (isDoubleSlashCommentLine(offset));
                        } else {
                            offset = Math.min(length, findEndOfLine(offset) + 1);
                        }
                        if (isDoc) {
                            setComment(start, offset, isLeadingComment);
                        }
                        line++;
                        repeat = true;
                    }
                } else if ((curr = charAt(offset)) === "*") { /* Block */
                    // check for /** (regular comment mode) or /* (alternate comment mode)
                    start = offset + 1;
                    isDoc = alternateCommentMode || charAt(start) === "*";
                    do {
                        if (curr === "\n") {
                            ++line;
                        }
                        if (++offset === length) {
                            throw illegal("comment");
                        }
                        prev = curr;
                        curr = charAt(offset);
                    } while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isDoc) {
                        setComment(start, offset - 2, isLeadingComment);
                    }
                    repeat = true;
                } else {
                    return "/";
                }
            }
        } while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
            while (end < length && !delimRe.test(charAt(end)))
                ++end;
        var token = source.substring(offset, offset = end);
        if (token === "\"" || token === "'")
            stringDelim = token;
        return token;
    }

    /**
     * Pushes a token back to the stack.
     * @param {string} token Token
     * @returns {undefined}
     * @inner
     */
    function push(token) {
        stack.push(token);
    }

    /**
     * Peeks for the next token.
     * @returns {string|null} Token or `null` on eof
     * @inner
     */
    function peek() {
        if (!stack.length) {
            var token = next();
            if (token === null)
                return null;
            push(token);
        }
        return stack[0];
    }

    /**
     * Skips a token.
     * @param {string} expected Expected token
     * @param {boolean} [optional=false] Whether the token is optional
     * @returns {boolean} `true` when skipped, `false` if not
     * @throws {Error} When a required token is not present
     * @inner
     */
    function skip(expected, optional) {
        var actual = peek(),
            equals = actual === expected;
        if (equals) {
            next();
            return true;
        }
        if (!optional)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
    }

    /**
     * Gets a comment.
     * @param {number} [trailingLine] Line number if looking for a trailing comment
     * @returns {string|null} Comment text
     * @inner
     */
    function cmnt(trailingLine) {
        var ret = null;
        if (trailingLine === undefined) {
            if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
                ret = commentIsLeading ? commentText : null;
            }
        } else {
            /* istanbul ignore else */
            if (commentLine < trailingLine) {
                peek();
            }
            if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
                ret = commentIsLeading ? null : commentText;
            }
        }
        return ret;
    }

    return Object.defineProperty({
        next: next,
        peek: peek,
        push: push,
        skip: skip,
        cmnt: cmnt
    }, "line", {
        get: function() { return line; }
    });
    /* eslint-enable callback-return */
}


/***/ }),

/***/ 8520:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Type;

// extends Namespace
var Namespace = __webpack_require__(6189);
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = __webpack_require__(7732),
    OneOf     = __webpack_require__(4408),
    Field     = __webpack_require__(8213),
    MapField  = __webpack_require__(7777),
    Service   = __webpack_require__(6178),
    Message   = __webpack_require__(8027),
    Reader    = __webpack_require__(1011),
    Writer    = __webpack_require__(3098),
    util      = __webpack_require__(7174),
    encoder   = __webpack_require__(3072),
    decoder   = __webpack_require__(5871),
    verifier  = __webpack_require__(4334),
    converter = __webpack_require__(3617),
    wrappers  = __webpack_require__(3216);

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Message name
 * @param {Object.<string,*>} [options] Declared options
 */
function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.<string,Field>}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.<string,OneOf>}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {Object.<number,Field>|null}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {Field[]|null}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {OneOf[]|null}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {Constructor<{}>}
     * @private
     */
    this._ctor = null;
}

Object.defineProperties(Type.prototype, {

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
        get: function() {

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = {};
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            }
            return this._fieldsById;
        }
    },

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
        get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
    },

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
        get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
    },

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
        get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        }
    }
});

/**
 * Generates a constructor function for the specified type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
};

function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
}

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
 * @property {Object.<string,IField>} fields Field descriptors
 * @property {number[][]} [extensions] Extension ranges
 * @property {number[][]} [reserved] Reserved ranges
 * @property {boolean} [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param {string} name Message name
 * @param {IType} json Message type descriptor
 * @returns {Type} Created message type
 */
Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    if (json.comment)
        type.comment = json.comment;
    return type;
};

/**
 * Converts this message type to a message type descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IType} Message type descriptor
 */
Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined,
        "comment"    , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
};

/**
 * @override
 */
Type.prototype.get = function get(name) {
    return this.fields[name]
        || this.oneofs && this.oneofs[name]
        || this.nested && this.nested[name]
        || null;
};

/**
 * Adds a nested object to this type.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * Removes a nested object from this type.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<{}>} Message instance
 */
Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
};

/**
 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
 * @returns {Type} `this`
 */
Type.prototype.setup = function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)({
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this)({
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this)({
        types : types,
        util  : util
    });
    this.fromObject = converter.fromObject(this)({
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this)({
        types : types,
        util  : util
    });

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) {
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) {
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // }
        // if (wrapper.toObject) {
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // }
    }

    return this;
};

/**
 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
};

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
};

/**
 * Decodes a message of this type.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @param {number} [length] Length of the message, if known beforehand
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError<{}>} If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
};

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError} If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
};

/**
 * Verifies that field values are valid and that required fields are present.
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {null|string} `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object to convert
 * @returns {Message<{}>} Message instance
 */
Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
};

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 * @interface IConversionOptions
 * @property {Function} [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
 * @property {Function} [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property {Function} [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property {boolean} [defaults=false] Also sets default values on the resulting object
 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 */
Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
};

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @typedef TypeDecorator
 * @type {function}
 * @param {Constructor<T>} target Target constructor
 * @returns {undefined}
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {TypeDecorator<T>} Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
        util.decorateType(target, typeName);
    };
};


/***/ }),

/***/ 6581:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * Common type constants.
 * @namespace
 */
var types = exports;

var util = __webpack_require__(7174);

var s = [
    "double",   // 0
    "float",    // 1
    "int32",    // 2
    "uint32",   // 3
    "sint32",   // 4
    "fixed32",  // 5
    "sfixed32", // 6
    "int64",    // 7
    "uint64",   // 8
    "sint64",   // 9
    "fixed64",  // 10
    "sfixed64", // 11
    "bool",     // 12
    "string",   // 13
    "bytes"     // 14
];

function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length) o[s[i + offset]] = values[i++];
    return o;
}

/**
 * Basic type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 * @property {number} bytes=2 Ldelim wire type
 */
types.basic = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2,
    /* bytes    */ 2
]);

/**
 * Basic type defaults.
 * @type {Object.<string,*>}
 * @const
 * @property {number} double=0 Double default
 * @property {number} float=0 Float default
 * @property {number} int32=0 Int32 default
 * @property {number} uint32=0 Uint32 default
 * @property {number} sint32=0 Sint32 default
 * @property {number} fixed32=0 Fixed32 default
 * @property {number} sfixed32=0 Sfixed32 default
 * @property {number} int64=0 Int64 default
 * @property {number} uint64=0 Uint64 default
 * @property {number} sint64=0 Sint32 default
 * @property {number} fixed64=0 Fixed64 default
 * @property {number} sfixed64=0 Sfixed64 default
 * @property {boolean} bool=false Bool default
 * @property {string} string="" String default
 * @property {Array.<number>} bytes=Array(0) Bytes default
 * @property {null} message=null Message default
 */
types.defaults = bake([
    /* double   */ 0,
    /* float    */ 0,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 0,
    /* sfixed32 */ 0,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 0,
    /* sfixed64 */ 0,
    /* bool     */ false,
    /* string   */ "",
    /* bytes    */ util.emptyArray,
    /* message  */ null
]);

/**
 * Basic long type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 */
types.long = bake([
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1
], 7);

/**
 * Allowed types for map keys with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 */
types.mapKey = bake([
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2
], 2);

/**
 * Allowed types for packed repeated fields with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 */
types.packed = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0
]);


/***/ }),

/***/ 7174:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = __webpack_require__(1241);

var roots = __webpack_require__(73);

var Type, // cyclic
    Enum;

util.codegen = __webpack_require__(8882);
util.fetch   = __webpack_require__(663);
util.path    = __webpack_require__(4761);

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
    if (object) {
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    }
    return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
    var object = {},
        index  = 0;
    while (index < array.length) {
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    }
    return object;
};

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
};

/**
 * Returns a safe property accessor for the specified property name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
    return "." + prop;
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
};

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {

    /* istanbul ignore if */
    if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
    }

    /* istanbul ignore next */
    if (!Type)
        Type = __webpack_require__(8520);

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
};

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = __webpack_require__(7732);

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
};


/**
 * Sets the value of a property by property path. If a value already exists, it is turned to an array
 * @param {Object.<string,*>} dst Destination object
 * @param {string} path dot '.' delimited path of the property to set
 * @param {Object} value the value to set
 * @returns {Object.<string,*>} Destination object
 */
util.setProperty = function setProperty(dst, path, value) {
    function setProp(dst, path, value) {
        var part = path.shift();
        if (path.length > 0) {
            dst[part] = setProp(dst[part] || {}, path, value);
        } else {
            var prevValue = dst[part];
            if (prevValue)
                value = [].concat(prevValue).concat(value);
            dst[part] = value;
        }
        return dst;
    }

    if (typeof dst !== "object")
        throw TypeError("dst must be an object");
    if (!path)
        throw TypeError("path must be specified");

    path = path.split(".");
    return setProp(dst, path, value);
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
    get: function() {
        return roots["decorated"] || (roots["decorated"] = new (__webpack_require__(2614))());
    }
});


/***/ }),

/***/ 8374:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(1241);

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ 1241:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(252);

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(6718);

// base class of rpc.Service
util.EventEmitter = __webpack_require__(6850);

// float handling accross browsers
util.float = __webpack_require__(1843);

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(94);

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(9049);

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(969);

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(8374);

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};


/***/ }),

/***/ 4334:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = verifier;

var Enum      = __webpack_require__(7732),
    util      = __webpack_require__(7174);

function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
}

/**
 * Generates a partial value verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyValue(gen, field, fieldIndex, ref) {
    /* eslint-disable no-unexpected-multiline */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(%s){", ref)
                ("default:")
                    ("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
                ("case %i:", field.resolvedType.values[keys[j]]);
            gen
                    ("break")
            ("}");
        } else {
            gen
            ("{")
                ("var e=types[%i].verify(%s);", fieldIndex, ref)
                ("if(e)")
                    ("return%j+e", field.name + ".")
            ("}");
        }
    } else {
        switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32": gen
                ("if(!util.isInteger(%s))", ref)
                    ("return%j", invalid(field, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
                    ("return%j", invalid(field, "integer|Long"));
                break;
            case "float":
            case "double": gen
                ("if(typeof %s!==\"number\")", ref)
                    ("return%j", invalid(field, "number"));
                break;
            case "bool": gen
                ("if(typeof %s!==\"boolean\")", ref)
                    ("return%j", invalid(field, "boolean"));
                break;
            case "string": gen
                ("if(!util.isString(%s))", ref)
                    ("return%j", invalid(field, "string"));
                break;
            case "bytes": gen
                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
                    ("return%j", invalid(field, "buffer"));
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a partial key verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyKey(gen, field, ref) {
    /* eslint-disable no-unexpected-multiline */
    switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32": gen
            ("if(!util.key32Re.test(%s))", ref)
                ("return%j", invalid(field, "integer key"));
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64": gen
            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                ("return%j", invalid(field, "integer|Long key"));
            break;
        case "bool": gen
            ("if(!util.key2Re.test(%s))", ref)
                ("return%j", invalid(field, "boolean key"));
            break;
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a verifier specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen(["m"], mtype.name + "$verify")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        if (field.optional) gen
        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

        // map fields
        if (field.map) { gen
            ("if(!util.isObject(%s))", ref)
                ("return%j", invalid(field, "object"))
            ("var k=Object.keys(%s)", ref)
            ("for(var i=0;i<k.length;++i){");
                genVerifyKey(gen, field, "k[i]");
                genVerifyValue(gen, field, i, ref + "[k[i]]")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(!Array.isArray(%s))", ref)
                ("return%j", invalid(field, "array"))
            ("for(var i=0;i<%s.length;++i){", ref);
                genVerifyValue(gen, field, i, ref + "[i]")
            ("}");

        // required or present fields
        } else {
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen
        ("}");
    }
    return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}

/***/ }),

/***/ 3216:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * Wrappers for common types.
 * @type {Object.<string,IWrapper>}
 * @const
 */
var wrappers = exports;

var Message = __webpack_require__(8027);

/**
 * From object converter part of an {@link IWrapper}.
 * @typedef WrapperFromObjectConverter
 * @type {function}
 * @param {Object.<string,*>} object Plain object
 * @returns {Message<{}>} Message instance
 * @this Type
 */

/**
 * To object converter part of an {@link IWrapper}.
 * @typedef WrapperToObjectConverter
 * @type {function}
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @this Type
 */

/**
 * Common type wrapper part of {@link wrappers}.
 * @interface IWrapper
 * @property {WrapperFromObjectConverter} [fromObject] From object converter
 * @property {WrapperToObjectConverter} [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = {

    fromObject: function(object) {

        // unwrap value type if mapped
        if (object && object["@type"]) {
             // Only use fully qualified type name after the last '/'
            var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type) {
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ?
                    object["@type"].substr(1) : object["@type"];
                // type_url prefix is optional, but path seperator is required
                if (type_url.indexOf("/") === -1) {
                    type_url = "/" + type_url;
                }
                return this.create({
                    type_url: type_url,
                    value: type.encode(type.fromObject(object)).finish()
                });
            }
        }

        return this.fromObject(object);
    },

    toObject: function(message, options) {

        // Default prefix
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) {
            // Only use fully qualified type name after the last '/'
            name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
            // Separate the prefix used
            prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        }

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            var messageName = message.$type.fullName[0] === "." ?
                message.$type.fullName.substr(1) : message.$type.fullName;
            // Default to type.googleapis.com prefix if no prefix is used
            if (prefix === "") {
                prefix = googleApi;
            }
            name = prefix + messageName;
            object["@type"] = name;
            return object;
        }

        return this.toObject(message, options);
    }
};


/***/ }),

/***/ 3098:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(1241);

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ 1863:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(3098);
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(1241);

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ 762:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var syntax = __webpack_require__(5701)
var fromMarkdown = __webpack_require__(6628)
var toMarkdown = __webpack_require__(4792)

module.exports = frontmatter

function frontmatter(options) {
  var data = this.data()
  add('micromarkExtensions', syntax(options))
  add('fromMarkdownExtensions', fromMarkdown(options))
  add('toMarkdownExtensions', toMarkdown(options))
  function add(field, value) {
    /* istanbul ignore if - other extensions. */
    if (data[field]) data[field].push(value)
    else data[field] = [value]
  }
}


/***/ }),

/***/ 5772:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var syntax = __webpack_require__(6083)
var fromMarkdown = __webpack_require__(7831)
var toMarkdown = __webpack_require__(9129)

var warningIssued

module.exports = gfm

function gfm(options) {
  var data = this.data()

  /* istanbul ignore next - old remark. */
  if (
    !warningIssued &&
    ((this.Parser &&
      this.Parser.prototype &&
      this.Parser.prototype.blockTokenizers) ||
      (this.Compiler &&
        this.Compiler.prototype &&
        this.Compiler.prototype.visitors))
  ) {
    warningIssued = true
    console.warn(
      '[remark-gfm] Warning: please upgrade to remark 13 to use this plugin'
    )
  }

  add('micromarkExtensions', syntax(options))
  add('fromMarkdownExtensions', fromMarkdown)
  add('toMarkdownExtensions', toMarkdown(options))

  function add(field, value) {
    /* istanbul ignore if - other extensions. */
    if (data[field]) data[field].push(value)
    else data[field] = [value]
  }
}


/***/ }),

/***/ 4859:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = parse

var fromMarkdown = __webpack_require__(3068)

function parse(options) {
  var self = this

  this.Parser = parse

  function parse(doc) {
    return fromMarkdown(
      doc,
      Object.assign({}, self.data('settings'), options, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: self.data('micromarkExtensions') || [],
        mdastExtensions: self.data('fromMarkdownExtensions') || []
      })
    )
  }
}


/***/ }),

/***/ 7114:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = stringify

var toMarkdown = __webpack_require__(219)

function stringify(options) {
  var self = this

  this.Compiler = compile

  function compile(tree) {
    return toMarkdown(
      tree,
      Object.assign({}, self.data('settings'), options, {
        // Note: this option is not in the readme.
        // The goal is for it to be set by plugins on `data` instead of being
        // passed by users.
        extensions: self.data('toMarkdownExtensions') || []
      })
    )
  }
}


/***/ }),

/***/ 6976:
/***/ ((module) => {

"use strict";
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */



/**
 * Results cache
 */

var res = '';
var cache;

/**
 * Expose `repeat`
 */

module.exports = repeat;

/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */

function repeat(str, num) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  // cover common, quick use cases
  if (num === 1) return str;
  if (num === 2) return str + str;

  var max = str.length * num;
  if (cache !== str || typeof cache === 'undefined') {
    cache = str;
    res = '';
  } else if (res.length >= max) {
    return res.substr(0, max);
  }

  while (max > res.length && num > 1) {
    if (num & 1) {
      res += str;
    }

    num >>= 1;
    str += str;
  }

  res += str;
  res = res.substr(0, max);
  return res;
}


/***/ }),

/***/ 3604:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var wrap = __webpack_require__(3458)

module.exports = trough

trough.wrap = wrap

var slice = [].slice

// Create new middleware.
function trough() {
  var fns = []
  var middleware = {}

  middleware.run = run
  middleware.use = use

  return middleware

  // Run `fns`.  Last argument must be a completion handler.
  function run() {
    var index = -1
    var input = slice.call(arguments, 0, -1)
    var done = arguments[arguments.length - 1]

    if (typeof done !== 'function') {
      throw new Error('Expected function as last argument, not ' + done)
    }

    next.apply(null, [null].concat(input))

    // Run the next `fn`, if any.
    function next(err) {
      var fn = fns[++index]
      var params = slice.call(arguments, 0)
      var values = params.slice(1)
      var length = input.length
      var pos = -1

      if (err) {
        done(err)
        return
      }

      // Copy non-nully input into values.
      while (++pos < length) {
        if (values[pos] === null || values[pos] === undefined) {
          values[pos] = input[pos]
        }
      }

      input = values

      // Next or done.
      if (fn) {
        wrap(fn, next).apply(null, input)
      } else {
        done.apply(null, [null].concat(input))
      }
    }
  }

  // Add `fn` to the list.
  function use(fn) {
    if (typeof fn !== 'function') {
      throw new Error('Expected `fn` to be a function, not ' + fn)
    }

    fns.push(fn)

    return middleware
  }
}


/***/ }),

/***/ 3458:
/***/ ((module) => {

"use strict";


var slice = [].slice

module.exports = wrap

// Wrap `fn`.
// Can be sync or async; return a promise, receive a completion handler, return
// new values and errors.
function wrap(fn, callback) {
  var invoked

  return wrapped

  function wrapped() {
    var params = slice.call(arguments, 0)
    var callback = fn.length > params.length
    var result

    if (callback) {
      params.push(done)
    }

    try {
      result = fn.apply(null, params)
    } catch (error) {
      // Well, this is quite the pickle.
      // `fn` received a callback and invoked it (thus continuing the pipeline),
      // but later also threw an error.
      // We’re not about to restart the pipeline again, so the only thing left
      // to do is to throw the thing instead.
      if (callback && invoked) {
        throw error
      }

      return done(error)
    }

    if (!callback) {
      if (result && typeof result.then === 'function') {
        result.then(then, done)
      } else if (result instanceof Error) {
        done(result)
      } else {
        then(result)
      }
    }
  }

  // Invoke `next`, only once.
  function done() {
    if (!invoked) {
      invoked = true

      callback.apply(null, arguments)
    }
  }

  // Invoke `done` with one value.
  // Tracks if an error is passed, too.
  function then(value) {
    done(null, value)
  }
}


/***/ }),

/***/ 4294:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(4219);


/***/ }),

/***/ 4219:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var net = __webpack_require__(1631);
var tls = __webpack_require__(4016);
var http = __webpack_require__(8605);
var https = __webpack_require__(7211);
var events = __webpack_require__(8614);
var assert = __webpack_require__(2357);
var util = __webpack_require__(1669);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 5075:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bail = __webpack_require__(7240)
var buffer = __webpack_require__(8810)
var extend = __webpack_require__(8171)
var plain = __webpack_require__(864)
var trough = __webpack_require__(3604)
var vfile = __webpack_require__(4860)

// Expose a frozen processor.
module.exports = unified().freeze()

var slice = [].slice
var own = {}.hasOwnProperty

// Process pipeline.
var pipeline = trough()
  .use(pipelineParse)
  .use(pipelineRun)
  .use(pipelineStringify)

function pipelineParse(p, ctx) {
  ctx.tree = p.parse(ctx.file)
}

function pipelineRun(p, ctx, next) {
  p.run(ctx.tree, ctx.file, done)

  function done(error, tree, file) {
    if (error) {
      next(error)
    } else {
      ctx.tree = tree
      ctx.file = file
      next()
    }
  }
}

function pipelineStringify(p, ctx) {
  var result = p.stringify(ctx.tree, ctx.file)

  if (result === undefined || result === null) {
    // Empty.
  } else if (typeof result === 'string' || buffer(result)) {
    ctx.file.contents = result
  } else {
    ctx.file.result = result
  }
}

// Function to create the first processor.
function unified() {
  var attachers = []
  var transformers = trough()
  var namespace = {}
  var freezeIndex = -1
  var frozen

  // Data management.
  processor.data = data

  // Lock.
  processor.freeze = freeze

  // Plugins.
  processor.attachers = attachers
  processor.use = use

  // API.
  processor.parse = parse
  processor.stringify = stringify
  processor.run = run
  processor.runSync = runSync
  processor.process = process
  processor.processSync = processSync

  // Expose.
  return processor

  // Create a new processor based on the processor in the current scope.
  function processor() {
    var destination = unified()
    var index = -1

    while (++index < attachers.length) {
      destination.use.apply(null, attachers[index])
    }

    destination.data(extend(true, {}, namespace))

    return destination
  }

  // Freeze: used to signal a processor that has finished configuration.
  //
  // For example, take unified itself: it’s frozen.
  // Plugins should not be added to it.
  // Rather, it should be extended, by invoking it, before modifying it.
  //
  // In essence, always invoke this when exporting a processor.
  function freeze() {
    var values
    var transformer

    if (frozen) {
      return processor
    }

    while (++freezeIndex < attachers.length) {
      values = attachers[freezeIndex]

      if (values[1] === false) {
        continue
      }

      if (values[1] === true) {
        values[1] = undefined
      }

      transformer = values[0].apply(processor, values.slice(1))

      if (typeof transformer === 'function') {
        transformers.use(transformer)
      }
    }

    frozen = true
    freezeIndex = Infinity

    return processor
  }

  // Data management.
  // Getter / setter for processor-specific informtion.
  function data(key, value) {
    if (typeof key === 'string') {
      // Set `key`.
      if (arguments.length === 2) {
        assertUnfrozen('data', frozen)
        namespace[key] = value
        return processor
      }

      // Get `key`.
      return (own.call(namespace, key) && namespace[key]) || null
    }

    // Set space.
    if (key) {
      assertUnfrozen('data', frozen)
      namespace = key
      return processor
    }

    // Get space.
    return namespace
  }

  // Plugin management.
  //
  // Pass it:
  // *   an attacher and options,
  // *   a preset,
  // *   a list of presets, attachers, and arguments (list of attachers and
  //     options).
  function use(value) {
    var settings

    assertUnfrozen('use', frozen)

    if (value === null || value === undefined) {
      // Empty.
    } else if (typeof value === 'function') {
      addPlugin.apply(null, arguments)
    } else if (typeof value === 'object') {
      if ('length' in value) {
        addList(value)
      } else {
        addPreset(value)
      }
    } else {
      throw new Error('Expected usable value, not `' + value + '`')
    }

    if (settings) {
      namespace.settings = extend(namespace.settings || {}, settings)
    }

    return processor

    function addPreset(result) {
      addList(result.plugins)

      if (result.settings) {
        settings = extend(settings || {}, result.settings)
      }
    }

    function add(value) {
      if (typeof value === 'function') {
        addPlugin(value)
      } else if (typeof value === 'object') {
        if ('length' in value) {
          addPlugin.apply(null, value)
        } else {
          addPreset(value)
        }
      } else {
        throw new Error('Expected usable value, not `' + value + '`')
      }
    }

    function addList(plugins) {
      var index = -1

      if (plugins === null || plugins === undefined) {
        // Empty.
      } else if (typeof plugins === 'object' && 'length' in plugins) {
        while (++index < plugins.length) {
          add(plugins[index])
        }
      } else {
        throw new Error('Expected a list of plugins, not `' + plugins + '`')
      }
    }

    function addPlugin(plugin, value) {
      var entry = find(plugin)

      if (entry) {
        if (plain(entry[1]) && plain(value)) {
          value = extend(true, entry[1], value)
        }

        entry[1] = value
      } else {
        attachers.push(slice.call(arguments))
      }
    }
  }

  function find(plugin) {
    var index = -1

    while (++index < attachers.length) {
      if (attachers[index][0] === plugin) {
        return attachers[index]
      }
    }
  }

  // Parse a file (in string or vfile representation) into a unist node using
  // the `Parser` on the processor.
  function parse(doc) {
    var file = vfile(doc)
    var Parser

    freeze()
    Parser = processor.Parser
    assertParser('parse', Parser)

    if (newable(Parser, 'parse')) {
      return new Parser(String(file), file).parse()
    }

    return Parser(String(file), file) // eslint-disable-line new-cap
  }

  // Run transforms on a unist node representation of a file (in string or
  // vfile representation), async.
  function run(node, file, cb) {
    assertNode(node)
    freeze()

    if (!cb && typeof file === 'function') {
      cb = file
      file = null
    }

    if (!cb) {
      return new Promise(executor)
    }

    executor(null, cb)

    function executor(resolve, reject) {
      transformers.run(node, vfile(file), done)

      function done(error, tree, file) {
        tree = tree || node
        if (error) {
          reject(error)
        } else if (resolve) {
          resolve(tree)
        } else {
          cb(null, tree, file)
        }
      }
    }
  }

  // Run transforms on a unist node representation of a file (in string or
  // vfile representation), sync.
  function runSync(node, file) {
    var result
    var complete

    run(node, file, done)

    assertDone('runSync', 'run', complete)

    return result

    function done(error, tree) {
      complete = true
      result = tree
      bail(error)
    }
  }

  // Stringify a unist node representation of a file (in string or vfile
  // representation) into a string using the `Compiler` on the processor.
  function stringify(node, doc) {
    var file = vfile(doc)
    var Compiler

    freeze()
    Compiler = processor.Compiler
    assertCompiler('stringify', Compiler)
    assertNode(node)

    if (newable(Compiler, 'compile')) {
      return new Compiler(node, file).compile()
    }

    return Compiler(node, file) // eslint-disable-line new-cap
  }

  // Parse a file (in string or vfile representation) into a unist node using
  // the `Parser` on the processor, then run transforms on that node, and
  // compile the resulting node using the `Compiler` on the processor, and
  // store that result on the vfile.
  function process(doc, cb) {
    freeze()
    assertParser('process', processor.Parser)
    assertCompiler('process', processor.Compiler)

    if (!cb) {
      return new Promise(executor)
    }

    executor(null, cb)

    function executor(resolve, reject) {
      var file = vfile(doc)

      pipeline.run(processor, {file: file}, done)

      function done(error) {
        if (error) {
          reject(error)
        } else if (resolve) {
          resolve(file)
        } else {
          cb(null, file)
        }
      }
    }
  }

  // Process the given document (in string or vfile representation), sync.
  function processSync(doc) {
    var file
    var complete

    freeze()
    assertParser('processSync', processor.Parser)
    assertCompiler('processSync', processor.Compiler)
    file = vfile(doc)

    process(file, done)

    assertDone('processSync', 'process', complete)

    return file

    function done(error) {
      complete = true
      bail(error)
    }
  }
}

// Check if `value` is a constructor.
function newable(value, name) {
  return (
    typeof value === 'function' &&
    value.prototype &&
    // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    (keys(value.prototype) || name in value.prototype)
  )
}

// Check if `value` is an object with keys.
function keys(value) {
  var key
  for (key in value) {
    return true
  }

  return false
}

// Assert a parser is available.
function assertParser(name, Parser) {
  if (typeof Parser !== 'function') {
    throw new Error('Cannot `' + name + '` without `Parser`')
  }
}

// Assert a compiler is available.
function assertCompiler(name, Compiler) {
  if (typeof Compiler !== 'function') {
    throw new Error('Cannot `' + name + '` without `Compiler`')
  }
}

// Assert the processor is not frozen.
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      'Cannot invoke `' +
        name +
        '` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.'
    )
  }
}

// Assert `node` is a unist node.
function assertNode(node) {
  if (!node || typeof node.type !== 'string') {
    throw new Error('Expected node, got `' + node + '`')
  }
}

// Assert that `complete` is `true`.
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      '`' + name + '` finished async. Use `' + asyncName + '` instead'
    )
  }
}


/***/ }),

/***/ 8810:
/***/ ((module) => {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}


/***/ }),

/***/ 4070:
/***/ ((module) => {

"use strict";


module.exports = convert

function convert(test) {
  if (test == null) {
    return ok
  }

  if (typeof test === 'string') {
    return typeFactory(test)
  }

  if (typeof test === 'object') {
    return 'length' in test ? anyFactory(test) : allFactory(test)
  }

  if (typeof test === 'function') {
    return test
  }

  throw new Error('Expected function, string, or object as test')
}

// Utility assert each property in `test` is represented in `node`, and each
// values are strictly equal.
function allFactory(test) {
  return all

  function all(node) {
    var key

    for (key in test) {
      if (node[key] !== test[key]) return false
    }

    return true
  }
}

function anyFactory(tests) {
  var checks = []
  var index = -1

  while (++index < tests.length) {
    checks[index] = convert(tests[index])
  }

  return any

  function any() {
    var index = -1

    while (++index < checks.length) {
      if (checks[index].apply(this, arguments)) {
        return true
      }
    }

    return false
  }
}

// Utility to convert a string into a function which checks a given node’s type
// for said string.
function typeFactory(test) {
  return type

  function type(node) {
    return Boolean(node && node.type === test)
  }
}

// Utility to return true.
function ok() {
  return true
}


/***/ }),

/***/ 1957:
/***/ ((module) => {

"use strict";


var own = {}.hasOwnProperty

module.exports = stringify

function stringify(value) {
  // Nothing.
  if (!value || typeof value !== 'object') {
    return ''
  }

  // Node.
  if (own.call(value, 'position') || own.call(value, 'type')) {
    return position(value.position)
  }

  // Position.
  if (own.call(value, 'start') || own.call(value, 'end')) {
    return position(value)
  }

  // Point.
  if (own.call(value, 'line') || own.call(value, 'column')) {
    return point(value)
  }

  // ?
  return ''
}

function point(point) {
  if (!point || typeof point !== 'object') {
    point = {}
  }

  return index(point.line) + ':' + index(point.column)
}

function position(pos) {
  if (!pos || typeof pos !== 'object') {
    pos = {}
  }

  return point(pos.start) + '-' + point(pos.end)
}

function index(value) {
  return value && typeof value === 'number' ? value : 1
}


/***/ }),

/***/ 9906:
/***/ ((module) => {

module.exports = color
function color(d) {
  return '\u001B[33m' + d + '\u001B[39m'
}


/***/ }),

/***/ 3246:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = visitParents

var convert = __webpack_require__(4070)
var color = __webpack_require__(9906)

var CONTINUE = true
var SKIP = 'skip'
var EXIT = false

visitParents.CONTINUE = CONTINUE
visitParents.SKIP = SKIP
visitParents.EXIT = EXIT

function visitParents(tree, test, visitor, reverse) {
  var step
  var is

  if (typeof test === 'function' && typeof visitor !== 'function') {
    reverse = visitor
    visitor = test
    test = null
  }

  is = convert(test)
  step = reverse ? -1 : 1

  factory(tree, null, [])()

  function factory(node, index, parents) {
    var value = typeof node === 'object' && node !== null ? node : {}
    var name

    if (typeof value.type === 'string') {
      name =
        typeof value.tagName === 'string'
          ? value.tagName
          : typeof value.name === 'string'
          ? value.name
          : undefined

      visit.displayName =
        'node (' + color(value.type + (name ? '<' + name + '>' : '')) + ')'
    }

    return visit

    function visit() {
      var grandparents = parents.concat(node)
      var result = []
      var subresult
      var offset

      if (!test || is(node, index, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node, parents))

        if (result[0] === EXIT) {
          return result
        }
      }

      if (node.children && result[0] !== SKIP) {
        offset = (reverse ? node.children.length : -1) + step

        while (offset > -1 && offset < node.children.length) {
          subresult = factory(node.children[offset], offset, grandparents)()

          if (subresult[0] === EXIT) {
            return subresult
          }

          offset =
            typeof subresult[1] === 'number' ? subresult[1] : offset + step
        }
      }

      return result
    }
  }
}

function toResult(value) {
  if (value !== null && typeof value === 'object' && 'length' in value) {
    return value
  }

  if (typeof value === 'number') {
    return [CONTINUE, value]
  }

  return [value]
}


/***/ }),

/***/ 199:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = visit

var visitParents = __webpack_require__(3246)

var CONTINUE = visitParents.CONTINUE
var SKIP = visitParents.SKIP
var EXIT = visitParents.EXIT

visit.CONTINUE = CONTINUE
visit.SKIP = SKIP
visit.EXIT = EXIT

function visit(tree, test, visitor, reverse) {
  if (typeof test === 'function' && typeof visitor !== 'function') {
    reverse = visitor
    visitor = test
    test = null
  }

  visitParents(tree, test, overload, reverse)

  function overload(node, parents) {
    var parent = parents[parents.length - 1]
    var index = parent ? parent.children.indexOf(node) : null
    return visitor(node, index, parent)
  }
}


/***/ }),

/***/ 5030:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }

  if (typeof process === "object" && "version" in process) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }

  return "<environment undetectable>";
}

exports.getUserAgent = getUserAgent;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 2707:
/***/ ((module) => {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ 5859:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.

var crypto = __webpack_require__(6417);

module.exports = function nodeRNG() {
  return crypto.randomBytes(16);
};


/***/ }),

/***/ 824:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(5859);
var bytesToUuid = __webpack_require__(2707);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ 4108:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(1957)

module.exports = VMessage

// Inherit from `Error#`.
function VMessagePrototype() {}
VMessagePrototype.prototype = Error.prototype
VMessage.prototype = new VMessagePrototype()

// Message properties.
var proto = VMessage.prototype

proto.file = ''
proto.name = ''
proto.reason = ''
proto.message = ''
proto.stack = ''
proto.fatal = null
proto.column = null
proto.line = null

// Construct a new VMessage.
//
// Note: We cannot invoke `Error` on the created context, as that adds readonly
// `line` and `column` attributes on Safari 9, thus throwing and failing the
// data.
function VMessage(reason, position, origin) {
  var parts
  var range
  var location

  if (typeof position === 'string') {
    origin = position
    position = null
  }

  parts = parseOrigin(origin)
  range = stringify(position) || '1:1'

  location = {
    start: {line: null, column: null},
    end: {line: null, column: null}
  }

  // Node.
  if (position && position.position) {
    position = position.position
  }

  if (position) {
    // Position.
    if (position.start) {
      location = position
      position = position.start
    } else {
      // Point.
      location.start = position
    }
  }

  if (reason.stack) {
    this.stack = reason.stack
    reason = reason.message
  }

  this.message = reason
  this.name = range
  this.reason = reason
  this.line = position ? position.line : null
  this.column = position ? position.column : null
  this.location = location
  this.source = parts[0]
  this.ruleId = parts[1]
}

function parseOrigin(origin) {
  var result = [null, null]
  var index

  if (typeof origin === 'string') {
    index = origin.indexOf(':')

    if (index === -1) {
      result[1] = origin
    } else {
      result[0] = origin.slice(0, index)
      result[1] = origin.slice(index + 1)
    }
  }

  return result
}


/***/ }),

/***/ 4860:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(77)


/***/ }),

/***/ 9523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var p = __webpack_require__(9239)
var proc = __webpack_require__(6070)
var buffer = __webpack_require__(2157)

module.exports = VFile

var own = {}.hasOwnProperty

// Order of setting (least specific to most), we need this because otherwise
// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
// stem can be set.
var order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']

VFile.prototype.toString = toString

// Access full path (`~/index.min.js`).
Object.defineProperty(VFile.prototype, 'path', {get: getPath, set: setPath})

// Access parent path (`~`).
Object.defineProperty(VFile.prototype, 'dirname', {
  get: getDirname,
  set: setDirname
})

// Access basename (`index.min.js`).
Object.defineProperty(VFile.prototype, 'basename', {
  get: getBasename,
  set: setBasename
})

// Access extname (`.js`).
Object.defineProperty(VFile.prototype, 'extname', {
  get: getExtname,
  set: setExtname
})

// Access stem (`index.min`).
Object.defineProperty(VFile.prototype, 'stem', {get: getStem, set: setStem})

// Construct a new file.
function VFile(options) {
  var prop
  var index

  if (!options) {
    options = {}
  } else if (typeof options === 'string' || buffer(options)) {
    options = {contents: options}
  } else if ('message' in options && 'messages' in options) {
    return options
  }

  if (!(this instanceof VFile)) {
    return new VFile(options)
  }

  this.data = {}
  this.messages = []
  this.history = []
  this.cwd = proc.cwd()

  // Set path related properties in the correct order.
  index = -1

  while (++index < order.length) {
    prop = order[index]

    if (own.call(options, prop)) {
      this[prop] = options[prop]
    }
  }

  // Set non-path related properties.
  for (prop in options) {
    if (order.indexOf(prop) < 0) {
      this[prop] = options[prop]
    }
  }
}

function getPath() {
  return this.history[this.history.length - 1]
}

function setPath(path) {
  assertNonEmpty(path, 'path')

  if (this.path !== path) {
    this.history.push(path)
  }
}

function getDirname() {
  return typeof this.path === 'string' ? p.dirname(this.path) : undefined
}

function setDirname(dirname) {
  assertPath(this.path, 'dirname')
  this.path = p.join(dirname || '', this.basename)
}

function getBasename() {
  return typeof this.path === 'string' ? p.basename(this.path) : undefined
}

function setBasename(basename) {
  assertNonEmpty(basename, 'basename')
  assertPart(basename, 'basename')
  this.path = p.join(this.dirname || '', basename)
}

function getExtname() {
  return typeof this.path === 'string' ? p.extname(this.path) : undefined
}

function setExtname(extname) {
  assertPart(extname, 'extname')
  assertPath(this.path, 'extname')

  if (extname) {
    if (extname.charCodeAt(0) !== 46 /* `.` */) {
      throw new Error('`extname` must start with `.`')
    }

    if (extname.indexOf('.', 1) > -1) {
      throw new Error('`extname` cannot contain multiple dots')
    }
  }

  this.path = p.join(this.dirname, this.stem + (extname || ''))
}

function getStem() {
  return typeof this.path === 'string'
    ? p.basename(this.path, this.extname)
    : undefined
}

function setStem(stem) {
  assertNonEmpty(stem, 'stem')
  assertPart(stem, 'stem')
  this.path = p.join(this.dirname || '', stem + (this.extname || ''))
}

// Get the value of the file.
function toString(encoding) {
  return (this.contents || '').toString(encoding)
}

// Assert that `part` is not a path (i.e., does not contain `p.sep`).
function assertPart(part, name) {
  if (part && part.indexOf(p.sep) > -1) {
    throw new Error(
      '`' + name + '` cannot be a path: did not expect `' + p.sep + '`'
    )
  }
}

// Assert that `part` is not empty.
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error('`' + name + '` cannot be empty')
  }
}

// Assert `path` exists.
function assertPath(path, name) {
  if (!path) {
    throw new Error('Setting `' + name + '` requires `path` to be set too')
  }
}


/***/ }),

/***/ 77:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var VMessage = __webpack_require__(4108)
var VFile = __webpack_require__(9523)

module.exports = VFile

VFile.prototype.message = message
VFile.prototype.info = info
VFile.prototype.fail = fail

// Create a message with `reason` at `position`.
// When an error is passed in as `reason`, copies the stack.
function message(reason, position, origin) {
  var message = new VMessage(reason, position, origin)

  if (this.path) {
    message.name = this.path + ':' + message.name
    message.file = this.path
  }

  message.fatal = false

  this.messages.push(message)

  return message
}

// Fail: creates a vmessage, associates it with the file, and throws it.
function fail() {
  var message = this.message.apply(this, arguments)

  message.fatal = true

  throw message
}

// Info: creates a vmessage, associates it with the file, and marks the fatality
// as null.
function info() {
  var message = this.message.apply(this, arguments)

  message.fatal = null

  return message
}


/***/ }),

/***/ 9239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(5622)


/***/ }),

/***/ 6070:
/***/ ((module) => {

"use strict";


module.exports = process


/***/ }),

/***/ 2157:
/***/ ((module) => {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}


/***/ }),

/***/ 2940:
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ 1983:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var PlainValue = __webpack_require__(5215);
var resolveSeq = __webpack_require__(6140);
var Schema = __webpack_require__(3656);

const defaultOptions = {
  anchorPrefix: 'a',
  customTags: null,
  indent: 2,
  indentSeq: true,
  keepCstNodes: false,
  keepNodeTypes: true,
  keepBlobsInJSON: true,
  mapAsMap: false,
  maxAliasCount: 100,
  prettyErrors: false,
  // TODO Set true in v2
  simpleKeys: false,
  version: '1.2'
};
const scalarOptions = {
  get binary() {
    return resolveSeq.binaryOptions;
  },

  set binary(opt) {
    Object.assign(resolveSeq.binaryOptions, opt);
  },

  get bool() {
    return resolveSeq.boolOptions;
  },

  set bool(opt) {
    Object.assign(resolveSeq.boolOptions, opt);
  },

  get int() {
    return resolveSeq.intOptions;
  },

  set int(opt) {
    Object.assign(resolveSeq.intOptions, opt);
  },

  get null() {
    return resolveSeq.nullOptions;
  },

  set null(opt) {
    Object.assign(resolveSeq.nullOptions, opt);
  },

  get str() {
    return resolveSeq.strOptions;
  },

  set str(opt) {
    Object.assign(resolveSeq.strOptions, opt);
  }

};
const documentOptions = {
  '1.0': {
    schema: 'yaml-1.1',
    merge: true,
    tagPrefixes: [{
      handle: '!',
      prefix: PlainValue.defaultTagPrefix
    }, {
      handle: '!!',
      prefix: 'tag:private.yaml.org,2002:'
    }]
  },
  '1.1': {
    schema: 'yaml-1.1',
    merge: true,
    tagPrefixes: [{
      handle: '!',
      prefix: '!'
    }, {
      handle: '!!',
      prefix: PlainValue.defaultTagPrefix
    }]
  },
  '1.2': {
    schema: 'core',
    merge: false,
    tagPrefixes: [{
      handle: '!',
      prefix: '!'
    }, {
      handle: '!!',
      prefix: PlainValue.defaultTagPrefix
    }]
  }
};

function stringifyTag(doc, tag) {
  if ((doc.version || doc.options.version) === '1.0') {
    const priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
    if (priv) return '!' + priv[1];
    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;
  }

  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);

  if (!p) {
    const dtp = doc.getDefaults().tagPrefixes;
    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);
  }

  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;
  const suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, ch => ({
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '{': '%7B',
    '}': '%7D'
  })[ch]);
  return p.handle + suffix;
}

function getTagObject(tags, item) {
  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;

  if (item.tag) {
    const match = tags.filter(t => t.tag === item.tag);
    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];
  }

  let tagObj, obj;

  if (item instanceof resolveSeq.Scalar) {
    obj = item.value; // TODO: deprecate/remove class check

    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);
    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);
  } else {
    obj = item;
    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
  }

  if (!tagObj) {
    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }

  return tagObj;
} // needs to be called before value stringifier to allow for circular anchor refs


function stringifyProps(node, tagObj, {
  anchors,
  doc
}) {
  const props = [];
  const anchor = doc.anchors.getName(node);

  if (anchor) {
    anchors[anchor] = node;
    props.push(`&${anchor}`);
  }

  if (node.tag) {
    props.push(stringifyTag(doc, node.tag));
  } else if (!tagObj.default) {
    props.push(stringifyTag(doc, tagObj.tag));
  }

  return props.join(' ');
}

function stringify(item, ctx, onComment, onChompKeep) {
  const {
    anchors,
    schema
  } = ctx.doc;
  let tagObj;

  if (!(item instanceof resolveSeq.Node)) {
    const createCtx = {
      aliasNodes: [],
      onTagObj: o => tagObj = o,
      prevObjects: new Map()
    };
    item = schema.createNode(item, true, null, createCtx);

    for (const alias of createCtx.aliasNodes) {
      alias.source = alias.source.node;
      let name = anchors.getName(alias.source);

      if (!name) {
        name = anchors.newName();
        anchors.map[name] = alias.source;
      }
    }
  }

  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);
  if (!tagObj) tagObj = getTagObject(schema.tags, item);
  const props = stringifyProps(item, tagObj, ctx);
  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
  if (!props) return str;
  return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\n${ctx.indent}${str}`;
}

class Anchors {
  static validAnchorNode(node) {
    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;
  }

  constructor(prefix) {
    PlainValue._defineProperty(this, "map", {});

    this.prefix = prefix;
  }

  createAlias(node, name) {
    this.setAnchor(node, name);
    return new resolveSeq.Alias(node);
  }

  createMergePair(...sources) {
    const merge = new resolveSeq.Merge();
    merge.value.items = sources.map(s => {
      if (s instanceof resolveSeq.Alias) {
        if (s.source instanceof resolveSeq.YAMLMap) return s;
      } else if (s instanceof resolveSeq.YAMLMap) {
        return this.createAlias(s);
      }

      throw new Error('Merge sources must be Map nodes or their Aliases');
    });
    return merge;
  }

  getName(node) {
    const {
      map
    } = this;
    return Object.keys(map).find(a => map[a] === node);
  }

  getNames() {
    return Object.keys(this.map);
  }

  getNode(name) {
    return this.map[name];
  }

  newName(prefix) {
    if (!prefix) prefix = this.prefix;
    const names = Object.keys(this.map);

    for (let i = 1; true; ++i) {
      const name = `${prefix}${i}`;
      if (!names.includes(name)) return name;
    }
  } // During parsing, map & aliases contain CST nodes


  resolveNodes() {
    const {
      map,
      _cstAliases
    } = this;
    Object.keys(map).forEach(a => {
      map[a] = map[a].resolved;
    });

    _cstAliases.forEach(a => {
      a.source = a.source.resolved;
    });

    delete this._cstAliases;
  }

  setAnchor(node, name) {
    if (node != null && !Anchors.validAnchorNode(node)) {
      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');
    }

    if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
      throw new Error('Anchor names must not contain whitespace or control characters');
    }

    const {
      map
    } = this;
    const prev = node && Object.keys(map).find(a => map[a] === node);

    if (prev) {
      if (!name) {
        return prev;
      } else if (prev !== name) {
        delete map[prev];
        map[name] = node;
      }
    } else {
      if (!name) {
        if (!node) return null;
        name = this.newName();
      }

      map[name] = node;
    }

    return name;
  }

}

const visit = (node, tags) => {
  if (node && typeof node === 'object') {
    const {
      tag
    } = node;

    if (node instanceof resolveSeq.Collection) {
      if (tag) tags[tag] = true;
      node.items.forEach(n => visit(n, tags));
    } else if (node instanceof resolveSeq.Pair) {
      visit(node.key, tags);
      visit(node.value, tags);
    } else if (node instanceof resolveSeq.Scalar) {
      if (tag) tags[tag] = true;
    }
  }

  return tags;
};

const listTagNames = node => Object.keys(visit(node, {}));

function parseContents(doc, contents) {
  const comments = {
    before: [],
    after: []
  };
  let body = undefined;
  let spaceBefore = false;

  for (const node of contents) {
    if (node.valueRange) {
      if (body !== undefined) {
        const msg = 'Document contains trailing content not separated by a ... or --- line';
        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));
        break;
      }

      const res = resolveSeq.resolveNode(doc, node);

      if (spaceBefore) {
        res.spaceBefore = true;
        spaceBefore = false;
      }

      body = res;
    } else if (node.comment !== null) {
      const cc = body === undefined ? comments.before : comments.after;
      cc.push(node.comment);
    } else if (node.type === PlainValue.Type.BLANK_LINE) {
      spaceBefore = true;

      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {
        // space-separated comments at start are parsed as document comments
        doc.commentBefore = comments.before.join('\n');
        comments.before = [];
      }
    }
  }

  doc.contents = body || null;

  if (!body) {
    doc.comment = comments.before.concat(comments.after).join('\n') || null;
  } else {
    const cb = comments.before.join('\n');

    if (cb) {
      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;
      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\n${cbNode.commentBefore}` : cb;
    }

    doc.comment = comments.after.join('\n') || null;
  }
}

function resolveTagDirective({
  tagPrefixes
}, directive) {
  const [handle, prefix] = directive.parameters;

  if (!handle || !prefix) {
    const msg = 'Insufficient parameters given for %TAG directive';
    throw new PlainValue.YAMLSemanticError(directive, msg);
  }

  if (tagPrefixes.some(p => p.handle === handle)) {
    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';
    throw new PlainValue.YAMLSemanticError(directive, msg);
  }

  return {
    handle,
    prefix
  };
}

function resolveYamlDirective(doc, directive) {
  let [version] = directive.parameters;
  if (directive.name === 'YAML:1.0') version = '1.0';

  if (!version) {
    const msg = 'Insufficient parameters given for %YAML directive';
    throw new PlainValue.YAMLSemanticError(directive, msg);
  }

  if (!documentOptions[version]) {
    const v0 = doc.version || doc.options.version;
    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;
    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
  }

  return version;
}

function parseDirectives(doc, directives, prevDoc) {
  const directiveComments = [];
  let hasDirectives = false;

  for (const directive of directives) {
    const {
      comment,
      name
    } = directive;

    switch (name) {
      case 'TAG':
        try {
          doc.tagPrefixes.push(resolveTagDirective(doc, directive));
        } catch (error) {
          doc.errors.push(error);
        }

        hasDirectives = true;
        break;

      case 'YAML':
      case 'YAML:1.0':
        if (doc.version) {
          const msg = 'The %YAML directive must only be given at most once per document.';
          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));
        }

        try {
          doc.version = resolveYamlDirective(doc, directive);
        } catch (error) {
          doc.errors.push(error);
        }

        hasDirectives = true;
        break;

      default:
        if (name) {
          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;
          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
        }

    }

    if (comment) directiveComments.push(comment);
  }

  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {
    const copyTagPrefix = ({
      handle,
      prefix
    }) => ({
      handle,
      prefix
    });

    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
    doc.version = prevDoc.version;
  }

  doc.commentBefore = directiveComments.join('\n') || null;
}

function assertCollection(contents) {
  if (contents instanceof resolveSeq.Collection) return true;
  throw new Error('Expected a YAML collection as document contents');
}

class Document {
  constructor(options) {
    this.anchors = new Anchors(options.anchorPrefix);
    this.commentBefore = null;
    this.comment = null;
    this.contents = null;
    this.directivesEndMarker = null;
    this.errors = [];
    this.options = options;
    this.schema = null;
    this.tagPrefixes = [];
    this.version = null;
    this.warnings = [];
  }

  add(value) {
    assertCollection(this.contents);
    return this.contents.add(value);
  }

  addIn(path, value) {
    assertCollection(this.contents);
    this.contents.addIn(path, value);
  }

  delete(key) {
    assertCollection(this.contents);
    return this.contents.delete(key);
  }

  deleteIn(path) {
    if (resolveSeq.isEmptyPath(path)) {
      if (this.contents == null) return false;
      this.contents = null;
      return true;
    }

    assertCollection(this.contents);
    return this.contents.deleteIn(path);
  }

  getDefaults() {
    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};
  }

  get(key, keepScalar) {
    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;
  }

  getIn(path, keepScalar) {
    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;
    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;
  }

  has(key) {
    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;
  }

  hasIn(path) {
    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;
    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;
  }

  set(key, value) {
    assertCollection(this.contents);
    this.contents.set(key, value);
  }

  setIn(path, value) {
    if (resolveSeq.isEmptyPath(path)) this.contents = value;else {
      assertCollection(this.contents);
      this.contents.setIn(path, value);
    }
  }

  setSchema(id, customTags) {
    if (!id && !customTags && this.schema) return;
    if (typeof id === 'number') id = id.toFixed(1);

    if (id === '1.0' || id === '1.1' || id === '1.2') {
      if (this.version) this.version = id;else this.options.version = id;
      delete this.options.schema;
    } else if (id && typeof id === 'string') {
      this.options.schema = id;
    }

    if (Array.isArray(customTags)) this.options.customTags = customTags;
    const opt = Object.assign({}, this.getDefaults(), this.options);
    this.schema = new Schema.Schema(opt);
  }

  parse(node, prevDoc) {
    if (this.options.keepCstNodes) this.cstNode = node;
    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';
    const {
      directives = [],
      contents = [],
      directivesEndMarker,
      error,
      valueRange
    } = node;

    if (error) {
      if (!error.source) error.source = this;
      this.errors.push(error);
    }

    parseDirectives(this, directives, prevDoc);
    if (directivesEndMarker) this.directivesEndMarker = true;
    this.range = valueRange ? [valueRange.start, valueRange.end] : null;
    this.setSchema();
    this.anchors._cstAliases = [];
    parseContents(this, contents);
    this.anchors.resolveNodes();

    if (this.options.prettyErrors) {
      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();

      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();
    }

    return this;
  }

  listNonDefaultTags() {
    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);
  }

  setTagPrefix(handle, prefix) {
    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');

    if (prefix) {
      const prev = this.tagPrefixes.find(p => p.handle === handle);
      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({
        handle,
        prefix
      });
    } else {
      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);
    }
  }

  toJSON(arg, onAnchor) {
    const {
      keepBlobsInJSON,
      mapAsMap,
      maxAliasCount
    } = this.options;
    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));
    const ctx = {
      doc: this,
      indentStep: '  ',
      keep,
      mapAsMap: keep && !!mapAsMap,
      maxAliasCount,
      stringify // Requiring directly in Pair would create circular dependencies

    };
    const anchorNames = Object.keys(this.anchors.map);
    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {
      alias: [],
      aliasCount: 0,
      count: 1
    }]));
    const res = resolveSeq.toJSON(this.contents, arg, ctx);
    if (typeof onAnchor === 'function' && ctx.anchors) for (const {
      count,
      res
    } of ctx.anchors.values()) onAnchor(res, count);
    return res;
  }

  toString() {
    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');
    const indentSize = this.options.indent;

    if (!Number.isInteger(indentSize) || indentSize <= 0) {
      const s = JSON.stringify(indentSize);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }

    this.setSchema();
    const lines = [];
    let hasDirectives = false;

    if (this.version) {
      let vd = '%YAML 1.2';

      if (this.schema.name === 'yaml-1.1') {
        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';
      }

      lines.push(vd);
      hasDirectives = true;
    }

    const tagNames = this.listNonDefaultTags();
    this.tagPrefixes.forEach(({
      handle,
      prefix
    }) => {
      if (tagNames.some(t => t.indexOf(prefix) === 0)) {
        lines.push(`%TAG ${handle} ${prefix}`);
        hasDirectives = true;
      }
    });
    if (hasDirectives || this.directivesEndMarker) lines.push('---');

    if (this.commentBefore) {
      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');
      lines.unshift(this.commentBefore.replace(/^/gm, '#'));
    }

    const ctx = {
      anchors: {},
      doc: this,
      indent: '',
      indentStep: ' '.repeat(indentSize),
      stringify // Requiring directly in nodes would create circular dependencies

    };
    let chompKeep = false;
    let contentComment = null;

    if (this.contents) {
      if (this.contents instanceof resolveSeq.Node) {
        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');
        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment

        ctx.forceBlockIndent = !!this.comment;
        contentComment = this.contents.comment;
      }

      const onChompKeep = contentComment ? null : () => chompKeep = true;
      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);
      lines.push(resolveSeq.addComment(body, '', contentComment));
    } else if (this.contents !== undefined) {
      lines.push(stringify(this.contents, ctx));
    }

    if (this.comment) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');
      lines.push(this.comment.replace(/^/gm, '#'));
    }

    return lines.join('\n') + '\n';
  }

}

PlainValue._defineProperty(Document, "defaults", documentOptions);

exports.Document = Document;
exports.defaultOptions = defaultOptions;
exports.scalarOptions = scalarOptions;


/***/ }),

/***/ 5215:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const Char = {
  ANCHOR: '&',
  COMMENT: '#',
  TAG: '!',
  DIRECTIVES_END: '-',
  DOCUMENT_END: '.'
};
const Type = {
  ALIAS: 'ALIAS',
  BLANK_LINE: 'BLANK_LINE',
  BLOCK_FOLDED: 'BLOCK_FOLDED',
  BLOCK_LITERAL: 'BLOCK_LITERAL',
  COMMENT: 'COMMENT',
  DIRECTIVE: 'DIRECTIVE',
  DOCUMENT: 'DOCUMENT',
  FLOW_MAP: 'FLOW_MAP',
  FLOW_SEQ: 'FLOW_SEQ',
  MAP: 'MAP',
  MAP_KEY: 'MAP_KEY',
  MAP_VALUE: 'MAP_VALUE',
  PLAIN: 'PLAIN',
  QUOTE_DOUBLE: 'QUOTE_DOUBLE',
  QUOTE_SINGLE: 'QUOTE_SINGLE',
  SEQ: 'SEQ',
  SEQ_ITEM: 'SEQ_ITEM'
};
const defaultTagPrefix = 'tag:yaml.org,2002:';
const defaultTags = {
  MAP: 'tag:yaml.org,2002:map',
  SEQ: 'tag:yaml.org,2002:seq',
  STR: 'tag:yaml.org,2002:str'
};

function findLineStarts(src) {
  const ls = [0];
  let offset = src.indexOf('\n');

  while (offset !== -1) {
    offset += 1;
    ls.push(offset);
    offset = src.indexOf('\n', offset);
  }

  return ls;
}

function getSrcInfo(cst) {
  let lineStarts, src;

  if (typeof cst === 'string') {
    lineStarts = findLineStarts(cst);
    src = cst;
  } else {
    if (Array.isArray(cst)) cst = cst[0];

    if (cst && cst.context) {
      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);
      lineStarts = cst.lineStarts;
      src = cst.context.src;
    }
  }

  return {
    lineStarts,
    src
  };
}
/**
 * @typedef {Object} LinePos - One-indexed position in the source
 * @property {number} line
 * @property {number} col
 */

/**
 * Determine the line/col position matching a character offset.
 *
 * Accepts a source string or a CST document as the second parameter. With
 * the latter, starting indices for lines are cached in the document as
 * `lineStarts: number[]`.
 *
 * Returns a one-indexed `{ line, col }` location if found, or
 * `undefined` otherwise.
 *
 * @param {number} offset
 * @param {string|Document|Document[]} cst
 * @returns {?LinePos}
 */


function getLinePos(offset, cst) {
  if (typeof offset !== 'number' || offset < 0) return null;
  const {
    lineStarts,
    src
  } = getSrcInfo(cst);
  if (!lineStarts || !src || offset > src.length) return null;

  for (let i = 0; i < lineStarts.length; ++i) {
    const start = lineStarts[i];

    if (offset < start) {
      return {
        line: i,
        col: offset - lineStarts[i - 1] + 1
      };
    }

    if (offset === start) return {
      line: i + 1,
      col: 1
    };
  }

  const line = lineStarts.length;
  return {
    line,
    col: offset - lineStarts[line - 1] + 1
  };
}
/**
 * Get a specified line from the source.
 *
 * Accepts a source string or a CST document as the second parameter. With
 * the latter, starting indices for lines are cached in the document as
 * `lineStarts: number[]`.
 *
 * Returns the line as a string if found, or `null` otherwise.
 *
 * @param {number} line One-indexed line number
 * @param {string|Document|Document[]} cst
 * @returns {?string}
 */

function getLine(line, cst) {
  const {
    lineStarts,
    src
  } = getSrcInfo(cst);
  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;
  const start = lineStarts[line - 1];
  let end = lineStarts[line]; // undefined for last line; that's ok for slice()

  while (end && end > start && src[end - 1] === '\n') --end;

  return src.slice(start, end);
}
/**
 * Pretty-print the starting line from the source indicated by the range `pos`
 *
 * Trims output to `maxWidth` chars while keeping the starting column visible,
 * using `…` at either end to indicate dropped characters.
 *
 * Returns a two-line string (or `null`) with `\n` as separator; the second line
 * will hold appropriately indented `^` marks indicating the column range.
 *
 * @param {Object} pos
 * @param {LinePos} pos.start
 * @param {LinePos} [pos.end]
 * @param {string|Document|Document[]*} cst
 * @param {number} [maxWidth=80]
 * @returns {?string}
 */

function getPrettyContext({
  start,
  end
}, cst, maxWidth = 80) {
  let src = getLine(start.line, cst);
  if (!src) return null;
  let {
    col
  } = start;

  if (src.length > maxWidth) {
    if (col <= maxWidth - 10) {
      src = src.substr(0, maxWidth - 1) + '…';
    } else {
      const halfWidth = Math.round(maxWidth / 2);
      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';
      col -= src.length - maxWidth;
      src = '…' + src.substr(1 - maxWidth);
    }
  }

  let errLen = 1;
  let errEnd = '';

  if (end) {
    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
      errLen = end.col - start.col;
    } else {
      errLen = Math.min(src.length + 1, maxWidth) - col;
      errEnd = '…';
    }
  }

  const offset = col > 1 ? ' '.repeat(col - 1) : '';
  const err = '^'.repeat(errLen);
  return `${src}\n${offset}${err}${errEnd}`;
}

class Range {
  static copy(orig) {
    return new Range(orig.start, orig.end);
  }

  constructor(start, end) {
    this.start = start;
    this.end = end || start;
  }

  isEmpty() {
    return typeof this.start !== 'number' || !this.end || this.end <= this.start;
  }
  /**
   * Set `origStart` and `origEnd` to point to the original source range for
   * this node, which may differ due to dropped CR characters.
   *
   * @param {number[]} cr - Positions of dropped CR characters
   * @param {number} offset - Starting index of `cr` from the last call
   * @returns {number} - The next offset, matching the one found for `origStart`
   */


  setOrigRange(cr, offset) {
    const {
      start,
      end
    } = this;

    if (cr.length === 0 || end <= cr[0]) {
      this.origStart = start;
      this.origEnd = end;
      return offset;
    }

    let i = offset;

    while (i < cr.length) {
      if (cr[i] > start) break;else ++i;
    }

    this.origStart = start + i;
    const nextOffset = i;

    while (i < cr.length) {
      // if end was at \n, it should now be at \r
      if (cr[i] >= end) break;else ++i;
    }

    this.origEnd = end + i;
    return nextOffset;
  }

}

/** Root class of all nodes */

class Node {
  static addStringTerminator(src, offset, str) {
    if (str[str.length - 1] === '\n') return str;
    const next = Node.endOfWhiteSpace(src, offset);
    return next >= src.length || src[next] === '\n' ? str + '\n' : str;
  } // ^(---|...)


  static atDocumentBoundary(src, offset, sep) {
    const ch0 = src[offset];
    if (!ch0) return true;
    const prev = src[offset - 1];
    if (prev && prev !== '\n') return false;

    if (sep) {
      if (ch0 !== sep) return false;
    } else {
      if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;
    }

    const ch1 = src[offset + 1];
    const ch2 = src[offset + 2];
    if (ch1 !== ch0 || ch2 !== ch0) return false;
    const ch3 = src[offset + 3];
    return !ch3 || ch3 === '\n' || ch3 === '\t' || ch3 === ' ';
  }

  static endOfIdentifier(src, offset) {
    let ch = src[offset];
    const isVerbatim = ch === '<';
    const notOk = isVerbatim ? ['\n', '\t', ' ', '>'] : ['\n', '\t', ' ', '[', ']', '{', '}', ','];

    while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];

    if (isVerbatim && ch === '>') offset += 1;
    return offset;
  }

  static endOfIndent(src, offset) {
    let ch = src[offset];

    while (ch === ' ') ch = src[offset += 1];

    return offset;
  }

  static endOfLine(src, offset) {
    let ch = src[offset];

    while (ch && ch !== '\n') ch = src[offset += 1];

    return offset;
  }

  static endOfWhiteSpace(src, offset) {
    let ch = src[offset];

    while (ch === '\t' || ch === ' ') ch = src[offset += 1];

    return offset;
  }

  static startOfLine(src, offset) {
    let ch = src[offset - 1];
    if (ch === '\n') return offset;

    while (ch && ch !== '\n') ch = src[offset -= 1];

    return offset + 1;
  }
  /**
   * End of indentation, or null if the line's indent level is not more
   * than `indent`
   *
   * @param {string} src
   * @param {number} indent
   * @param {number} lineStart
   * @returns {?number}
   */


  static endOfBlockIndent(src, indent, lineStart) {
    const inEnd = Node.endOfIndent(src, lineStart);

    if (inEnd > lineStart + indent) {
      return inEnd;
    } else {
      const wsEnd = Node.endOfWhiteSpace(src, inEnd);
      const ch = src[wsEnd];
      if (!ch || ch === '\n') return wsEnd;
    }

    return null;
  }

  static atBlank(src, offset, endAsBlank) {
    const ch = src[offset];
    return ch === '\n' || ch === '\t' || ch === ' ' || endAsBlank && !ch;
  }

  static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
    if (!ch || indentDiff < 0) return false;
    if (indentDiff > 0) return true;
    return indicatorAsIndent && ch === '-';
  } // should be at line or string end, or at next non-whitespace char


  static normalizeOffset(src, offset) {
    const ch = src[offset];
    return !ch ? offset : ch !== '\n' && src[offset - 1] === '\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);
  } // fold single newline into space, multiple newlines to N - 1 newlines
  // presumes src[offset] === '\n'


  static foldNewline(src, offset, indent) {
    let inCount = 0;
    let error = false;
    let fold = '';
    let ch = src[offset + 1];

    while (ch === ' ' || ch === '\t' || ch === '\n') {
      switch (ch) {
        case '\n':
          inCount = 0;
          offset += 1;
          fold += '\n';
          break;

        case '\t':
          if (inCount <= indent) error = true;
          offset = Node.endOfWhiteSpace(src, offset + 2) - 1;
          break;

        case ' ':
          inCount += 1;
          offset += 1;
          break;
      }

      ch = src[offset + 1];
    }

    if (!fold) fold = ' ';
    if (ch && inCount <= indent) error = true;
    return {
      fold,
      offset,
      error
    };
  }

  constructor(type, props, context) {
    Object.defineProperty(this, 'context', {
      value: context || null,
      writable: true
    });
    this.error = null;
    this.range = null;
    this.valueRange = null;
    this.props = props || [];
    this.type = type;
    this.value = null;
  }

  getPropValue(idx, key, skipKey) {
    if (!this.context) return null;
    const {
      src
    } = this.context;
    const prop = this.props[idx];
    return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
  }

  get anchor() {
    for (let i = 0; i < this.props.length; ++i) {
      const anchor = this.getPropValue(i, Char.ANCHOR, true);
      if (anchor != null) return anchor;
    }

    return null;
  }

  get comment() {
    const comments = [];

    for (let i = 0; i < this.props.length; ++i) {
      const comment = this.getPropValue(i, Char.COMMENT, true);
      if (comment != null) comments.push(comment);
    }

    return comments.length > 0 ? comments.join('\n') : null;
  }

  commentHasRequiredWhitespace(start) {
    const {
      src
    } = this.context;
    if (this.header && start === this.header.end) return false;
    if (!this.valueRange) return false;
    const {
      end
    } = this.valueRange;
    return start !== end || Node.atBlank(src, end - 1);
  }

  get hasComment() {
    if (this.context) {
      const {
        src
      } = this.context;

      for (let i = 0; i < this.props.length; ++i) {
        if (src[this.props[i].start] === Char.COMMENT) return true;
      }
    }

    return false;
  }

  get hasProps() {
    if (this.context) {
      const {
        src
      } = this.context;

      for (let i = 0; i < this.props.length; ++i) {
        if (src[this.props[i].start] !== Char.COMMENT) return true;
      }
    }

    return false;
  }

  get includesTrailingLines() {
    return false;
  }

  get jsonLike() {
    const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
    return jsonLikeTypes.indexOf(this.type) !== -1;
  }

  get rangeAsLinePos() {
    if (!this.range || !this.context) return undefined;
    const start = getLinePos(this.range.start, this.context.root);
    if (!start) return undefined;
    const end = getLinePos(this.range.end, this.context.root);
    return {
      start,
      end
    };
  }

  get rawValue() {
    if (!this.valueRange || !this.context) return null;
    const {
      start,
      end
    } = this.valueRange;
    return this.context.src.slice(start, end);
  }

  get tag() {
    for (let i = 0; i < this.props.length; ++i) {
      const tag = this.getPropValue(i, Char.TAG, false);

      if (tag != null) {
        if (tag[1] === '<') {
          return {
            verbatim: tag.slice(2, -1)
          };
        } else {
          // eslint-disable-next-line no-unused-vars
          const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
          return {
            handle,
            suffix
          };
        }
      }
    }

    return null;
  }

  get valueRangeContainsNewline() {
    if (!this.valueRange || !this.context) return false;
    const {
      start,
      end
    } = this.valueRange;
    const {
      src
    } = this.context;

    for (let i = start; i < end; ++i) {
      if (src[i] === '\n') return true;
    }

    return false;
  }

  parseComment(start) {
    const {
      src
    } = this.context;

    if (src[start] === Char.COMMENT) {
      const end = Node.endOfLine(src, start + 1);
      const commentRange = new Range(start, end);
      this.props.push(commentRange);
      return end;
    }

    return start;
  }
  /**
   * Populates the `origStart` and `origEnd` values of all ranges for this
   * node. Extended by child classes to handle descendant nodes.
   *
   * @param {number[]} cr - Positions of dropped CR characters
   * @param {number} offset - Starting index of `cr` from the last call
   * @returns {number} - The next offset, matching the one found for `origStart`
   */


  setOrigRanges(cr, offset) {
    if (this.range) offset = this.range.setOrigRange(cr, offset);
    if (this.valueRange) this.valueRange.setOrigRange(cr, offset);
    this.props.forEach(prop => prop.setOrigRange(cr, offset));
    return offset;
  }

  toString() {
    const {
      context: {
        src
      },
      range,
      value
    } = this;
    if (value != null) return value;
    const str = src.slice(range.start, range.end);
    return Node.addStringTerminator(src, range.end, str);
  }

}

class YAMLError extends Error {
  constructor(name, source, message) {
    if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);
    super();
    this.name = name;
    this.message = message;
    this.source = source;
  }

  makePretty() {
    if (!this.source) return;
    this.nodeType = this.source.type;
    const cst = this.source.context && this.source.context.root;

    if (typeof this.offset === 'number') {
      this.range = new Range(this.offset, this.offset + 1);
      const start = cst && getLinePos(this.offset, cst);

      if (start) {
        const end = {
          line: start.line,
          col: start.col + 1
        };
        this.linePos = {
          start,
          end
        };
      }

      delete this.offset;
    } else {
      this.range = this.source.range;
      this.linePos = this.source.rangeAsLinePos;
    }

    if (this.linePos) {
      const {
        line,
        col
      } = this.linePos.start;
      this.message += ` at line ${line}, column ${col}`;
      const ctx = cst && getPrettyContext(this.linePos, cst);
      if (ctx) this.message += `:\n\n${ctx}\n`;
    }

    delete this.source;
  }

}
class YAMLReferenceError extends YAMLError {
  constructor(source, message) {
    super('YAMLReferenceError', source, message);
  }

}
class YAMLSemanticError extends YAMLError {
  constructor(source, message) {
    super('YAMLSemanticError', source, message);
  }

}
class YAMLSyntaxError extends YAMLError {
  constructor(source, message) {
    super('YAMLSyntaxError', source, message);
  }

}
class YAMLWarning extends YAMLError {
  constructor(source, message) {
    super('YAMLWarning', source, message);
  }

}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class PlainValue extends Node {
  static endOfLine(src, start, inFlow) {
    let ch = src[start];
    let offset = start;

    while (ch && ch !== '\n') {
      if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;
      const next = src[offset + 1];
      if (ch === ':' && (!next || next === '\n' || next === '\t' || next === ' ' || inFlow && next === ',')) break;
      if ((ch === ' ' || ch === '\t') && next === '#') break;
      offset += 1;
      ch = next;
    }

    return offset;
  }

  get strValue() {
    if (!this.valueRange || !this.context) return null;
    let {
      start,
      end
    } = this.valueRange;
    const {
      src
    } = this.context;
    let ch = src[end - 1];

    while (start < end && (ch === '\n' || ch === '\t' || ch === ' ')) ch = src[--end - 1];

    let str = '';

    for (let i = start; i < end; ++i) {
      const ch = src[i];

      if (ch === '\n') {
        const {
          fold,
          offset
        } = Node.foldNewline(src, i, -1);
        str += fold;
        i = offset;
      } else if (ch === ' ' || ch === '\t') {
        // trim trailing whitespace
        const wsStart = i;
        let next = src[i + 1];

        while (i < end && (next === ' ' || next === '\t')) {
          i += 1;
          next = src[i + 1];
        }

        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
      } else {
        str += ch;
      }
    }

    const ch0 = src[start];

    switch (ch0) {
      case '\t':
        {
          const msg = 'Plain value cannot start with a tab character';
          const errors = [new YAMLSemanticError(this, msg)];
          return {
            errors,
            str
          };
        }

      case '@':
      case '`':
        {
          const msg = `Plain value cannot start with reserved character ${ch0}`;
          const errors = [new YAMLSemanticError(this, msg)];
          return {
            errors,
            str
          };
        }

      default:
        return str;
    }
  }

  parseBlockValue(start) {
    const {
      indent,
      inFlow,
      src
    } = this.context;
    let offset = start;
    let valueEnd = start;

    for (let ch = src[offset]; ch === '\n'; ch = src[offset]) {
      if (Node.atDocumentBoundary(src, offset + 1)) break;
      const end = Node.endOfBlockIndent(src, indent, offset + 1);
      if (end === null || src[end] === '#') break;

      if (src[end] === '\n') {
        offset = end;
      } else {
        valueEnd = PlainValue.endOfLine(src, end, inFlow);
        offset = valueEnd;
      }
    }

    if (this.valueRange.isEmpty()) this.valueRange.start = start;
    this.valueRange.end = valueEnd;
    return valueEnd;
  }
  /**
   * Parses a plain value from the source
   *
   * Accepted forms are:
   * ```
   * #comment
   *
   * first line
   *
   * first line #comment
   *
   * first line
   * block
   * lines
   *
   * #comment
   * block
   * lines
   * ```
   * where block lines are empty or have an indent level greater than `indent`.
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar, may be `\n`
   */


  parse(context, start) {
    this.context = context;
    const {
      inFlow,
      src
    } = context;
    let offset = start;
    const ch = src[offset];

    if (ch && ch !== '#' && ch !== '\n') {
      offset = PlainValue.endOfLine(src, start, inFlow);
    }

    this.valueRange = new Range(start, offset);
    offset = Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);

    if (!this.hasComment || this.valueRange.isEmpty()) {
      offset = this.parseBlockValue(offset);
    }

    return offset;
  }

}

exports.Char = Char;
exports.Node = Node;
exports.PlainValue = PlainValue;
exports.Range = Range;
exports.Type = Type;
exports.YAMLError = YAMLError;
exports.YAMLReferenceError = YAMLReferenceError;
exports.YAMLSemanticError = YAMLSemanticError;
exports.YAMLSyntaxError = YAMLSyntaxError;
exports.YAMLWarning = YAMLWarning;
exports._defineProperty = _defineProperty;
exports.defaultTagPrefix = defaultTagPrefix;
exports.defaultTags = defaultTags;


/***/ }),

/***/ 3656:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var PlainValue = __webpack_require__(5215);
var resolveSeq = __webpack_require__(6140);
var warnings = __webpack_require__(7383);

function createMap(schema, obj, ctx) {
  const map = new resolveSeq.YAMLMap(schema);

  if (obj instanceof Map) {
    for (const [key, value] of obj) map.items.push(schema.createPair(key, value, ctx));
  } else if (obj && typeof obj === 'object') {
    for (const key of Object.keys(obj)) map.items.push(schema.createPair(key, obj[key], ctx));
  }

  if (typeof schema.sortMapEntries === 'function') {
    map.items.sort(schema.sortMapEntries);
  }

  return map;
}

const map = {
  createNode: createMap,
  default: true,
  nodeClass: resolveSeq.YAMLMap,
  tag: 'tag:yaml.org,2002:map',
  resolve: resolveSeq.resolveMap
};

function createSeq(schema, obj, ctx) {
  const seq = new resolveSeq.YAMLSeq(schema);

  if (obj && obj[Symbol.iterator]) {
    for (const it of obj) {
      const v = schema.createNode(it, ctx.wrapScalars, null, ctx);
      seq.items.push(v);
    }
  }

  return seq;
}

const seq = {
  createNode: createSeq,
  default: true,
  nodeClass: resolveSeq.YAMLSeq,
  tag: 'tag:yaml.org,2002:seq',
  resolve: resolveSeq.resolveSeq
};

const string = {
  identify: value => typeof value === 'string',
  default: true,
  tag: 'tag:yaml.org,2002:str',
  resolve: resolveSeq.resolveString,

  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({
      actualString: true
    }, ctx);
    return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);
  },

  options: resolveSeq.strOptions
};

const failsafe = [map, seq, string];

/* global BigInt */

const intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);

const intResolve = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);

function intStringify(node, radix, prefix) {
  const {
    value
  } = node;
  if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);
  return resolveSeq.stringifyNumber(node);
}

const nullObj = {
  identify: value => value == null,
  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
  default: true,
  tag: 'tag:yaml.org,2002:null',
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => null,
  options: resolveSeq.nullOptions,
  stringify: () => resolveSeq.nullOptions.nullStr
};
const boolObj = {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: str => str[0] === 't' || str[0] === 'T',
  options: resolveSeq.boolOptions,
  stringify: ({
    value
  }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr
};
const octObj = {
  identify: value => intIdentify(value) && value >= 0,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'OCT',
  test: /^0o([0-7]+)$/,
  resolve: (str, oct) => intResolve(str, oct, 8),
  options: resolveSeq.intOptions,
  stringify: node => intStringify(node, 8, '0o')
};
const intObj = {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^[-+]?[0-9]+$/,
  resolve: str => intResolve(str, str, 10),
  options: resolveSeq.intOptions,
  stringify: resolveSeq.stringifyNumber
};
const hexObj = {
  identify: value => intIdentify(value) && value >= 0,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'HEX',
  test: /^0x([0-9a-fA-F]+)$/,
  resolve: (str, hex) => intResolve(str, hex, 16),
  options: resolveSeq.intOptions,
  stringify: node => intStringify(node, 16, '0x')
};
const nanObj = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^(?:[-+]?\.inf|(\.nan))$/i,
  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: resolveSeq.stringifyNumber
};
const expObj = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'EXP',
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: str => parseFloat(str),
  stringify: ({
    value
  }) => Number(value).toExponential()
};
const floatObj = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,

  resolve(str, frac1, frac2) {
    const frac = frac1 || frac2;
    const node = new resolveSeq.Scalar(parseFloat(str));
    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;
    return node;
  },

  stringify: resolveSeq.stringifyNumber
};
const core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);

/* global BigInt */

const intIdentify$1 = value => typeof value === 'bigint' || Number.isInteger(value);

const stringifyJSON = ({
  value
}) => JSON.stringify(value);

const json = [map, seq, {
  identify: value => typeof value === 'string',
  default: true,
  tag: 'tag:yaml.org,2002:str',
  resolve: resolveSeq.resolveString,
  stringify: stringifyJSON
}, {
  identify: value => value == null,
  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
  default: true,
  tag: 'tag:yaml.org,2002:null',
  test: /^null$/,
  resolve: () => null,
  stringify: stringifyJSON
}, {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^true|false$/,
  resolve: str => str === 'true',
  stringify: stringifyJSON
}, {
  identify: intIdentify$1,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^-?(?:0|[1-9][0-9]*)$/,
  resolve: str => resolveSeq.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),
  stringify: ({
    value
  }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
  resolve: str => parseFloat(str),
  stringify: stringifyJSON
}];

json.scalarFallback = str => {
  throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);
};

/* global BigInt */

const boolStringify = ({
  value
}) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;

const intIdentify$2 = value => typeof value === 'bigint' || Number.isInteger(value);

function intResolve$1(sign, src, radix) {
  let str = src.replace(/_/g, '');

  if (resolveSeq.intOptions.asBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;

      case 8:
        str = `0o${str}`;
        break;

      case 16:
        str = `0x${str}`;
        break;
    }

    const n = BigInt(str);
    return sign === '-' ? BigInt(-1) * n : n;
  }

  const n = parseInt(str, radix);
  return sign === '-' ? -1 * n : n;
}

function intStringify$1(node, radix, prefix) {
  const {
    value
  } = node;

  if (intIdentify$2(value)) {
    const str = value.toString(radix);
    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
  }

  return resolveSeq.stringifyNumber(node);
}

const yaml11 = failsafe.concat([{
  identify: value => value == null,
  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
  default: true,
  tag: 'tag:yaml.org,2002:null',
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => null,
  options: resolveSeq.nullOptions,
  stringify: () => resolveSeq.nullOptions.nullStr
}, {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => true,
  options: resolveSeq.boolOptions,
  stringify: boolStringify
}, {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => false,
  options: resolveSeq.boolOptions,
  stringify: boolStringify
}, {
  identify: intIdentify$2,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'BIN',
  test: /^([-+]?)0b([0-1_]+)$/,
  resolve: (str, sign, bin) => intResolve$1(sign, bin, 2),
  stringify: node => intStringify$1(node, 2, '0b')
}, {
  identify: intIdentify$2,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'OCT',
  test: /^([-+]?)0([0-7_]+)$/,
  resolve: (str, sign, oct) => intResolve$1(sign, oct, 8),
  stringify: node => intStringify$1(node, 8, '0')
}, {
  identify: intIdentify$2,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^([-+]?)([0-9][0-9_]*)$/,
  resolve: (str, sign, abs) => intResolve$1(sign, abs, 10),
  stringify: resolveSeq.stringifyNumber
}, {
  identify: intIdentify$2,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'HEX',
  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
  resolve: (str, sign, hex) => intResolve$1(sign, hex, 16),
  stringify: node => intStringify$1(node, 16, '0x')
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^(?:[-+]?\.inf|(\.nan))$/i,
  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: resolveSeq.stringifyNumber
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'EXP',
  test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: str => parseFloat(str.replace(/_/g, '')),
  stringify: ({
    value
  }) => Number(value).toExponential()
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,

  resolve(str, frac) {
    const node = new resolveSeq.Scalar(parseFloat(str.replace(/_/g, '')));

    if (frac) {
      const f = frac.replace(/_/g, '');
      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;
    }

    return node;
  },

  stringify: resolveSeq.stringifyNumber
}], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);

const schemas = {
  core,
  failsafe,
  json,
  yaml11
};
const tags = {
  binary: warnings.binary,
  bool: boolObj,
  float: floatObj,
  floatExp: expObj,
  floatNaN: nanObj,
  floatTime: warnings.floatTime,
  int: intObj,
  intHex: hexObj,
  intOct: octObj,
  intTime: warnings.intTime,
  map,
  null: nullObj,
  omap: warnings.omap,
  pairs: warnings.pairs,
  seq,
  set: warnings.set,
  timestamp: warnings.timestamp
};

function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter(t => t.tag === tagName);
    const tagObj = match.find(t => !t.format) || match[0];
    if (!tagObj) throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  } // TODO: deprecate/remove class check


  return tags.find(t => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);
}

function createNode(value, tagName, ctx) {
  if (value instanceof resolveSeq.Node) return value;
  const {
    defaultPrefix,
    onTagObj,
    prevObjects,
    schema,
    wrapScalars
  } = ctx;
  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema.tags);

  if (!tagObj) {
    if (typeof value.toJSON === 'function') value = value.toJSON();
    if (typeof value !== 'object') return wrapScalars ? new resolveSeq.Scalar(value) : value;
    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;
  }

  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  } // Detect duplicate references to the same object & use Alias nodes for all
  // after first. The `obj` wrapper allows for circular references to resolve.


  const obj = {};

  if (value && typeof value === 'object' && prevObjects) {
    const prev = prevObjects.get(value);

    if (prev) {
      const alias = new resolveSeq.Alias(prev); // leaves source dirty; must be cleaned by caller

      ctx.aliasNodes.push(alias); // defined along with prevObjects

      return alias;
    }

    obj.value = value;
    prevObjects.set(value, obj);
  }

  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;
  if (tagName && obj.node instanceof resolveSeq.Node) obj.node.tag = tagName;
  return obj.node;
}

function getSchemaTags(schemas, knownTags, customTags, schemaId) {
  let tags = schemas[schemaId.replace(/\W/g, '')]; // 'yaml-1.1' -> 'yaml11'

  if (!tags) {
    const keys = Object.keys(schemas).map(key => JSON.stringify(key)).join(', ');
    throw new Error(`Unknown schema "${schemaId}"; use one of ${keys}`);
  }

  if (Array.isArray(customTags)) {
    for (const tag of customTags) tags = tags.concat(tag);
  } else if (typeof customTags === 'function') {
    tags = customTags(tags.slice());
  }

  for (let i = 0; i < tags.length; ++i) {
    const tag = tags[i];

    if (typeof tag === 'string') {
      const tagObj = knownTags[tag];

      if (!tagObj) {
        const keys = Object.keys(knownTags).map(key => JSON.stringify(key)).join(', ');
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
      }

      tags[i] = tagObj;
    }
  }

  return tags;
}

const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;

class Schema {
  // TODO: remove in v2
  // TODO: remove in v2
  constructor({
    customTags,
    merge,
    schema,
    sortMapEntries,
    tags: deprecatedCustomTags
  }) {
    this.merge = !!merge;
    this.name = schema;
    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
    if (!customTags && deprecatedCustomTags) warnings.warnOptionDeprecation('tags', 'customTags');
    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);
  }

  createNode(value, wrapScalars, tagName, ctx) {
    const baseCtx = {
      defaultPrefix: Schema.defaultPrefix,
      schema: this,
      wrapScalars
    };
    const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
    return createNode(value, tagName, createCtx);
  }

  createPair(key, value, ctx) {
    if (!ctx) ctx = {
      wrapScalars: true
    };
    const k = this.createNode(key, ctx.wrapScalars, null, ctx);
    const v = this.createNode(value, ctx.wrapScalars, null, ctx);
    return new resolveSeq.Pair(k, v);
  }

}

PlainValue._defineProperty(Schema, "defaultPrefix", PlainValue.defaultTagPrefix);

PlainValue._defineProperty(Schema, "defaultTags", PlainValue.defaultTags);

exports.Schema = Schema;


/***/ }),

/***/ 5065:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var PlainValue = __webpack_require__(5215);
var parseCst = __webpack_require__(445);
__webpack_require__(6140);
var Document$1 = __webpack_require__(1983);
var Schema = __webpack_require__(3656);
var warnings = __webpack_require__(7383);

function createNode(value, wrapScalars = true, tag) {
  if (tag === undefined && typeof wrapScalars === 'string') {
    tag = wrapScalars;
    wrapScalars = true;
  }

  const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);
  const schema = new Schema.Schema(options);
  return schema.createNode(value, wrapScalars, tag);
}

class Document extends Document$1.Document {
  constructor(options) {
    super(Object.assign({}, Document$1.defaultOptions, options));
  }

}

function parseAllDocuments(src, options) {
  const stream = [];
  let prev;

  for (const cstDoc of parseCst.parse(src)) {
    const doc = new Document(options);
    doc.parse(cstDoc, prev);
    stream.push(doc);
    prev = doc;
  }

  return stream;
}

function parseDocument(src, options) {
  const cst = parseCst.parse(src);
  const doc = new Document(options).parse(cst[0]);

  if (cst.length > 1) {
    const errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';
    doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));
  }

  return doc;
}

function parse(src, options) {
  const doc = parseDocument(src, options);
  doc.warnings.forEach(warning => warnings.warn(warning));
  if (doc.errors.length > 0) throw doc.errors[0];
  return doc.toJSON();
}

function stringify(value, options) {
  const doc = new Document(options);
  doc.contents = value;
  return String(doc);
}

const YAML = {
  createNode,
  defaultOptions: Document$1.defaultOptions,
  Document,
  parse,
  parseAllDocuments,
  parseCST: parseCst.parse,
  parseDocument,
  scalarOptions: Document$1.scalarOptions,
  stringify
};

exports.YAML = YAML;


/***/ }),

/***/ 445:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var PlainValue = __webpack_require__(5215);

class BlankLine extends PlainValue.Node {
  constructor() {
    super(PlainValue.Type.BLANK_LINE);
  }
  /* istanbul ignore next */


  get includesTrailingLines() {
    // This is never called from anywhere, but if it were,
    // this is the value it should return.
    return true;
  }
  /**
   * Parses a blank line from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first \n character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    this.range = new PlainValue.Range(start, start + 1);
    return start + 1;
  }

}

class CollectionItem extends PlainValue.Node {
  constructor(type, props) {
    super(type, props);
    this.node = null;
  }

  get includesTrailingLines() {
    return !!this.node && this.node.includesTrailingLines;
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    const {
      parseNode,
      src
    } = context;
    let {
      atLineStart,
      lineStart
    } = context;
    if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');
    const indent = atLineStart ? start - lineStart : context.indent;
    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
    let ch = src[offset];
    const inlineComment = ch === '#';
    const comments = [];
    let blankLine = null;

    while (ch === '\n' || ch === '#') {
      if (ch === '#') {
        const end = PlainValue.Node.endOfLine(src, offset + 1);
        comments.push(new PlainValue.Range(offset, end));
        offset = end;
      } else {
        atLineStart = true;
        lineStart = offset + 1;
        const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);

        if (src[wsEnd] === '\n' && comments.length === 0) {
          blankLine = new BlankLine();
          lineStart = blankLine.parse({
            src
          }, lineStart);
        }

        offset = PlainValue.Node.endOfIndent(src, lineStart);
      }

      ch = src[offset];
    }

    if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {
      this.node = parseNode({
        atLineStart,
        inCollection: false,
        indent,
        lineStart,
        parent: this
      }, offset);
    } else if (ch && lineStart > start + 1) {
      offset = lineStart - 1;
    }

    if (this.node) {
      if (blankLine) {
        // Only blank lines preceding non-empty nodes are captured. Note that
        // this means that collection item range start indices do not always
        // increase monotonically. -- eemeli/yaml#126
        const items = context.parent.items || context.parent.contents;
        if (items) items.push(blankLine);
      }

      if (comments.length) Array.prototype.push.apply(this.props, comments);
      offset = this.node.range.end;
    } else {
      if (inlineComment) {
        const c = comments[0];
        this.props.push(c);
        offset = c.end;
      } else {
        offset = PlainValue.Node.endOfLine(src, start + 1);
      }
    }

    const end = this.node ? this.node.valueRange.end : offset;
    this.valueRange = new PlainValue.Range(start, end);
    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    return this.node ? this.node.setOrigRanges(cr, offset) : offset;
  }

  toString() {
    const {
      context: {
        src
      },
      node,
      range,
      value
    } = this;
    if (value != null) return value;
    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
    return PlainValue.Node.addStringTerminator(src, range.end, str);
  }

}

class Comment extends PlainValue.Node {
  constructor() {
    super(PlainValue.Type.COMMENT);
  }
  /**
   * Parses a comment line from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */


  parse(context, start) {
    this.context = context;
    const offset = this.parseComment(start);
    this.range = new PlainValue.Range(start, offset);
    return offset;
  }

}

function grabCollectionEndComments(node) {
  let cnode = node;

  while (cnode instanceof CollectionItem) cnode = cnode.node;

  if (!(cnode instanceof Collection)) return null;
  const len = cnode.items.length;
  let ci = -1;

  for (let i = len - 1; i >= 0; --i) {
    const n = cnode.items[i];

    if (n.type === PlainValue.Type.COMMENT) {
      // Keep sufficiently indented comments with preceding node
      const {
        indent,
        lineStart
      } = n.context;
      if (indent > 0 && n.range.start >= lineStart + indent) break;
      ci = i;
    } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;else break;
  }

  if (ci === -1) return null;
  const ca = cnode.items.splice(ci, len - ci);
  const prevEnd = ca[0].range.start;

  while (true) {
    cnode.range.end = prevEnd;
    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;
    if (cnode === node) break;
    cnode = cnode.context.parent;
  }

  return ca;
}
class Collection extends PlainValue.Node {
  static nextContentHasIndent(src, offset, indent) {
    const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;
    offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);
    const ch = src[offset];
    if (!ch) return false;
    if (offset >= lineStart + indent) return true;
    if (ch !== '#' && ch !== '\n') return false;
    return Collection.nextContentHasIndent(src, offset, indent);
  }

  constructor(firstItem) {
    super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);

    for (let i = firstItem.props.length - 1; i >= 0; --i) {
      if (firstItem.props[i].start < firstItem.context.lineStart) {
        // props on previous line are assumed by the collection
        this.props = firstItem.props.slice(0, i + 1);
        firstItem.props = firstItem.props.slice(i + 1);
        const itemRange = firstItem.props[0] || firstItem.valueRange;
        firstItem.range.start = itemRange.start;
        break;
      }
    }

    this.items = [firstItem];
    const ec = grabCollectionEndComments(firstItem);
    if (ec) Array.prototype.push.apply(this.items, ec);
  }

  get includesTrailingLines() {
    return this.items.length > 0;
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    const {
      parseNode,
      src
    } = context; // It's easier to recalculate lineStart here rather than tracking down the
    // last context from which to read it -- eemeli/yaml#2

    let lineStart = PlainValue.Node.startOfLine(src, start);
    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling
    // -- eemeli/yaml#17

    firstItem.context.parent = this;
    this.valueRange = PlainValue.Range.copy(firstItem.valueRange);
    const indent = firstItem.range.start - firstItem.context.lineStart;
    let offset = start;
    offset = PlainValue.Node.normalizeOffset(src, offset);
    let ch = src[offset];
    let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;
    let prevIncludesTrailingLines = false;

    while (ch) {
      while (ch === '\n' || ch === '#') {
        if (atLineStart && ch === '\n' && !prevIncludesTrailingLines) {
          const blankLine = new BlankLine();
          offset = blankLine.parse({
            src
          }, offset);
          this.valueRange.end = offset;

          if (offset >= src.length) {
            ch = null;
            break;
          }

          this.items.push(blankLine);
          offset -= 1; // blankLine.parse() consumes terminal newline
        } else if (ch === '#') {
          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {
            return offset;
          }

          const comment = new Comment();
          offset = comment.parse({
            indent,
            lineStart,
            src
          }, offset);
          this.items.push(comment);
          this.valueRange.end = offset;

          if (offset >= src.length) {
            ch = null;
            break;
          }
        }

        lineStart = offset + 1;
        offset = PlainValue.Node.endOfIndent(src, lineStart);

        if (PlainValue.Node.atBlank(src, offset)) {
          const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);
          const next = src[wsEnd];

          if (!next || next === '\n' || next === '#') {
            offset = wsEnd;
          }
        }

        ch = src[offset];
        atLineStart = true;
      }

      if (!ch) {
        break;
      }

      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {
        if (offset < lineStart + indent) {
          if (lineStart > start) offset = lineStart;
          break;
        } else if (!this.error) {
          const msg = 'All collection items must start at the same column';
          this.error = new PlainValue.YAMLSyntaxError(this, msg);
        }
      }

      if (firstItem.type === PlainValue.Type.SEQ_ITEM) {
        if (ch !== '-') {
          if (lineStart > start) offset = lineStart;
          break;
        }
      } else if (ch === '-' && !this.error) {
        // map key may start with -, as long as it's followed by a non-whitespace char
        const next = src[offset + 1];

        if (!next || next === '\n' || next === '\t' || next === ' ') {
          const msg = 'A collection cannot be both a mapping and a sequence';
          this.error = new PlainValue.YAMLSyntaxError(this, msg);
        }
      }

      const node = parseNode({
        atLineStart,
        inCollection: true,
        indent,
        lineStart,
        parent: this
      }, offset);
      if (!node) return offset; // at next document start

      this.items.push(node);
      this.valueRange.end = node.valueRange.end;
      offset = PlainValue.Node.normalizeOffset(src, node.range.end);
      ch = src[offset];
      atLineStart = false;
      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range
      // has advanced to check the current line's indentation level
      // -- eemeli/yaml#10 & eemeli/yaml#38

      if (ch) {
        let ls = offset - 1;
        let prev = src[ls];

        while (prev === ' ' || prev === '\t') prev = src[--ls];

        if (prev === '\n') {
          lineStart = ls + 1;
          atLineStart = true;
        }
      }

      const ec = grabCollectionEndComments(node);
      if (ec) Array.prototype.push.apply(this.items, ec);
    }

    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    this.items.forEach(node => {
      offset = node.setOrigRanges(cr, offset);
    });
    return offset;
  }

  toString() {
    const {
      context: {
        src
      },
      items,
      range,
      value
    } = this;
    if (value != null) return value;
    let str = src.slice(range.start, items[0].range.start) + String(items[0]);

    for (let i = 1; i < items.length; ++i) {
      const item = items[i];
      const {
        atLineStart,
        indent
      } = item.context;
      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';
      str += String(item);
    }

    return PlainValue.Node.addStringTerminator(src, range.end, str);
  }

}

class Directive extends PlainValue.Node {
  constructor() {
    super(PlainValue.Type.DIRECTIVE);
    this.name = null;
  }

  get parameters() {
    const raw = this.rawValue;
    return raw ? raw.trim().split(/[ \t]+/) : [];
  }

  parseName(start) {
    const {
      src
    } = this.context;
    let offset = start;
    let ch = src[offset];

    while (ch && ch !== '\n' && ch !== '\t' && ch !== ' ') ch = src[offset += 1];

    this.name = src.slice(start, offset);
    return offset;
  }

  parseParameters(start) {
    const {
      src
    } = this.context;
    let offset = start;
    let ch = src[offset];

    while (ch && ch !== '\n' && ch !== '#') ch = src[offset += 1];

    this.valueRange = new PlainValue.Range(start, offset);
    return offset;
  }

  parse(context, start) {
    this.context = context;
    let offset = this.parseName(start + 1);
    offset = this.parseParameters(offset);
    offset = this.parseComment(offset);
    this.range = new PlainValue.Range(start, offset);
    return offset;
  }

}

class Document extends PlainValue.Node {
  static startCommentOrEndBlankLine(src, start) {
    const offset = PlainValue.Node.endOfWhiteSpace(src, start);
    const ch = src[offset];
    return ch === '#' || ch === '\n' ? offset : start;
  }

  constructor() {
    super(PlainValue.Type.DOCUMENT);
    this.directives = null;
    this.contents = null;
    this.directivesEndMarker = null;
    this.documentEndMarker = null;
  }

  parseDirectives(start) {
    const {
      src
    } = this.context;
    this.directives = [];
    let atLineStart = true;
    let hasDirectives = false;
    let offset = start;

    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {
      offset = Document.startCommentOrEndBlankLine(src, offset);

      switch (src[offset]) {
        case '\n':
          if (atLineStart) {
            const blankLine = new BlankLine();
            offset = blankLine.parse({
              src
            }, offset);

            if (offset < src.length) {
              this.directives.push(blankLine);
            }
          } else {
            offset += 1;
            atLineStart = true;
          }

          break;

        case '#':
          {
            const comment = new Comment();
            offset = comment.parse({
              src
            }, offset);
            this.directives.push(comment);
            atLineStart = false;
          }
          break;

        case '%':
          {
            const directive = new Directive();
            offset = directive.parse({
              parent: this,
              src
            }, offset);
            this.directives.push(directive);
            hasDirectives = true;
            atLineStart = false;
          }
          break;

        default:
          if (hasDirectives) {
            this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');
          } else if (this.directives.length > 0) {
            this.contents = this.directives;
            this.directives = [];
          }

          return offset;
      }
    }

    if (src[offset]) {
      this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);
      return offset + 3;
    }

    if (hasDirectives) {
      this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');
    } else if (this.directives.length > 0) {
      this.contents = this.directives;
      this.directives = [];
    }

    return offset;
  }

  parseContents(start) {
    const {
      parseNode,
      src
    } = this.context;
    if (!this.contents) this.contents = [];
    let lineStart = start;

    while (src[lineStart - 1] === '-') lineStart -= 1;

    let offset = PlainValue.Node.endOfWhiteSpace(src, start);
    let atLineStart = lineStart === start;
    this.valueRange = new PlainValue.Range(offset);

    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {
      switch (src[offset]) {
        case '\n':
          if (atLineStart) {
            const blankLine = new BlankLine();
            offset = blankLine.parse({
              src
            }, offset);

            if (offset < src.length) {
              this.contents.push(blankLine);
            }
          } else {
            offset += 1;
            atLineStart = true;
          }

          lineStart = offset;
          break;

        case '#':
          {
            const comment = new Comment();
            offset = comment.parse({
              src
            }, offset);
            this.contents.push(comment);
            atLineStart = false;
          }
          break;

        default:
          {
            const iEnd = PlainValue.Node.endOfIndent(src, offset);
            const context = {
              atLineStart,
              indent: -1,
              inFlow: false,
              inCollection: false,
              lineStart,
              parent: this
            };
            const node = parseNode(context, iEnd);
            if (!node) return this.valueRange.end = iEnd; // at next document start

            this.contents.push(node);
            offset = node.range.end;
            atLineStart = false;
            const ec = grabCollectionEndComments(node);
            if (ec) Array.prototype.push.apply(this.contents, ec);
          }
      }

      offset = Document.startCommentOrEndBlankLine(src, offset);
    }

    this.valueRange.end = offset;

    if (src[offset]) {
      this.documentEndMarker = new PlainValue.Range(offset, offset + 3);
      offset += 3;

      if (src[offset]) {
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);

        if (src[offset] === '#') {
          const comment = new Comment();
          offset = comment.parse({
            src
          }, offset);
          this.contents.push(comment);
        }

        switch (src[offset]) {
          case '\n':
            offset += 1;
            break;

          case undefined:
            break;

          default:
            this.error = new PlainValue.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');
        }
      }
    }

    return offset;
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    context.root = this;
    this.context = context;
    const {
      src
    } = context;
    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM

    offset = this.parseDirectives(offset);
    offset = this.parseContents(offset);
    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    this.directives.forEach(node => {
      offset = node.setOrigRanges(cr, offset);
    });
    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);
    this.contents.forEach(node => {
      offset = node.setOrigRanges(cr, offset);
    });
    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);
    return offset;
  }

  toString() {
    const {
      contents,
      directives,
      value
    } = this;
    if (value != null) return value;
    let str = directives.join('');

    if (contents.length > 0) {
      if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str += '---\n';
      str += contents.join('');
    }

    if (str[str.length - 1] !== '\n') str += '\n';
    return str;
  }

}

class Alias extends PlainValue.Node {
  /**
   * Parses an *alias from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */
  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = PlainValue.Node.endOfIdentifier(src, start + 1);
    this.valueRange = new PlainValue.Range(start + 1, offset);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
  }

}

const Chomp = {
  CLIP: 'CLIP',
  KEEP: 'KEEP',
  STRIP: 'STRIP'
};
class BlockValue extends PlainValue.Node {
  constructor(type, props) {
    super(type, props);
    this.blockIndent = null;
    this.chomping = Chomp.CLIP;
    this.header = null;
  }

  get includesTrailingLines() {
    return this.chomping === Chomp.KEEP;
  }

  get strValue() {
    if (!this.valueRange || !this.context) return null;
    let {
      start,
      end
    } = this.valueRange;
    const {
      indent,
      src
    } = this.context;
    if (this.valueRange.isEmpty()) return '';
    let lastNewLine = null;
    let ch = src[end - 1];

    while (ch === '\n' || ch === '\t' || ch === ' ') {
      end -= 1;

      if (end <= start) {
        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens
      }

      if (ch === '\n') lastNewLine = end;
      ch = src[end - 1];
    }

    let keepStart = end + 1;

    if (lastNewLine) {
      if (this.chomping === Chomp.KEEP) {
        keepStart = lastNewLine;
        end = this.valueRange.end;
      } else {
        end = lastNewLine;
      }
    }

    const bi = indent + this.blockIndent;
    const folded = this.type === PlainValue.Type.BLOCK_FOLDED;
    let atStart = true;
    let str = '';
    let sep = '';
    let prevMoreIndented = false;

    for (let i = start; i < end; ++i) {
      for (let j = 0; j < bi; ++j) {
        if (src[i] !== ' ') break;
        i += 1;
      }

      const ch = src[i];

      if (ch === '\n') {
        if (sep === '\n') str += '\n';else sep = '\n';
      } else {
        const lineEnd = PlainValue.Node.endOfLine(src, i);
        const line = src.slice(i, lineEnd);
        i = lineEnd;

        if (folded && (ch === ' ' || ch === '\t') && i < keepStart) {
          if (sep === ' ') sep = '\n';else if (!prevMoreIndented && !atStart && sep === '\n') sep = '\n\n';
          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')

          sep = lineEnd < end && src[lineEnd] || '';
          prevMoreIndented = true;
        } else {
          str += sep + line;
          sep = folded && i < keepStart ? ' ' : '\n';
          prevMoreIndented = false;
        }

        if (atStart && line !== '') atStart = false;
      }
    }

    return this.chomping === Chomp.STRIP ? str : str + '\n';
  }

  parseBlockHeader(start) {
    const {
      src
    } = this.context;
    let offset = start + 1;
    let bi = '';

    while (true) {
      const ch = src[offset];

      switch (ch) {
        case '-':
          this.chomping = Chomp.STRIP;
          break;

        case '+':
          this.chomping = Chomp.KEEP;
          break;

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          bi += ch;
          break;

        default:
          this.blockIndent = Number(bi) || null;
          this.header = new PlainValue.Range(start, offset);
          return offset;
      }

      offset += 1;
    }
  }

  parseBlockValue(start) {
    const {
      indent,
      src
    } = this.context;
    const explicit = !!this.blockIndent;
    let offset = start;
    let valueEnd = start;
    let minBlockIndent = 1;

    for (let ch = src[offset]; ch === '\n'; ch = src[offset]) {
      offset += 1;
      if (PlainValue.Node.atDocumentBoundary(src, offset)) break;
      const end = PlainValue.Node.endOfBlockIndent(src, indent, offset); // should not include tab?

      if (end === null) break;
      const ch = src[end];
      const lineIndent = end - (offset + indent);

      if (!this.blockIndent) {
        // no explicit block indent, none yet detected
        if (src[end] !== '\n') {
          // first line with non-whitespace content
          if (lineIndent < minBlockIndent) {
            const msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
            this.error = new PlainValue.YAMLSemanticError(this, msg);
          }

          this.blockIndent = lineIndent;
        } else if (lineIndent > minBlockIndent) {
          // empty line with more whitespace
          minBlockIndent = lineIndent;
        }
      } else if (ch && ch !== '\n' && lineIndent < this.blockIndent) {
        if (src[end] === '#') break;

        if (!this.error) {
          const src = explicit ? 'explicit indentation indicator' : 'first line';
          const msg = `Block scalars must not be less indented than their ${src}`;
          this.error = new PlainValue.YAMLSemanticError(this, msg);
        }
      }

      if (src[end] === '\n') {
        offset = end;
      } else {
        offset = valueEnd = PlainValue.Node.endOfLine(src, end);
      }
    }

    if (this.chomping !== Chomp.KEEP) {
      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
    }

    this.valueRange = new PlainValue.Range(start + 1, offset);
    return offset;
  }
  /**
   * Parses a block value from the source
   *
   * Accepted forms are:
   * ```
   * BS
   * block
   * lines
   *
   * BS #comment
   * block
   * lines
   * ```
   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
   * are empty or have an indent level greater than `indent`.
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this block
   */


  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = this.parseBlockHeader(start);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    offset = this.parseBlockValue(offset);
    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    return this.header ? this.header.setOrigRange(cr, offset) : offset;
  }

}

class FlowCollection extends PlainValue.Node {
  constructor(type, props) {
    super(type, props);
    this.items = null;
  }

  prevNodeIsJsonLike(idx = this.items.length) {
    const node = this.items[idx - 1];
    return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    const {
      parseNode,
      src
    } = context;
    let {
      indent,
      lineStart
    } = context;
    let char = src[start]; // { or [

    this.items = [{
      char,
      offset: start
    }];
    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
    char = src[offset];

    while (char && char !== ']' && char !== '}') {
      switch (char) {
        case '\n':
          {
            lineStart = offset + 1;
            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);

            if (src[wsEnd] === '\n') {
              const blankLine = new BlankLine();
              lineStart = blankLine.parse({
                src
              }, lineStart);
              this.items.push(blankLine);
            }

            offset = PlainValue.Node.endOfIndent(src, lineStart);

            if (offset <= lineStart + indent) {
              char = src[offset];

              if (offset < lineStart + indent || char !== ']' && char !== '}') {
                const msg = 'Insufficient indentation in flow collection';
                this.error = new PlainValue.YAMLSemanticError(this, msg);
              }
            }
          }
          break;

        case ',':
          {
            this.items.push({
              char,
              offset
            });
            offset += 1;
          }
          break;

        case '#':
          {
            const comment = new Comment();
            offset = comment.parse({
              src
            }, offset);
            this.items.push(comment);
          }
          break;

        case '?':
        case ':':
          {
            const next = src[offset + 1];

            if (next === '\n' || next === '\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace
            char === ':' && this.prevNodeIsJsonLike()) {
              this.items.push({
                char,
                offset
              });
              offset += 1;
              break;
            }
          }
        // fallthrough

        default:
          {
            const node = parseNode({
              atLineStart: false,
              inCollection: false,
              inFlow: true,
              indent: -1,
              lineStart,
              parent: this
            }, offset);

            if (!node) {
              // at next document start
              this.valueRange = new PlainValue.Range(start, offset);
              return offset;
            }

            this.items.push(node);
            offset = PlainValue.Node.normalizeOffset(src, node.range.end);
          }
      }

      offset = PlainValue.Node.endOfWhiteSpace(src, offset);
      char = src[offset];
    }

    this.valueRange = new PlainValue.Range(start, offset + 1);

    if (char) {
      this.items.push({
        char,
        offset
      });
      offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);
      offset = this.parseComment(offset);
    }

    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    this.items.forEach(node => {
      if (node instanceof PlainValue.Node) {
        offset = node.setOrigRanges(cr, offset);
      } else if (cr.length === 0) {
        node.origOffset = node.offset;
      } else {
        let i = offset;

        while (i < cr.length) {
          if (cr[i] > node.offset) break;else ++i;
        }

        node.origOffset = node.offset + i;
        offset = i;
      }
    });
    return offset;
  }

  toString() {
    const {
      context: {
        src
      },
      items,
      range,
      value
    } = this;
    if (value != null) return value;
    const nodes = items.filter(item => item instanceof PlainValue.Node);
    let str = '';
    let prevEnd = range.start;
    nodes.forEach(node => {
      const prefix = src.slice(prevEnd, node.range.start);
      prevEnd = node.range.end;
      str += prefix + String(node);

      if (str[str.length - 1] === '\n' && src[prevEnd - 1] !== '\n' && src[prevEnd] === '\n') {
        // Comment range does not include the terminal newline, but its
        // stringified value does. Without this fix, newlines at comment ends
        // get duplicated.
        prevEnd += 1;
      }
    });
    str += src.slice(prevEnd, range.end);
    return PlainValue.Node.addStringTerminator(src, range.end, str);
  }

}

class QuoteDouble extends PlainValue.Node {
  static endOfQuote(src, offset) {
    let ch = src[offset];

    while (ch && ch !== '"') {
      offset += ch === '\\' ? 2 : 1;
      ch = src[offset];
    }

    return offset + 1;
  }
  /**
   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
   */


  get strValue() {
    if (!this.valueRange || !this.context) return null;
    const errors = [];
    const {
      start,
      end
    } = this.valueRange;
    const {
      indent,
      src
    } = this.context;
    if (src[end - 1] !== '"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing "quote')); // Using String#replace is too painful with escaped newlines preceded by
    // escaped backslashes; also, this should be faster.

    let str = '';

    for (let i = start + 1; i < end - 1; ++i) {
      const ch = src[i];

      if (ch === '\n') {
        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));
        const {
          fold,
          offset,
          error
        } = PlainValue.Node.foldNewline(src, i, indent);
        str += fold;
        i = offset;
        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));
      } else if (ch === '\\') {
        i += 1;

        switch (src[i]) {
          case '0':
            str += '\0';
            break;
          // null character

          case 'a':
            str += '\x07';
            break;
          // bell character

          case 'b':
            str += '\b';
            break;
          // backspace

          case 'e':
            str += '\x1b';
            break;
          // escape character

          case 'f':
            str += '\f';
            break;
          // form feed

          case 'n':
            str += '\n';
            break;
          // line feed

          case 'r':
            str += '\r';
            break;
          // carriage return

          case 't':
            str += '\t';
            break;
          // horizontal tab

          case 'v':
            str += '\v';
            break;
          // vertical tab

          case 'N':
            str += '\u0085';
            break;
          // Unicode next line

          case '_':
            str += '\u00a0';
            break;
          // Unicode non-breaking space

          case 'L':
            str += '\u2028';
            break;
          // Unicode line separator

          case 'P':
            str += '\u2029';
            break;
          // Unicode paragraph separator

          case ' ':
            str += ' ';
            break;

          case '"':
            str += '"';
            break;

          case '/':
            str += '/';
            break;

          case '\\':
            str += '\\';
            break;

          case '\t':
            str += '\t';
            break;

          case 'x':
            str += this.parseCharCode(i + 1, 2, errors);
            i += 2;
            break;

          case 'u':
            str += this.parseCharCode(i + 1, 4, errors);
            i += 4;
            break;

          case 'U':
            str += this.parseCharCode(i + 1, 8, errors);
            i += 8;
            break;

          case '\n':
            // skip escaped newlines, but still trim the following line
            while (src[i + 1] === ' ' || src[i + 1] === '\t') i += 1;

            break;

          default:
            errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));
            str += '\\' + src[i];
        }
      } else if (ch === ' ' || ch === '\t') {
        // trim trailing whitespace
        const wsStart = i;
        let next = src[i + 1];

        while (next === ' ' || next === '\t') {
          i += 1;
          next = src[i + 1];
        }

        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
      } else {
        str += ch;
      }
    }

    return errors.length > 0 ? {
      errors,
      str
    } : str;
  }

  parseCharCode(offset, length, errors) {
    const {
      src
    } = this.context;
    const cc = src.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;

    if (isNaN(code)) {
      errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));
      return src.substr(offset - 2, length + 2);
    }

    return String.fromCodePoint(code);
  }
  /**
   * Parses a "double quoted" value from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */


  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = QuoteDouble.endOfQuote(src, start + 1);
    this.valueRange = new PlainValue.Range(start, offset);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
  }

}

class QuoteSingle extends PlainValue.Node {
  static endOfQuote(src, offset) {
    let ch = src[offset];

    while (ch) {
      if (ch === "'") {
        if (src[offset + 1] !== "'") break;
        ch = src[offset += 2];
      } else {
        ch = src[offset += 1];
      }
    }

    return offset + 1;
  }
  /**
   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
   */


  get strValue() {
    if (!this.valueRange || !this.context) return null;
    const errors = [];
    const {
      start,
      end
    } = this.valueRange;
    const {
      indent,
      src
    } = this.context;
    if (src[end - 1] !== "'") errors.push(new PlainValue.YAMLSyntaxError(this, "Missing closing 'quote"));
    let str = '';

    for (let i = start + 1; i < end - 1; ++i) {
      const ch = src[i];

      if (ch === '\n') {
        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));
        const {
          fold,
          offset,
          error
        } = PlainValue.Node.foldNewline(src, i, indent);
        str += fold;
        i = offset;
        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));
      } else if (ch === "'") {
        str += ch;
        i += 1;
        if (src[i] !== "'") errors.push(new PlainValue.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));
      } else if (ch === ' ' || ch === '\t') {
        // trim trailing whitespace
        const wsStart = i;
        let next = src[i + 1];

        while (next === ' ' || next === '\t') {
          i += 1;
          next = src[i + 1];
        }

        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
      } else {
        str += ch;
      }
    }

    return errors.length > 0 ? {
      errors,
      str
    } : str;
  }
  /**
   * Parses a 'single quoted' value from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */


  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = QuoteSingle.endOfQuote(src, start + 1);
    this.valueRange = new PlainValue.Range(start, offset);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
  }

}

function createNewNode(type, props) {
  switch (type) {
    case PlainValue.Type.ALIAS:
      return new Alias(type, props);

    case PlainValue.Type.BLOCK_FOLDED:
    case PlainValue.Type.BLOCK_LITERAL:
      return new BlockValue(type, props);

    case PlainValue.Type.FLOW_MAP:
    case PlainValue.Type.FLOW_SEQ:
      return new FlowCollection(type, props);

    case PlainValue.Type.MAP_KEY:
    case PlainValue.Type.MAP_VALUE:
    case PlainValue.Type.SEQ_ITEM:
      return new CollectionItem(type, props);

    case PlainValue.Type.COMMENT:
    case PlainValue.Type.PLAIN:
      return new PlainValue.PlainValue(type, props);

    case PlainValue.Type.QUOTE_DOUBLE:
      return new QuoteDouble(type, props);

    case PlainValue.Type.QUOTE_SINGLE:
      return new QuoteSingle(type, props);

    /* istanbul ignore next */

    default:
      return null;
    // should never happen
  }
}
/**
 * @param {boolean} atLineStart - Node starts at beginning of line
 * @param {boolean} inFlow - true if currently in a flow context
 * @param {boolean} inCollection - true if currently in a collection context
 * @param {number} indent - Current level of indentation
 * @param {number} lineStart - Start of the current line
 * @param {Node} parent - The parent of the node
 * @param {string} src - Source of the YAML document
 */


class ParseContext {
  static parseType(src, offset, inFlow) {
    switch (src[offset]) {
      case '*':
        return PlainValue.Type.ALIAS;

      case '>':
        return PlainValue.Type.BLOCK_FOLDED;

      case '|':
        return PlainValue.Type.BLOCK_LITERAL;

      case '{':
        return PlainValue.Type.FLOW_MAP;

      case '[':
        return PlainValue.Type.FLOW_SEQ;

      case '?':
        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;

      case ':':
        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;

      case '-':
        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;

      case '"':
        return PlainValue.Type.QUOTE_DOUBLE;

      case "'":
        return PlainValue.Type.QUOTE_SINGLE;

      default:
        return PlainValue.Type.PLAIN;
    }
  }

  constructor(orig = {}, {
    atLineStart,
    inCollection,
    inFlow,
    indent,
    lineStart,
    parent
  } = {}) {
    PlainValue._defineProperty(this, "parseNode", (overlay, start) => {
      if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;
      const context = new ParseContext(this, overlay);
      const {
        props,
        type,
        valueStart
      } = context.parseProps(start);
      const node = createNewNode(type, props);
      let offset = node.parse(context, valueStart);
      node.range = new PlainValue.Range(start, offset);
      /* istanbul ignore if */

      if (offset <= start) {
        // This should never happen, but if it does, let's make sure to at least
        // step one character forward to avoid a busy loop.
        node.error = new Error(`Node#parse consumed no characters`);
        node.error.parseEnd = offset;
        node.error.source = node;
        node.range.end = start + 1;
      }

      if (context.nodeStartsCollection(node)) {
        if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {
          node.error = new PlainValue.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');
        }

        const collection = new Collection(node);
        offset = collection.parse(new ParseContext(context), offset);
        collection.range = new PlainValue.Range(start, offset);
        return collection;
      }

      return node;
    });

    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
    this.indent = indent != null ? indent : orig.indent;
    this.lineStart = lineStart != null ? lineStart : orig.lineStart;
    this.parent = parent != null ? parent : orig.parent || {};
    this.root = orig.root;
    this.src = orig.src;
  }

  nodeStartsCollection(node) {
    const {
      inCollection,
      inFlow,
      src
    } = this;
    if (inCollection || inFlow) return false;
    if (node instanceof CollectionItem) return true; // check for implicit key

    let offset = node.range.end;
    if (src[offset] === '\n' || src[offset - 1] === '\n') return false;
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    return src[offset] === ':';
  } // Anchor and tag are before type, which determines the node implementation
  // class; hence this intermediate step.


  parseProps(offset) {
    const {
      inFlow,
      parent,
      src
    } = this;
    const props = [];
    let lineHasProps = false;
    offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);
    let ch = src[offset];

    while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === '\n') {
      if (ch === '\n') {
        const lineStart = offset + 1;
        const inEnd = PlainValue.Node.endOfIndent(src, lineStart);
        const indentDiff = inEnd - (lineStart + this.indent);
        const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;
        if (!PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;
        this.atLineStart = true;
        this.lineStart = lineStart;
        lineHasProps = false;
        offset = inEnd;
      } else if (ch === PlainValue.Char.COMMENT) {
        const end = PlainValue.Node.endOfLine(src, offset + 1);
        props.push(new PlainValue.Range(offset, end));
        offset = end;
      } else {
        let end = PlainValue.Node.endOfIdentifier(src, offset + 1);

        if (ch === PlainValue.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, end + 13))) {
          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather
          // than an empty but 'foo.bar' private-tagged node in a flow collection
          // followed without whitespace by a plain string starting with a year
          // or date divided by something.
          end = PlainValue.Node.endOfIdentifier(src, end + 5);
        }

        props.push(new PlainValue.Range(offset, end));
        lineHasProps = true;
        offset = PlainValue.Node.endOfWhiteSpace(src, end);
      }

      ch = src[offset];
    } // '- &a : b' has an anchor on an empty node


    if (lineHasProps && ch === ':' && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;
    const type = ParseContext.parseType(src, offset, inFlow);
    return {
      props,
      type,
      valueStart: offset
    };
  }
  /**
   * Parses a node from the source
   * @param {ParseContext} overlay
   * @param {number} start - Index of first non-whitespace character for the node
   * @returns {?Node} - null if at a document boundary
   */


}

// Published as 'yaml/parse-cst'
function parse(src) {
  const cr = [];

  if (src.indexOf('\r') !== -1) {
    src = src.replace(/\r\n?/g, (match, offset) => {
      if (match.length > 1) cr.push(offset);
      return '\n';
    });
  }

  const documents = [];
  let offset = 0;

  do {
    const doc = new Document();
    const context = new ParseContext({
      src
    });
    offset = doc.parse(context, offset);
    documents.push(doc);
  } while (offset < src.length);

  documents.setOrigRanges = () => {
    if (cr.length === 0) return false;

    for (let i = 1; i < cr.length; ++i) cr[i] -= i;

    let crOffset = 0;

    for (let i = 0; i < documents.length; ++i) {
      crOffset = documents[i].setOrigRanges(cr, crOffset);
    }

    cr.splice(0, cr.length);
    return true;
  };

  documents.toString = () => documents.join('...\n');

  return documents;
}

exports.parse = parse;


/***/ }),

/***/ 6140:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var PlainValue = __webpack_require__(5215);

function addCommentBefore(str, indent, comment) {
  if (!comment) return str;
  const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`);
  return `#${cc}\n${indent}${str}`;
}
function addComment(str, indent, comment) {
  return !comment ? str : comment.indexOf('\n') === -1 ? `${str} #${comment}` : `${str}\n` + comment.replace(/^/gm, `${indent || ''}#`);
}

class Node {}

function toJSON(value, arg, ctx) {
  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));

  if (value && typeof value.toJSON === 'function') {
    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
    if (anchor) ctx.onCreate = res => {
      anchor.res = res;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (anchor && ctx.onCreate) ctx.onCreate(res);
    return res;
  }

  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);
  return value;
}

class Scalar extends Node {
  constructor(value) {
    super();
    this.value = value;
  }

  toJSON(arg, ctx) {
    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
  }

  toString() {
    return String(this.value);
  }

}

function collectionFromPath(schema, path, value) {
  let v = value;

  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    const o = Number.isInteger(k) && k >= 0 ? [] : {};
    o[k] = v;
    v = o;
  }

  return schema.createNode(v, false);
} // null, undefined, or an empty non-string iterable (e.g. [])


const isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;
class Collection extends Node {
  constructor(schema) {
    super();

    PlainValue._defineProperty(this, "items", []);

    this.schema = schema;
  }

  addIn(path, value) {
    if (isEmptyPath(path)) this.add(value);else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }

  deleteIn([key, ...rest]) {
    if (rest.length === 0) return this.delete(key);
    const node = this.get(key, true);
    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }

  getIn([key, ...rest], keepScalar) {
    const node = this.get(key, true);
    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;
  }

  hasAllNullValues() {
    return this.items.every(node => {
      if (!node || node.type !== 'PAIR') return false;
      const n = node.value;
      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }

  hasIn([key, ...rest]) {
    if (rest.length === 0) return this.has(key);
    const node = this.get(key, true);
    return node instanceof Collection ? node.hasIn(rest) : false;
  }

  setIn([key, ...rest], value) {
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  } // overridden in implementations

  /* istanbul ignore next */


  toJSON() {
    return null;
  }

  toString(ctx, {
    blockItem,
    flowChars,
    isMap,
    itemIndent
  }, onComment, onChompKeep) {
    const {
      indent,
      indentStep,
      stringify
    } = ctx;
    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;
    if (inFlow) itemIndent += indentStep;
    const allNullValues = isMap && this.hasAllNullValues();
    ctx = Object.assign({}, ctx, {
      allNullValues,
      indent: itemIndent,
      inFlow,
      type: null
    });
    let chompKeep = false;
    let hasItemWithNewLine = false;
    const nodes = this.items.reduce((nodes, item, i) => {
      let comment;

      if (item) {
        if (!chompKeep && item.spaceBefore) nodes.push({
          type: 'comment',
          str: ''
        });
        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {
          nodes.push({
            type: 'comment',
            str: `#${line}`
          });
        });
        if (item.comment) comment = item.comment;
        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;
      }

      chompKeep = false;
      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);
      if (inFlow && !hasItemWithNewLine && str.includes('\n')) hasItemWithNewLine = true;
      if (inFlow && i < this.items.length - 1) str += ',';
      str = addComment(str, itemIndent, comment);
      if (chompKeep && (comment || inFlow)) chompKeep = false;
      nodes.push({
        type: 'item',
        str
      });
      return nodes;
    }, []);
    let str;

    if (nodes.length === 0) {
      str = flowChars.start + flowChars.end;
    } else if (inFlow) {
      const {
        start,
        end
      } = flowChars;
      const strings = nodes.map(n => n.str);

      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {
        str = start;

        for (const s of strings) {
          str += s ? `\n${indentStep}${indent}${s}` : '\n';
        }

        str += `\n${indent}${end}`;
      } else {
        str = `${start} ${strings.join(' ')} ${end}`;
      }
    } else {
      const strings = nodes.map(blockItem);
      str = strings.shift();

      for (const s of strings) str += s ? `\n${indent}${s}` : '\n';
    }

    if (this.comment) {
      str += '\n' + this.comment.replace(/^/gm, `${indent}#`);
      if (onComment) onComment();
    } else if (chompKeep && onChompKeep) onChompKeep();

    return str;
  }

}

PlainValue._defineProperty(Collection, "maxFlowStringSingleLineLength", 60);

function asItemIndex(key) {
  let idx = key instanceof Scalar ? key.value : key;
  if (idx && typeof idx === 'string') idx = Number(idx);
  return Number.isInteger(idx) && idx >= 0 ? idx : null;
}

class YAMLSeq extends Collection {
  add(value) {
    this.items.push(value);
  }

  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }

  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') return undefined;
    const it = this.items[idx];
    return !keepScalar && it instanceof Scalar ? it.value : it;
  }

  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === 'number' && idx < this.items.length;
  }

  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);
    this.items[idx] = value;
  }

  toJSON(_, ctx) {
    const seq = [];
    if (ctx && ctx.onCreate) ctx.onCreate(seq);
    let i = 0;

    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));

    return seq;
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);
    return super.toString(ctx, {
      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,
      flowChars: {
        start: '[',
        end: ']'
      },
      isMap: false,
      itemIndent: (ctx.indent || '') + '  '
    }, onComment, onChompKeep);
  }

}

const stringifyKey = (key, jsKey, ctx) => {
  if (jsKey === null) return '';
  if (typeof jsKey !== 'object') return String(jsKey);
  if (key instanceof Node && ctx && ctx.doc) return key.toString({
    anchors: {},
    doc: ctx.doc,
    indent: '',
    indentStep: ctx.indentStep,
    inFlow: true,
    inStringifyKey: true,
    stringify: ctx.stringify
  });
  return JSON.stringify(jsKey);
};

class Pair extends Node {
  constructor(key, value = null) {
    super();
    this.key = key;
    this.value = value;
    this.type = Pair.Type.PAIR;
  }

  get commentBefore() {
    return this.key instanceof Node ? this.key.commentBefore : undefined;
  }

  set commentBefore(cb) {
    if (this.key == null) this.key = new Scalar(null);
    if (this.key instanceof Node) this.key.commentBefore = cb;else {
      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';
      throw new Error(msg);
    }
  }

  addToJSMap(ctx, map) {
    const key = toJSON(this.key, '', ctx);

    if (map instanceof Map) {
      const value = toJSON(this.value, key, ctx);
      map.set(key, value);
    } else if (map instanceof Set) {
      map.add(key);
    } else {
      const stringKey = stringifyKey(this.key, key, ctx);
      map[stringKey] = toJSON(this.value, stringKey, ctx);
    }

    return map;
  }

  toJSON(_, ctx) {
    const pair = ctx && ctx.mapAsMap ? new Map() : {};
    return this.addToJSMap(ctx, pair);
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx || !ctx.doc) return JSON.stringify(this);
    const {
      indent: indentSize,
      indentSeq,
      simpleKeys
    } = ctx.doc.options;
    let {
      key,
      value
    } = this;
    let keyComment = key instanceof Node && key.comment;

    if (simpleKeys) {
      if (keyComment) {
        throw new Error('With simple keys, key nodes cannot have comments');
      }

      if (key instanceof Collection) {
        const msg = 'With simple keys, collection cannot be used as a key value';
        throw new Error(msg);
      }
    }

    const explicitKey = !simpleKeys && (!key || keyComment || key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL);
    const {
      doc,
      indent,
      indentStep,
      stringify
    } = ctx;
    ctx = Object.assign({}, ctx, {
      implicitKey: !explicitKey,
      indent: indent + indentStep
    });
    let chompKeep = false;
    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);
    str = addComment(str, ctx.indent, keyComment);

    if (ctx.allNullValues && !simpleKeys) {
      if (this.comment) {
        str = addComment(str, ctx.indent, this.comment);
        if (onComment) onComment();
      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();

      return ctx.inFlow ? str : `? ${str}`;
    }

    str = explicitKey ? `? ${str}\n${indent}:` : `${str}:`;

    if (this.comment) {
      // expected (but not strictly required) to be a single-line comment
      str = addComment(str, ctx.indent, this.comment);
      if (onComment) onComment();
    }

    let vcb = '';
    let valueComment = null;

    if (value instanceof Node) {
      if (value.spaceBefore) vcb = '\n';

      if (value.commentBefore) {
        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
        vcb += `\n${cs}`;
      }

      valueComment = value.comment;
    } else if (value && typeof value === 'object') {
      value = doc.schema.createNode(value, true);
    }

    ctx.implicitKey = false;
    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;
    chompKeep = false;

    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
      // If indentSeq === false, consider '- ' as part of indentation where possible
      ctx.indent = ctx.indent.substr(2);
    }

    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);
    let ws = ' ';

    if (vcb || this.comment) {
      ws = `${vcb}\n${ctx.indent}`;
    } else if (!explicitKey && value instanceof Collection) {
      const flow = valueStr[0] === '[' || valueStr[0] === '{';
      if (!flow || valueStr.includes('\n')) ws = `\n${ctx.indent}`;
    }

    if (chompKeep && !valueComment && onChompKeep) onChompKeep();
    return addComment(str + ws + valueStr, ctx.indent, valueComment);
  }

}

PlainValue._defineProperty(Pair, "Type", {
  PAIR: 'PAIR',
  MERGE_PAIR: 'MERGE_PAIR'
});

const getAliasCount = (node, anchors) => {
  if (node instanceof Alias) {
    const anchor = anchors.get(node.source);
    return anchor.count * anchor.aliasCount;
  } else if (node instanceof Collection) {
    let count = 0;

    for (const item of node.items) {
      const c = getAliasCount(item, anchors);
      if (c > count) count = c;
    }

    return count;
  } else if (node instanceof Pair) {
    const kc = getAliasCount(node.key, anchors);
    const vc = getAliasCount(node.value, anchors);
    return Math.max(kc, vc);
  }

  return 1;
};

class Alias extends Node {
  static stringify({
    range,
    source
  }, {
    anchors,
    doc,
    implicitKey,
    inStringifyKey
  }) {
    let anchor = Object.keys(anchors).find(a => anchors[a] === source);
    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();
    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;
    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';
    throw new Error(`${msg} [${range}]`);
  }

  constructor(source) {
    super();
    this.source = source;
    this.type = PlainValue.Type.ALIAS;
  }

  set tag(t) {
    throw new Error('Alias nodes cannot have tags');
  }

  toJSON(arg, ctx) {
    if (!ctx) return toJSON(this.source, arg, ctx);
    const {
      anchors,
      maxAliasCount
    } = ctx;
    const anchor = anchors.get(this.source);
    /* istanbul ignore if */

    if (!anchor || anchor.res === undefined) {
      const msg = 'This should not happen: Alias anchor was not resolved?';
      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);
    }

    if (maxAliasCount >= 0) {
      anchor.count += 1;
      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);

      if (anchor.count * anchor.aliasCount > maxAliasCount) {
        const msg = 'Excessive alias count indicates a resource exhaustion attack';
        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);
      }
    }

    return anchor.res;
  } // Only called when stringifying an alias mapping key while constructing
  // Object output.


  toString(ctx) {
    return Alias.stringify(this, ctx);
  }

}

PlainValue._defineProperty(Alias, "default", true);

function findPair(items, key) {
  const k = key instanceof Scalar ? key.value : key;

  for (const it of items) {
    if (it instanceof Pair) {
      if (it.key === key || it.key === k) return it;
      if (it.key && it.key.value === k) return it;
    }
  }

  return undefined;
}
class YAMLMap extends Collection {
  add(pair, overwrite) {
    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);
    const prev = findPair(this.items, pair.key);
    const sortEntries = this.schema && this.schema.sortMapEntries;

    if (prev) {
      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);
    } else if (sortEntries) {
      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);
      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);
    } else {
      this.items.push(pair);
    }
  }

  delete(key) {
    const it = findPair(this.items, key);
    if (!it) return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }

  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node = it && it.value;
    return !keepScalar && node instanceof Scalar ? node.value : node;
  }

  has(key) {
    return !!findPair(this.items, key);
  }

  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param {*} arg ignored
   * @param {*} ctx Conversion context, originally set in Document#toJSON()
   * @param {Class} Type If set, forces the returned collection type
   * @returns {*} Instance of Type, Map, or Object
   */


  toJSON(_, ctx, Type) {
    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
    if (ctx && ctx.onCreate) ctx.onCreate(map);

    for (const item of this.items) item.addToJSMap(ctx, map);

    return map;
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);

    for (const item of this.items) {
      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }

    return super.toString(ctx, {
      blockItem: n => n.str,
      flowChars: {
        start: '{',
        end: '}'
      },
      isMap: true,
      itemIndent: ctx.indent || ''
    }, onComment, onChompKeep);
  }

}

const MERGE_KEY = '<<';
class Merge extends Pair {
  constructor(pair) {
    if (pair instanceof Pair) {
      let seq = pair.value;

      if (!(seq instanceof YAMLSeq)) {
        seq = new YAMLSeq();
        seq.items.push(pair.value);
        seq.range = pair.value.range;
      }

      super(pair.key, seq);
      this.range = pair.range;
    } else {
      super(new Scalar(MERGE_KEY), new YAMLSeq());
    }

    this.type = Pair.Type.MERGE_PAIR;
  } // If the value associated with a merge key is a single mapping node, each of
  // its key/value pairs is inserted into the current mapping, unless the key
  // already exists in it. If the value associated with the merge key is a
  // sequence, then this sequence is expected to contain mapping nodes and each
  // of these nodes is merged in turn according to its order in the sequence.
  // Keys in mapping nodes earlier in the sequence override keys specified in
  // later mapping nodes. -- http://yaml.org/type/merge.html


  addToJSMap(ctx, map) {
    for (const {
      source
    } of this.value.items) {
      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');
      const srcMap = source.toJSON(null, ctx, Map);

      for (const [key, value] of srcMap) {
        if (map instanceof Map) {
          if (!map.has(key)) map.set(key, value);
        } else if (map instanceof Set) {
          map.add(key);
        } else {
          if (!Object.prototype.hasOwnProperty.call(map, key)) map[key] = value;
        }
      }
    }

    return map;
  }

  toString(ctx, onComment) {
    const seq = this.value;
    if (seq.items.length > 1) return super.toString(ctx, onComment);
    this.value = seq.items[0];
    const str = super.toString(ctx, onComment);
    this.value = seq;
    return str;
  }

}

const binaryOptions = {
  defaultType: PlainValue.Type.BLOCK_LITERAL,
  lineWidth: 76
};
const boolOptions = {
  trueStr: 'true',
  falseStr: 'false'
};
const intOptions = {
  asBigInt: false
};
const nullOptions = {
  nullStr: 'null'
};
const strOptions = {
  defaultType: PlainValue.Type.PLAIN,
  doubleQuoted: {
    jsonEncoding: false,
    minMultiLineLength: 40
  },
  fold: {
    lineWidth: 80,
    minContentWidth: 20
  }
};

function resolveScalar(str, tags, scalarFallback) {
  for (const {
    format,
    test,
    resolve
  } of tags) {
    if (test) {
      const match = str.match(test);

      if (match) {
        let res = resolve.apply(null, match);
        if (!(res instanceof Scalar)) res = new Scalar(res);
        if (format) res.format = format;
        return res;
      }
    }
  }

  if (scalarFallback) str = scalarFallback(str);
  return new Scalar(str);
}

const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line
// returns index of last newline in more-indented block

const consumeMoreIndentedLines = (text, i) => {
  let ch = text[i + 1];

  while (ch === ' ' || ch === '\t') {
    do {
      ch = text[i += 1];
    } while (ch && ch !== '\n');

    ch = text[i + 1];
  }

  return i;
};
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 *
 * @param {string} text
 * @param {string} indent
 * @param {string} [mode='flow'] `'block'` prevents more-indented lines
 *   from being folded; `'quoted'` allows for `\` escapes, including escaped
 *   newlines
 * @param {Object} options
 * @param {number} [options.indentAtStart] Accounts for leading contents on
 *   the first line, defaulting to `indent.length`
 * @param {number} [options.lineWidth=80]
 * @param {number} [options.minContentWidth=20] Allow highly indented lines to
 *   stretch the line width
 * @param {function} options.onFold Called once if the text is folded
 * @param {function} options.onFold Called once if any line of text exceeds
 *   lineWidth characters
 */


function foldFlowLines(text, indent, mode, {
  indentAtStart,
  lineWidth = 80,
  minContentWidth = 20,
  onFold,
  onOverflow
}) {
  if (!lineWidth || lineWidth < 0) return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep) return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - (typeof indentAtStart === 'number' ? indentAtStart : indent.length);
  let split = undefined;
  let prev = undefined;
  let overflow = false;
  let i = -1;

  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1) end = i + endStep;
  }

  for (let ch; ch = text[i += 1];) {
    if (mode === FOLD_QUOTED && ch === '\\') {
      switch (text[i + 1]) {
        case 'x':
          i += 3;
          break;

        case 'u':
          i += 5;
          break;

        case 'U':
          i += 9;
          break;

        default:
          i += 1;
      }
    }

    if (ch === '\n') {
      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split = undefined;
    } else {
      if (ch === ' ' && prev && prev !== ' ' && prev !== '\n' && prev !== '\t') {
        // space surrounded by non-space can be replaced with newline + indent
        const next = text[i + 1];
        if (next && next !== ' ' && next !== '\n' && next !== '\t') split = i;
      }

      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = undefined;
        } else if (mode === FOLD_QUOTED) {
          // white-space collected at end may stretch past lineWidth
          while (prev === ' ' || prev === '\t') {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          } // i - 2 accounts for not-dropped last char + newline-escaping \


          folds.push(i - 2);
          escapedFolds[i - 2] = true;
          end = i - 2 + endStep;
          split = undefined;
        } else {
          overflow = true;
        }
      }
    }

    prev = ch;
  }

  if (overflow && onOverflow) onOverflow();
  if (folds.length === 0) return text;
  if (onFold) onFold();
  let res = text.slice(0, folds[0]);

  for (let i = 0; i < folds.length; ++i) {
    const fold = folds[i];
    const end = folds[i + 1] || text.length;
    if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
    res += `\n${indent}${text.slice(fold + 1, end)}`;
  }

  return res;
}

const getFoldOptions = ({
  indentAtStart
}) => indentAtStart ? Object.assign({
  indentAtStart
}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.


const containsDocumentMarker = str => /^(%|---|\.\.\.)/m.test(str);

function lineLengthOverLimit(str, limit) {
  const strLen = str.length;
  if (strLen <= limit) return false;

  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === '\n') {
      if (i - start > limit) return true;
      start = i + 1;
      if (strLen - start <= limit) return false;
    }
  }

  return true;
}

function doubleQuotedString(value, ctx) {
  const {
    implicitKey
  } = ctx;
  const {
    jsonEncoding,
    minMultiLineLength
  } = strOptions.doubleQuoted;
  const json = JSON.stringify(value);
  if (jsonEncoding) return json;
  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
  let str = '';
  let start = 0;

  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
      // space before newline needs to be escaped to not be folded
      str += json.slice(start, i) + '\\ ';
      i += 1;
      start = i;
      ch = '\\';
    }

    if (ch === '\\') switch (json[i + 1]) {
      case 'u':
        {
          str += json.slice(start, i);
          const code = json.substr(i + 2, 4);

          switch (code) {
            case '0000':
              str += '\\0';
              break;

            case '0007':
              str += '\\a';
              break;

            case '000b':
              str += '\\v';
              break;

            case '001b':
              str += '\\e';
              break;

            case '0085':
              str += '\\N';
              break;

            case '00a0':
              str += '\\_';
              break;

            case '2028':
              str += '\\L';
              break;

            case '2029':
              str += '\\P';
              break;

            default:
              if (code.substr(0, 2) === '00') str += '\\x' + code.substr(2);else str += json.substr(i, 6);
          }

          i += 5;
          start = i + 1;
        }
        break;

      case 'n':
        if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
          i += 1;
        } else {
          // folding will eat first newline
          str += json.slice(start, i) + '\n\n';

          while (json[i + 2] === '\\' && json[i + 3] === 'n' && json[i + 4] !== '"') {
            str += '\n';
            i += 2;
          }

          str += indent; // space after newline needs to be escaped to not be folded

          if (json[i + 2] === ' ') str += '\\';
          i += 1;
          start = i + 1;
        }

        break;

      default:
        i += 1;
    }
  }

  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
}

function singleQuotedString(value, ctx) {
  if (ctx.implicitKey) {
    if (/\n/.test(value)) return doubleQuotedString(value, ctx);
  } else {
    // single quoted string can't have leading or trailing whitespace around newline
    if (/[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
  }

  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
}

function blockString({
  comment,
  type,
  value
}, ctx, onComment, onChompKeep) {
  // 1. Block can't end in whitespace unless the last line is non-empty.
  // 2. Strings consisting of only whitespace are best rendered explicitly.
  if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return doubleQuotedString(value, ctx);
  }

  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
  const indentSize = indent ? '2' : '1'; // root is at -1

  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth - indent.length);
  let header = literal ? '|' : '>';
  if (!value) return header + '\n';
  let wsStart = '';
  let wsEnd = '';
  value = value.replace(/[\n\t ]*$/, ws => {
    const n = ws.indexOf('\n');

    if (n === -1) {
      header += '-'; // strip
    } else if (value === ws || n !== ws.length - 1) {
      header += '+'; // keep

      if (onChompKeep) onChompKeep();
    }

    wsEnd = ws.replace(/\n$/, '');
    return '';
  }).replace(/^[\n ]*/, ws => {
    if (ws.indexOf(' ') !== -1) header += indentSize;
    const m = ws.match(/ +$/);

    if (m) {
      wsStart = ws.slice(0, -m[0].length);
      return m[0];
    } else {
      wsStart = ws;
      return '';
    }
  });
  if (wsEnd) wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  if (wsStart) wsStart = wsStart.replace(/\n+/g, `$&${indent}`);

  if (comment) {
    header += ' #' + comment.replace(/ ?[\r\n]+/g, ' ');
    if (onComment) onComment();
  }

  if (!value) return `${header}${indentSize}\n${indent}${wsEnd}`;

  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}\n${indent}${wsStart}${value}${wsEnd}`;
  }

  value = value.replace(/\n+/g, '\n$&').replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent
  .replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);
  return `${header}\n${indent}${body}`;
}

function plainString(item, ctx, onComment, onChompKeep) {
  const {
    comment,
    type,
    value
  } = item;
  const {
    actualString,
    implicitKey,
    indent,
    inFlow
  } = ctx;

  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return doubleQuotedString(value, ctx);
  }

  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    // not allowed:
    // - empty string, '-' or '?'
    // - start with an indicator character (except [?:-]) or /[?-] /
    // - '\n ', ': ' or ' \n' anywhere
    // - '#' not preceded by a non-space char
    // - end with ' ' or ':'
    return implicitKey || inFlow || value.indexOf('\n') === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }

  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\n') !== -1) {
    // Where allowed & type not set explicitly, prefer block style for multiline strings
    return blockString(item, ctx, onComment, onChompKeep);
  }

  if (indent === '' && containsDocumentMarker(value)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }

  const str = value.replace(/\n+/g, `$&\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and
  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
  // and others in v1.1.

  if (actualString) {
    const {
      tags
    } = ctx.doc.schema;
    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;
    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);
  }

  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));

  if (comment && !inFlow && (body.indexOf('\n') !== -1 || comment.indexOf('\n') !== -1)) {
    if (onComment) onComment();
    return addCommentBefore(body, indent, comment);
  }

  return body;
}

function stringifyString(item, ctx, onComment, onChompKeep) {
  const {
    defaultType
  } = strOptions;
  const {
    implicitKey,
    inFlow
  } = ctx;
  let {
    type,
    value
  } = item;

  if (typeof value !== 'string') {
    value = String(value);
    item = Object.assign({}, item, {
      value
    });
  }

  const _stringify = _type => {
    switch (_type) {
      case PlainValue.Type.BLOCK_FOLDED:
      case PlainValue.Type.BLOCK_LITERAL:
        return blockString(item, ctx, onComment, onChompKeep);

      case PlainValue.Type.QUOTE_DOUBLE:
        return doubleQuotedString(value, ctx);

      case PlainValue.Type.QUOTE_SINGLE:
        return singleQuotedString(value, ctx);

      case PlainValue.Type.PLAIN:
        return plainString(item, ctx, onComment, onChompKeep);

      default:
        return null;
    }
  };

  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
    // force double quotes on control characters
    type = PlainValue.Type.QUOTE_DOUBLE;
  } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {
    // should not happen; blocks are not valid inside flow containers
    type = PlainValue.Type.QUOTE_DOUBLE;
  }

  let res = _stringify(type);

  if (res === null) {
    res = _stringify(defaultType);
    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);
  }

  return res;
}

function stringifyNumber({
  format,
  minFractionDigits,
  tag,
  value
}) {
  if (typeof value === 'bigint') return String(value);
  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';
  let n = JSON.stringify(value);

  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\d/.test(n)) {
    let i = n.indexOf('.');

    if (i < 0) {
      i = n.length;
      n += '.';
    }

    let d = minFractionDigits - (n.length - i - 1);

    while (d-- > 0) n += '0';
  }

  return n;
}

function checkFlowCollectionEnd(errors, cst) {
  let char, name;

  switch (cst.type) {
    case PlainValue.Type.FLOW_MAP:
      char = '}';
      name = 'flow map';
      break;

    case PlainValue.Type.FLOW_SEQ:
      char = ']';
      name = 'flow sequence';
      break;

    default:
      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));
      return;
  }

  let lastItem;

  for (let i = cst.items.length - 1; i >= 0; --i) {
    const item = cst.items[i];

    if (!item || item.type !== PlainValue.Type.COMMENT) {
      lastItem = item;
      break;
    }
  }

  if (lastItem && lastItem.char !== char) {
    const msg = `Expected ${name} to end with ${char}`;
    let err;

    if (typeof lastItem.offset === 'number') {
      err = new PlainValue.YAMLSemanticError(cst, msg);
      err.offset = lastItem.offset + 1;
    } else {
      err = new PlainValue.YAMLSemanticError(lastItem, msg);
      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;
    }

    errors.push(err);
  }
}
function checkFlowCommentSpace(errors, comment) {
  const prev = comment.context.src[comment.range.start - 1];

  if (prev !== '\n' && prev !== '\t' && prev !== ' ') {
    const msg = 'Comments must be separated from other tokens by white space characters';
    errors.push(new PlainValue.YAMLSemanticError(comment, msg));
  }
}
function getLongKeyError(source, key) {
  const sk = String(key);
  const k = sk.substr(0, 8) + '...' + sk.substr(-8);
  return new PlainValue.YAMLSemanticError(source, `The "${k}" key is too long`);
}
function resolveComments(collection, comments) {
  for (const {
    afterKey,
    before,
    comment
  } of comments) {
    let item = collection.items[before];

    if (!item) {
      if (comment !== undefined) {
        if (collection.comment) collection.comment += '\n' + comment;else collection.comment = comment;
      }
    } else {
      if (afterKey && item.value) item = item.value;

      if (comment === undefined) {
        if (afterKey || !item.commentBefore) item.spaceBefore = true;
      } else {
        if (item.commentBefore) item.commentBefore += '\n' + comment;else item.commentBefore = comment;
      }
    }
  }
}

// on error, will return { str: string, errors: Error[] }
function resolveString(doc, node) {
  const res = node.strValue;
  if (!res) return '';
  if (typeof res === 'string') return res;
  res.errors.forEach(error => {
    if (!error.source) error.source = node;
    doc.errors.push(error);
  });
  return res.str;
}

function resolveTagHandle(doc, node) {
  const {
    handle,
    suffix
  } = node.tag;
  let prefix = doc.tagPrefixes.find(p => p.handle === handle);

  if (!prefix) {
    const dtp = doc.getDefaults().tagPrefixes;
    if (dtp) prefix = dtp.find(p => p.handle === handle);
    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);
  }

  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);

  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {
    if (suffix[0] === '^') {
      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));
      return suffix;
    }

    if (/[:/]/.test(suffix)) {
      // word/foo -> tag:word.yaml.org,2002:foo
      const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
    }
  }

  return prefix.prefix + decodeURIComponent(suffix);
}

function resolveTagName(doc, node) {
  const {
    tag,
    type
  } = node;
  let nonSpecific = false;

  if (tag) {
    const {
      handle,
      suffix,
      verbatim
    } = tag;

    if (verbatim) {
      if (verbatim !== '!' && verbatim !== '!!') return verbatim;
      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
    } else if (handle === '!' && !suffix) {
      nonSpecific = true;
    } else {
      try {
        return resolveTagHandle(doc, node);
      } catch (error) {
        doc.errors.push(error);
      }
    }
  }

  switch (type) {
    case PlainValue.Type.BLOCK_FOLDED:
    case PlainValue.Type.BLOCK_LITERAL:
    case PlainValue.Type.QUOTE_DOUBLE:
    case PlainValue.Type.QUOTE_SINGLE:
      return PlainValue.defaultTags.STR;

    case PlainValue.Type.FLOW_MAP:
    case PlainValue.Type.MAP:
      return PlainValue.defaultTags.MAP;

    case PlainValue.Type.FLOW_SEQ:
    case PlainValue.Type.SEQ:
      return PlainValue.defaultTags.SEQ;

    case PlainValue.Type.PLAIN:
      return nonSpecific ? PlainValue.defaultTags.STR : null;

    default:
      return null;
  }
}

function resolveByTagName(doc, node, tagName) {
  const {
    tags
  } = doc.schema;
  const matchWithTest = [];

  for (const tag of tags) {
    if (tag.tag === tagName) {
      if (tag.test) matchWithTest.push(tag);else {
        const res = tag.resolve(doc, node);
        return res instanceof Collection ? res : new Scalar(res);
      }
    }
  }

  const str = resolveString(doc, node);
  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);
  return null;
}

function getFallbackTagName({
  type
}) {
  switch (type) {
    case PlainValue.Type.FLOW_MAP:
    case PlainValue.Type.MAP:
      return PlainValue.defaultTags.MAP;

    case PlainValue.Type.FLOW_SEQ:
    case PlainValue.Type.SEQ:
      return PlainValue.defaultTags.SEQ;

    default:
      return PlainValue.defaultTags.STR;
  }
}

function resolveTag(doc, node, tagName) {
  try {
    const res = resolveByTagName(doc, node, tagName);

    if (res) {
      if (tagName && node.tag) res.tag = tagName;
      return res;
    }
  } catch (error) {
    /* istanbul ignore if */
    if (!error.source) error.source = node;
    doc.errors.push(error);
    return null;
  }

  try {
    const fallback = getFallbackTagName(node);
    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);
    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;
    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));
    const res = resolveByTagName(doc, node, fallback);
    res.tag = tagName;
    return res;
  } catch (error) {
    const refError = new PlainValue.YAMLReferenceError(node, error.message);
    refError.stack = error.stack;
    doc.errors.push(refError);
    return null;
  }
}

const isCollectionItem = node => {
  if (!node) return false;
  const {
    type
  } = node;
  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;
};

function resolveNodeProps(errors, node) {
  const comments = {
    before: [],
    after: []
  };
  let hasAnchor = false;
  let hasTag = false;
  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;

  for (const {
    start,
    end
  } of props) {
    switch (node.context.src[start]) {
      case PlainValue.Char.COMMENT:
        {
          if (!node.commentHasRequiredWhitespace(start)) {
            const msg = 'Comments must be separated from other tokens by white space characters';
            errors.push(new PlainValue.YAMLSemanticError(node, msg));
          }

          const {
            header,
            valueRange
          } = node;
          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
          cc.push(node.context.src.slice(start + 1, end));
          break;
        }
      // Actual anchor & tag resolution is handled by schema, here we just complain

      case PlainValue.Char.ANCHOR:
        if (hasAnchor) {
          const msg = 'A node can have at most one anchor';
          errors.push(new PlainValue.YAMLSemanticError(node, msg));
        }

        hasAnchor = true;
        break;

      case PlainValue.Char.TAG:
        if (hasTag) {
          const msg = 'A node can have at most one tag';
          errors.push(new PlainValue.YAMLSemanticError(node, msg));
        }

        hasTag = true;
        break;
    }
  }

  return {
    comments,
    hasAnchor,
    hasTag
  };
}

function resolveNodeValue(doc, node) {
  const {
    anchors,
    errors,
    schema
  } = doc;

  if (node.type === PlainValue.Type.ALIAS) {
    const name = node.rawValue;
    const src = anchors.getNode(name);

    if (!src) {
      const msg = `Aliased anchor not found: ${name}`;
      errors.push(new PlainValue.YAMLReferenceError(node, msg));
      return null;
    } // Lazy resolution for circular references


    const res = new Alias(src);

    anchors._cstAliases.push(res);

    return res;
  }

  const tagName = resolveTagName(doc, node);
  if (tagName) return resolveTag(doc, node, tagName);

  if (node.type !== PlainValue.Type.PLAIN) {
    const msg = `Failed to resolve ${node.type} node here`;
    errors.push(new PlainValue.YAMLSyntaxError(node, msg));
    return null;
  }

  try {
    const str = resolveString(doc, node);
    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
  } catch (error) {
    if (!error.source) error.source = node;
    errors.push(error);
    return null;
  }
} // sets node.resolved on success


function resolveNode(doc, node) {
  if (!node) return null;
  if (node.error) doc.errors.push(node.error);
  const {
    comments,
    hasAnchor,
    hasTag
  } = resolveNodeProps(doc.errors, node);

  if (hasAnchor) {
    const {
      anchors
    } = doc;
    const name = node.anchor;
    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor
    // name have already been resolved, so it may safely be renamed.

    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as
    // anchors need to be available during resolution to allow for
    // circular references.

    anchors.map[name] = node;
  }

  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {
    const msg = 'An alias node must not specify any properties';
    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
  }

  const res = resolveNodeValue(doc, node);

  if (res) {
    res.range = [node.range.start, node.range.end];
    if (doc.options.keepCstNodes) res.cstNode = node;
    if (doc.options.keepNodeTypes) res.type = node.type;
    const cb = comments.before.join('\n');

    if (cb) {
      res.commentBefore = res.commentBefore ? `${res.commentBefore}\n${cb}` : cb;
    }

    const ca = comments.after.join('\n');
    if (ca) res.comment = res.comment ? `${res.comment}\n${ca}` : ca;
  }

  return node.resolved = res;
}

function resolveMap(doc, cst) {
  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {
    const msg = `A ${cst.type} node cannot be resolved as a mapping`;
    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
    return null;
  }

  const {
    comments,
    items
  } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
  const map = new YAMLMap();
  map.items = items;
  resolveComments(map, comments);
  let hasCollectionKey = false;

  for (let i = 0; i < items.length; ++i) {
    const {
      key: iKey
    } = items[i];
    if (iKey instanceof Collection) hasCollectionKey = true;

    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
      items[i] = new Merge(items[i]);
      const sources = items[i].value.items;
      let error = null;
      sources.some(node => {
        if (node instanceof Alias) {
          // During parsing, alias sources are CST nodes; to account for
          // circular references their resolved values can't be used here.
          const {
            type
          } = node.source;
          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;
          return error = 'Merge nodes aliases can only point to maps';
        }

        return error = 'Merge nodes can only have Alias nodes as values';
      });
      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));
    } else {
      for (let j = i + 1; j < items.length; ++j) {
        const {
          key: jKey
        } = items[j];

        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {
          const msg = `Map keys must be unique; "${iKey}" is repeated`;
          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));
          break;
        }
      }
    }
  }

  if (hasCollectionKey && !doc.options.mapAsMap) {
    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
  }

  cst.resolved = map;
  return map;
}

const valueHasPairComment = ({
  context: {
    lineStart,
    node,
    src
  },
  props
}) => {
  if (props.length === 0) return false;
  const {
    start
  } = props[0];
  if (node && start > node.valueRange.start) return false;
  if (src[start] !== PlainValue.Char.COMMENT) return false;

  for (let i = lineStart; i < start; ++i) if (src[i] === '\n') return false;

  return true;
};

function resolvePairComment(item, pair) {
  if (!valueHasPairComment(item)) return;
  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);
  let found = false;
  const cb = pair.value.commentBefore;

  if (cb && cb.startsWith(comment)) {
    pair.value.commentBefore = cb.substr(comment.length + 1);
    found = true;
  } else {
    const cc = pair.value.comment;

    if (!item.node && cc && cc.startsWith(comment)) {
      pair.value.comment = cc.substr(comment.length + 1);
      found = true;
    }
  }

  if (found) pair.comment = comment;
}

function resolveBlockMapItems(doc, cst) {
  const comments = [];
  const items = [];
  let key = undefined;
  let keyStart = null;

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    switch (item.type) {
      case PlainValue.Type.BLANK_LINE:
        comments.push({
          afterKey: !!key,
          before: items.length
        });
        break;

      case PlainValue.Type.COMMENT:
        comments.push({
          afterKey: !!key,
          before: items.length,
          comment: item.comment
        });
        break;

      case PlainValue.Type.MAP_KEY:
        if (key !== undefined) items.push(new Pair(key));
        if (item.error) doc.errors.push(item.error);
        key = resolveNode(doc, item.node);
        keyStart = null;
        break;

      case PlainValue.Type.MAP_VALUE:
        {
          if (key === undefined) key = null;
          if (item.error) doc.errors.push(item.error);

          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {
            const msg = 'Nested mappings are not allowed in compact mappings';
            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));
          }

          let valueNode = item.node;

          if (!valueNode && item.props.length > 0) {
            // Comments on an empty mapping value need to be preserved, so we
            // need to construct a minimal empty node here to use instead of the
            // missing `item.node`. -- eemeli/yaml#19
            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);
            valueNode.context = {
              parent: item,
              src: item.context.src
            };
            const pos = item.range.start + 1;
            valueNode.range = {
              start: pos,
              end: pos
            };
            valueNode.valueRange = {
              start: pos,
              end: pos
            };

            if (typeof item.range.origStart === 'number') {
              const origPos = item.range.origStart + 1;
              valueNode.range.origStart = valueNode.range.origEnd = origPos;
              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
            }
          }

          const pair = new Pair(key, resolveNode(doc, valueNode));
          resolvePairComment(item, pair);
          items.push(pair);

          if (key && typeof keyStart === 'number') {
            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
          }

          key = undefined;
          keyStart = null;
        }
        break;

      default:
        if (key !== undefined) items.push(new Pair(key));
        key = resolveNode(doc, item);
        keyStart = item.range.start;
        if (item.error) doc.errors.push(item.error);

        next: for (let j = i + 1;; ++j) {
          const nextItem = cst.items[j];

          switch (nextItem && nextItem.type) {
            case PlainValue.Type.BLANK_LINE:
            case PlainValue.Type.COMMENT:
              continue next;

            case PlainValue.Type.MAP_VALUE:
              break next;

            default:
              {
                const msg = 'Implicit map keys need to be followed by map values';
                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                break next;
              }
          }
        }

        if (item.valueRangeContainsNewline) {
          const msg = 'Implicit map keys need to be on a single line';
          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
        }

    }
  }

  if (key !== undefined) items.push(new Pair(key));
  return {
    comments,
    items
  };
}

function resolveFlowMapItems(doc, cst) {
  const comments = [];
  const items = [];
  let key = undefined;
  let explicitKey = false;
  let next = '{';

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    if (typeof item.char === 'string') {
      const {
        char,
        offset
      } = item;

      if (char === '?' && key === undefined && !explicitKey) {
        explicitKey = true;
        next = ':';
        continue;
      }

      if (char === ':') {
        if (key === undefined) key = null;

        if (next === ':') {
          next = ',';
          continue;
        }
      } else {
        if (explicitKey) {
          if (key === undefined && char !== ',') key = null;
          explicitKey = false;
        }

        if (key !== undefined) {
          items.push(new Pair(key));
          key = undefined;

          if (char === ',') {
            next = ':';
            continue;
          }
        }
      }

      if (char === '}') {
        if (i === cst.items.length - 1) continue;
      } else if (char === next) {
        next = ':';
        continue;
      }

      const msg = `Flow map contains an unexpected ${char}`;
      const err = new PlainValue.YAMLSyntaxError(cst, msg);
      err.offset = offset;
      doc.errors.push(err);
    } else if (item.type === PlainValue.Type.BLANK_LINE) {
      comments.push({
        afterKey: !!key,
        before: items.length
      });
    } else if (item.type === PlainValue.Type.COMMENT) {
      checkFlowCommentSpace(doc.errors, item);
      comments.push({
        afterKey: !!key,
        before: items.length,
        comment: item.comment
      });
    } else if (key === undefined) {
      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));
      key = resolveNode(doc, item);
    } else {
      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));
      items.push(new Pair(key, resolveNode(doc, item)));
      key = undefined;
      explicitKey = false;
    }
  }

  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== undefined) items.push(new Pair(key));
  return {
    comments,
    items
  };
}

function resolveSeq(doc, cst) {
  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {
    const msg = `A ${cst.type} node cannot be resolved as a sequence`;
    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
    return null;
  }

  const {
    comments,
    items
  } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
  const seq = new YAMLSeq();
  seq.items = items;
  resolveComments(seq, comments);

  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) {
    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
  }

  cst.resolved = seq;
  return seq;
}

function resolveBlockSeqItems(doc, cst) {
  const comments = [];
  const items = [];

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    switch (item.type) {
      case PlainValue.Type.BLANK_LINE:
        comments.push({
          before: items.length
        });
        break;

      case PlainValue.Type.COMMENT:
        comments.push({
          comment: item.comment,
          before: items.length
        });
        break;

      case PlainValue.Type.SEQ_ITEM:
        if (item.error) doc.errors.push(item.error);
        items.push(resolveNode(doc, item.node));

        if (item.hasProps) {
          const msg = 'Sequence items cannot have tags or anchors before the - indicator';
          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
        }

        break;

      default:
        if (item.error) doc.errors.push(item.error);
        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
    }
  }

  return {
    comments,
    items
  };
}

function resolveFlowSeqItems(doc, cst) {
  const comments = [];
  const items = [];
  let explicitKey = false;
  let key = undefined;
  let keyStart = null;
  let next = '[';
  let prevItem = null;

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    if (typeof item.char === 'string') {
      const {
        char,
        offset
      } = item;

      if (char !== ':' && (explicitKey || key !== undefined)) {
        if (explicitKey && key === undefined) key = next ? items.pop() : null;
        items.push(new Pair(key));
        explicitKey = false;
        key = undefined;
        keyStart = null;
      }

      if (char === next) {
        next = null;
      } else if (!next && char === '?') {
        explicitKey = true;
      } else if (next !== '[' && char === ':' && key === undefined) {
        if (next === ',') {
          key = items.pop();

          if (key instanceof Pair) {
            const msg = 'Chaining flow sequence pairs is invalid';
            const err = new PlainValue.YAMLSemanticError(cst, msg);
            err.offset = offset;
            doc.errors.push(err);
          }

          if (!explicitKey && typeof keyStart === 'number') {
            const keyEnd = item.range ? item.range.start : item.offset;
            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
            const {
              src
            } = prevItem.context;

            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\n') {
              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';
              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));
              break;
            }
          }
        } else {
          key = null;
        }

        keyStart = null;
        explicitKey = false;
        next = null;
      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {
        const msg = `Flow sequence contains an unexpected ${char}`;
        const err = new PlainValue.YAMLSyntaxError(cst, msg);
        err.offset = offset;
        doc.errors.push(err);
      }
    } else if (item.type === PlainValue.Type.BLANK_LINE) {
      comments.push({
        before: items.length
      });
    } else if (item.type === PlainValue.Type.COMMENT) {
      checkFlowCommentSpace(doc.errors, item);
      comments.push({
        comment: item.comment,
        before: items.length
      });
    } else {
      if (next) {
        const msg = `Expected a ${next} in flow sequence`;
        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
      }

      const value = resolveNode(doc, item);

      if (key === undefined) {
        items.push(value);
        prevItem = item;
      } else {
        items.push(new Pair(key, value));
        key = undefined;
      }

      keyStart = item.range.start;
      next = ',';
    }
  }

  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== undefined) items.push(new Pair(key));
  return {
    comments,
    items
  };
}

exports.Alias = Alias;
exports.Collection = Collection;
exports.Merge = Merge;
exports.Node = Node;
exports.Pair = Pair;
exports.Scalar = Scalar;
exports.YAMLMap = YAMLMap;
exports.YAMLSeq = YAMLSeq;
exports.addComment = addComment;
exports.binaryOptions = binaryOptions;
exports.boolOptions = boolOptions;
exports.findPair = findPair;
exports.intOptions = intOptions;
exports.isEmptyPath = isEmptyPath;
exports.nullOptions = nullOptions;
exports.resolveMap = resolveMap;
exports.resolveNode = resolveNode;
exports.resolveSeq = resolveSeq;
exports.resolveString = resolveString;
exports.strOptions = strOptions;
exports.stringifyNumber = stringifyNumber;
exports.stringifyString = stringifyString;
exports.toJSON = toJSON;


/***/ }),

/***/ 7383:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var PlainValue = __webpack_require__(5215);
var resolveSeq = __webpack_require__(6140);

/* global atob, btoa, Buffer */
const binary = {
  identify: value => value instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: 'tag:yaml.org,2002:binary',

  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve: (doc, node) => {
    const src = resolveSeq.resolveString(doc, node);

    if (typeof Buffer === 'function') {
      return Buffer.from(src, 'base64');
    } else if (typeof atob === 'function') {
      // On IE 11, atob() can't handle newlines
      const str = atob(src.replace(/[\n\r]/g, ''));
      const buffer = new Uint8Array(str.length);

      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);

      return buffer;
    } else {
      const msg = 'This environment does not support reading binary tags; either Buffer or atob is required';
      doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));
      return null;
    }
  },
  options: resolveSeq.binaryOptions,
  stringify: ({
    comment,
    type,
    value
  }, ctx, onComment, onChompKeep) => {
    let src;

    if (typeof Buffer === 'function') {
      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');
    } else if (typeof btoa === 'function') {
      let s = '';

      for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);

      src = btoa(s);
    } else {
      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
    }

    if (!type) type = resolveSeq.binaryOptions.defaultType;

    if (type === PlainValue.Type.QUOTE_DOUBLE) {
      value = src;
    } else {
      const {
        lineWidth
      } = resolveSeq.binaryOptions;
      const n = Math.ceil(src.length / lineWidth);
      const lines = new Array(n);

      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = src.substr(o, lineWidth);
      }

      value = lines.join(type === PlainValue.Type.BLOCK_LITERAL ? '\n' : ' ');
    }

    return resolveSeq.stringifyString({
      comment,
      type,
      value
    }, ctx, onComment, onChompKeep);
  }
};

function parsePairs(doc, cst) {
  const seq = resolveSeq.resolveSeq(doc, cst);

  for (let i = 0; i < seq.items.length; ++i) {
    let item = seq.items[i];
    if (item instanceof resolveSeq.Pair) continue;else if (item instanceof resolveSeq.YAMLMap) {
      if (item.items.length > 1) {
        const msg = 'Each pair must have its own sequence indicator';
        throw new PlainValue.YAMLSemanticError(cst, msg);
      }

      const pair = item.items[0] || new resolveSeq.Pair();
      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}\n${pair.commentBefore}` : item.commentBefore;
      if (item.comment) pair.comment = pair.comment ? `${item.comment}\n${pair.comment}` : item.comment;
      item = pair;
    }
    seq.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);
  }

  return seq;
}
function createPairs(schema, iterable, ctx) {
  const pairs = new resolveSeq.YAMLSeq(schema);
  pairs.tag = 'tag:yaml.org,2002:pairs';

  for (const it of iterable) {
    let key, value;

    if (Array.isArray(it)) {
      if (it.length === 2) {
        key = it[0];
        value = it[1];
      } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
    } else if (it && it instanceof Object) {
      const keys = Object.keys(it);

      if (keys.length === 1) {
        key = keys[0];
        value = it[key];
      } else throw new TypeError(`Expected { key: value } tuple: ${it}`);
    } else {
      key = it;
    }

    const pair = schema.createPair(key, value, ctx);
    pairs.items.push(pair);
  }

  return pairs;
}
const pairs = {
  default: false,
  tag: 'tag:yaml.org,2002:pairs',
  resolve: parsePairs,
  createNode: createPairs
};

class YAMLOMap extends resolveSeq.YAMLSeq {
  constructor() {
    super();

    PlainValue._defineProperty(this, "add", resolveSeq.YAMLMap.prototype.add.bind(this));

    PlainValue._defineProperty(this, "delete", resolveSeq.YAMLMap.prototype.delete.bind(this));

    PlainValue._defineProperty(this, "get", resolveSeq.YAMLMap.prototype.get.bind(this));

    PlainValue._defineProperty(this, "has", resolveSeq.YAMLMap.prototype.has.bind(this));

    PlainValue._defineProperty(this, "set", resolveSeq.YAMLMap.prototype.set.bind(this));

    this.tag = YAMLOMap.tag;
  }

  toJSON(_, ctx) {
    const map = new Map();
    if (ctx && ctx.onCreate) ctx.onCreate(map);

    for (const pair of this.items) {
      let key, value;

      if (pair instanceof resolveSeq.Pair) {
        key = resolveSeq.toJSON(pair.key, '', ctx);
        value = resolveSeq.toJSON(pair.value, key, ctx);
      } else {
        key = resolveSeq.toJSON(pair, '', ctx);
      }

      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');
      map.set(key, value);
    }

    return map;
  }

}

PlainValue._defineProperty(YAMLOMap, "tag", 'tag:yaml.org,2002:omap');

function parseOMap(doc, cst) {
  const pairs = parsePairs(doc, cst);
  const seenKeys = [];

  for (const {
    key
  } of pairs.items) {
    if (key instanceof resolveSeq.Scalar) {
      if (seenKeys.includes(key.value)) {
        const msg = 'Ordered maps must not include duplicate keys';
        throw new PlainValue.YAMLSemanticError(cst, msg);
      } else {
        seenKeys.push(key.value);
      }
    }
  }

  return Object.assign(new YAMLOMap(), pairs);
}

function createOMap(schema, iterable, ctx) {
  const pairs = createPairs(schema, iterable, ctx);
  const omap = new YAMLOMap();
  omap.items = pairs.items;
  return omap;
}

const omap = {
  identify: value => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: 'tag:yaml.org,2002:omap',
  resolve: parseOMap,
  createNode: createOMap
};

class YAMLSet extends resolveSeq.YAMLMap {
  constructor() {
    super();
    this.tag = YAMLSet.tag;
  }

  add(key) {
    const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);
    const prev = resolveSeq.findPair(this.items, pair.key);
    if (!prev) this.items.push(pair);
  }

  get(key, keepPair) {
    const pair = resolveSeq.findPair(this.items, key);
    return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;
  }

  set(key, value) {
    if (typeof value !== 'boolean') throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = resolveSeq.findPair(this.items, key);

    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new resolveSeq.Pair(key));
    }
  }

  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);
    if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');
  }

}

PlainValue._defineProperty(YAMLSet, "tag", 'tag:yaml.org,2002:set');

function parseSet(doc, cst) {
  const map = resolveSeq.resolveMap(doc, cst);
  if (!map.hasAllNullValues()) throw new PlainValue.YAMLSemanticError(cst, 'Set items must all have null values');
  return Object.assign(new YAMLSet(), map);
}

function createSet(schema, iterable, ctx) {
  const set = new YAMLSet();

  for (const value of iterable) set.items.push(schema.createPair(value, null, ctx));

  return set;
}

const set = {
  identify: value => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: 'tag:yaml.org,2002:set',
  resolve: parseSet,
  createNode: createSet
};

const parseSexagesimal = (sign, parts) => {
  const n = parts.split(':').reduce((n, p) => n * 60 + Number(p), 0);
  return sign === '-' ? -n : n;
}; // hhhh:mm:ss.sss


const stringifySexagesimal = ({
  value
}) => {
  if (isNaN(value) || !isFinite(value)) return resolveSeq.stringifyNumber(value);
  let sign = '';

  if (value < 0) {
    sign = '-';
    value = Math.abs(value);
  }

  const parts = [value % 60]; // seconds, including ms

  if (value < 60) {
    parts.unshift(0); // at least one : is required
  } else {
    value = Math.round((value - parts[0]) / 60);
    parts.unshift(value % 60); // minutes

    if (value >= 60) {
      value = Math.round((value - parts[0]) / 60);
      parts.unshift(value); // hours
    }
  }

  return sign + parts.map(n => n < 10 ? '0' + String(n) : String(n)).join(':').replace(/000000\d*$/, '') // % 60 may introduce error
  ;
};

const intTime = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'TIME',
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),
  stringify: stringifySexagesimal
};
const floatTime = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'TIME',
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),
  stringify: stringifySexagesimal
};
const timestamp = {
  identify: value => value instanceof Date,
  default: true,
  tag: 'tag:yaml.org,2002:timestamp',
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
  '(?:(?:t|T|[ \\t]+)' + // t | T | whitespace
  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
  '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
  ')?' + ')$'),
  resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {
    if (millisec) millisec = (millisec + '00').substr(1, 3);
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);

    if (tz && tz !== 'Z') {
      let d = parseSexagesimal(tz[0], tz.slice(1));
      if (Math.abs(d) < 30) d *= 60;
      date -= 60000 * d;
    }

    return new Date(date);
  },
  stringify: ({
    value
  }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '')
};

/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */
function shouldWarn(deprecation) {
  const env = typeof process !== 'undefined' && process.env || {};

  if (deprecation) {
    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;
    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
  }

  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;
  return !env.YAML_SILENCE_WARNINGS;
}

function warn(warning, type) {
  if (shouldWarn(false)) {
    const emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to
    // https://github.com/facebook/jest/issues/2549

    if (emit) emit(warning, type);else {
      // eslint-disable-next-line no-console
      console.warn(type ? `${type}: ${warning}` : warning);
    }
  }
}
function warnFileDeprecation(filename) {
  if (shouldWarn(true)) {
    const path = filename.replace(/.*yaml[/\\]/i, '').replace(/\.js$/, '').replace(/\\/g, '/');
    warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, 'DeprecationWarning');
  }
}
const warned = {};
function warnOptionDeprecation(name, alternative) {
  if (!warned[name] && shouldWarn(true)) {
    warned[name] = true;
    let msg = `The option '${name}' will be removed in a future release`;
    msg += alternative ? `, use '${alternative}' instead.` : '.';
    warn(msg, 'DeprecationWarning');
  }
}

exports.binary = binary;
exports.floatTime = floatTime;
exports.intTime = intTime;
exports.omap = omap;
exports.pairs = pairs;
exports.set = set;
exports.timestamp = timestamp;
exports.warn = warn;
exports.warnFileDeprecation = warnFileDeprecation;
exports.warnOptionDeprecation = warnOptionDeprecation;


/***/ }),

/***/ 3552:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(5065).YAML


/***/ }),

/***/ 1067:
/***/ ((module) => {

"use strict";


module.exports = factory

var noop = Function.prototype
var own = {}.hasOwnProperty

// Handle values based on a property.
function factory(key, options) {
  var settings = options || {}

  function one(value) {
    var fn = one.invalid
    var handlers = one.handlers

    if (value && own.call(value, key)) {
      fn = own.call(handlers, value[key]) ? handlers[value[key]] : one.unknown
    }

    return (fn || noop).apply(this, arguments)
  }

  one.handlers = settings.handlers || {}
  one.invalid = settings.invalid
  one.unknown = settings.unknown

  return one
}


/***/ }),

/***/ 2877:
/***/ ((module) => {

module.exports = eval("require")("encoding");


/***/ }),

/***/ 3407:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("{\"AEli\":\"Æ\",\"AElig\":\"Æ\",\"AM\":\"&\",\"AMP\":\"&\",\"Aacut\":\"Á\",\"Aacute\":\"Á\",\"Abreve\":\"Ă\",\"Acir\":\"Â\",\"Acirc\":\"Â\",\"Acy\":\"А\",\"Afr\":\"𝔄\",\"Agrav\":\"À\",\"Agrave\":\"À\",\"Alpha\":\"Α\",\"Amacr\":\"Ā\",\"And\":\"⩓\",\"Aogon\":\"Ą\",\"Aopf\":\"𝔸\",\"ApplyFunction\":\"⁡\",\"Arin\":\"Å\",\"Aring\":\"Å\",\"Ascr\":\"𝒜\",\"Assign\":\"≔\",\"Atild\":\"Ã\",\"Atilde\":\"Ã\",\"Aum\":\"Ä\",\"Auml\":\"Ä\",\"Backslash\":\"∖\",\"Barv\":\"⫧\",\"Barwed\":\"⌆\",\"Bcy\":\"Б\",\"Because\":\"∵\",\"Bernoullis\":\"ℬ\",\"Beta\":\"Β\",\"Bfr\":\"𝔅\",\"Bopf\":\"𝔹\",\"Breve\":\"˘\",\"Bscr\":\"ℬ\",\"Bumpeq\":\"≎\",\"CHcy\":\"Ч\",\"COP\":\"©\",\"COPY\":\"©\",\"Cacute\":\"Ć\",\"Cap\":\"⋒\",\"CapitalDifferentialD\":\"ⅅ\",\"Cayleys\":\"ℭ\",\"Ccaron\":\"Č\",\"Ccedi\":\"Ç\",\"Ccedil\":\"Ç\",\"Ccirc\":\"Ĉ\",\"Cconint\":\"∰\",\"Cdot\":\"Ċ\",\"Cedilla\":\"¸\",\"CenterDot\":\"·\",\"Cfr\":\"ℭ\",\"Chi\":\"Χ\",\"CircleDot\":\"⊙\",\"CircleMinus\":\"⊖\",\"CirclePlus\":\"⊕\",\"CircleTimes\":\"⊗\",\"ClockwiseContourIntegral\":\"∲\",\"CloseCurlyDoubleQuote\":\"”\",\"CloseCurlyQuote\":\"’\",\"Colon\":\"∷\",\"Colone\":\"⩴\",\"Congruent\":\"≡\",\"Conint\":\"∯\",\"ContourIntegral\":\"∮\",\"Copf\":\"ℂ\",\"Coproduct\":\"∐\",\"CounterClockwiseContourIntegral\":\"∳\",\"Cross\":\"⨯\",\"Cscr\":\"𝒞\",\"Cup\":\"⋓\",\"CupCap\":\"≍\",\"DD\":\"ⅅ\",\"DDotrahd\":\"⤑\",\"DJcy\":\"Ђ\",\"DScy\":\"Ѕ\",\"DZcy\":\"Џ\",\"Dagger\":\"‡\",\"Darr\":\"↡\",\"Dashv\":\"⫤\",\"Dcaron\":\"Ď\",\"Dcy\":\"Д\",\"Del\":\"∇\",\"Delta\":\"Δ\",\"Dfr\":\"𝔇\",\"DiacriticalAcute\":\"´\",\"DiacriticalDot\":\"˙\",\"DiacriticalDoubleAcute\":\"˝\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"˜\",\"Diamond\":\"⋄\",\"DifferentialD\":\"ⅆ\",\"Dopf\":\"𝔻\",\"Dot\":\"¨\",\"DotDot\":\"⃜\",\"DotEqual\":\"≐\",\"DoubleContourIntegral\":\"∯\",\"DoubleDot\":\"¨\",\"DoubleDownArrow\":\"⇓\",\"DoubleLeftArrow\":\"⇐\",\"DoubleLeftRightArrow\":\"⇔\",\"DoubleLeftTee\":\"⫤\",\"DoubleLongLeftArrow\":\"⟸\",\"DoubleLongLeftRightArrow\":\"⟺\",\"DoubleLongRightArrow\":\"⟹\",\"DoubleRightArrow\":\"⇒\",\"DoubleRightTee\":\"⊨\",\"DoubleUpArrow\":\"⇑\",\"DoubleUpDownArrow\":\"⇕\",\"DoubleVerticalBar\":\"∥\",\"DownArrow\":\"↓\",\"DownArrowBar\":\"⤓\",\"DownArrowUpArrow\":\"⇵\",\"DownBreve\":\"̑\",\"DownLeftRightVector\":\"⥐\",\"DownLeftTeeVector\":\"⥞\",\"DownLeftVector\":\"↽\",\"DownLeftVectorBar\":\"⥖\",\"DownRightTeeVector\":\"⥟\",\"DownRightVector\":\"⇁\",\"DownRightVectorBar\":\"⥗\",\"DownTee\":\"⊤\",\"DownTeeArrow\":\"↧\",\"Downarrow\":\"⇓\",\"Dscr\":\"𝒟\",\"Dstrok\":\"Đ\",\"ENG\":\"Ŋ\",\"ET\":\"Ð\",\"ETH\":\"Ð\",\"Eacut\":\"É\",\"Eacute\":\"É\",\"Ecaron\":\"Ě\",\"Ecir\":\"Ê\",\"Ecirc\":\"Ê\",\"Ecy\":\"Э\",\"Edot\":\"Ė\",\"Efr\":\"𝔈\",\"Egrav\":\"È\",\"Egrave\":\"È\",\"Element\":\"∈\",\"Emacr\":\"Ē\",\"EmptySmallSquare\":\"◻\",\"EmptyVerySmallSquare\":\"▫\",\"Eogon\":\"Ę\",\"Eopf\":\"𝔼\",\"Epsilon\":\"Ε\",\"Equal\":\"⩵\",\"EqualTilde\":\"≂\",\"Equilibrium\":\"⇌\",\"Escr\":\"ℰ\",\"Esim\":\"⩳\",\"Eta\":\"Η\",\"Eum\":\"Ë\",\"Euml\":\"Ë\",\"Exists\":\"∃\",\"ExponentialE\":\"ⅇ\",\"Fcy\":\"Ф\",\"Ffr\":\"𝔉\",\"FilledSmallSquare\":\"◼\",\"FilledVerySmallSquare\":\"▪\",\"Fopf\":\"𝔽\",\"ForAll\":\"∀\",\"Fouriertrf\":\"ℱ\",\"Fscr\":\"ℱ\",\"GJcy\":\"Ѓ\",\"G\":\">\",\"GT\":\">\",\"Gamma\":\"Γ\",\"Gammad\":\"Ϝ\",\"Gbreve\":\"Ğ\",\"Gcedil\":\"Ģ\",\"Gcirc\":\"Ĝ\",\"Gcy\":\"Г\",\"Gdot\":\"Ġ\",\"Gfr\":\"𝔊\",\"Gg\":\"⋙\",\"Gopf\":\"𝔾\",\"GreaterEqual\":\"≥\",\"GreaterEqualLess\":\"⋛\",\"GreaterFullEqual\":\"≧\",\"GreaterGreater\":\"⪢\",\"GreaterLess\":\"≷\",\"GreaterSlantEqual\":\"⩾\",\"GreaterTilde\":\"≳\",\"Gscr\":\"𝒢\",\"Gt\":\"≫\",\"HARDcy\":\"Ъ\",\"Hacek\":\"ˇ\",\"Hat\":\"^\",\"Hcirc\":\"Ĥ\",\"Hfr\":\"ℌ\",\"HilbertSpace\":\"ℋ\",\"Hopf\":\"ℍ\",\"HorizontalLine\":\"─\",\"Hscr\":\"ℋ\",\"Hstrok\":\"Ħ\",\"HumpDownHump\":\"≎\",\"HumpEqual\":\"≏\",\"IEcy\":\"Е\",\"IJlig\":\"Ĳ\",\"IOcy\":\"Ё\",\"Iacut\":\"Í\",\"Iacute\":\"Í\",\"Icir\":\"Î\",\"Icirc\":\"Î\",\"Icy\":\"И\",\"Idot\":\"İ\",\"Ifr\":\"ℑ\",\"Igrav\":\"Ì\",\"Igrave\":\"Ì\",\"Im\":\"ℑ\",\"Imacr\":\"Ī\",\"ImaginaryI\":\"ⅈ\",\"Implies\":\"⇒\",\"Int\":\"∬\",\"Integral\":\"∫\",\"Intersection\":\"⋂\",\"InvisibleComma\":\"⁣\",\"InvisibleTimes\":\"⁢\",\"Iogon\":\"Į\",\"Iopf\":\"𝕀\",\"Iota\":\"Ι\",\"Iscr\":\"ℐ\",\"Itilde\":\"Ĩ\",\"Iukcy\":\"І\",\"Ium\":\"Ï\",\"Iuml\":\"Ï\",\"Jcirc\":\"Ĵ\",\"Jcy\":\"Й\",\"Jfr\":\"𝔍\",\"Jopf\":\"𝕁\",\"Jscr\":\"𝒥\",\"Jsercy\":\"Ј\",\"Jukcy\":\"Є\",\"KHcy\":\"Х\",\"KJcy\":\"Ќ\",\"Kappa\":\"Κ\",\"Kcedil\":\"Ķ\",\"Kcy\":\"К\",\"Kfr\":\"𝔎\",\"Kopf\":\"𝕂\",\"Kscr\":\"𝒦\",\"LJcy\":\"Љ\",\"L\":\"<\",\"LT\":\"<\",\"Lacute\":\"Ĺ\",\"Lambda\":\"Λ\",\"Lang\":\"⟪\",\"Laplacetrf\":\"ℒ\",\"Larr\":\"↞\",\"Lcaron\":\"Ľ\",\"Lcedil\":\"Ļ\",\"Lcy\":\"Л\",\"LeftAngleBracket\":\"⟨\",\"LeftArrow\":\"←\",\"LeftArrowBar\":\"⇤\",\"LeftArrowRightArrow\":\"⇆\",\"LeftCeiling\":\"⌈\",\"LeftDoubleBracket\":\"⟦\",\"LeftDownTeeVector\":\"⥡\",\"LeftDownVector\":\"⇃\",\"LeftDownVectorBar\":\"⥙\",\"LeftFloor\":\"⌊\",\"LeftRightArrow\":\"↔\",\"LeftRightVector\":\"⥎\",\"LeftTee\":\"⊣\",\"LeftTeeArrow\":\"↤\",\"LeftTeeVector\":\"⥚\",\"LeftTriangle\":\"⊲\",\"LeftTriangleBar\":\"⧏\",\"LeftTriangleEqual\":\"⊴\",\"LeftUpDownVector\":\"⥑\",\"LeftUpTeeVector\":\"⥠\",\"LeftUpVector\":\"↿\",\"LeftUpVectorBar\":\"⥘\",\"LeftVector\":\"↼\",\"LeftVectorBar\":\"⥒\",\"Leftarrow\":\"⇐\",\"Leftrightarrow\":\"⇔\",\"LessEqualGreater\":\"⋚\",\"LessFullEqual\":\"≦\",\"LessGreater\":\"≶\",\"LessLess\":\"⪡\",\"LessSlantEqual\":\"⩽\",\"LessTilde\":\"≲\",\"Lfr\":\"𝔏\",\"Ll\":\"⋘\",\"Lleftarrow\":\"⇚\",\"Lmidot\":\"Ŀ\",\"LongLeftArrow\":\"⟵\",\"LongLeftRightArrow\":\"⟷\",\"LongRightArrow\":\"⟶\",\"Longleftarrow\":\"⟸\",\"Longleftrightarrow\":\"⟺\",\"Longrightarrow\":\"⟹\",\"Lopf\":\"𝕃\",\"LowerLeftArrow\":\"↙\",\"LowerRightArrow\":\"↘\",\"Lscr\":\"ℒ\",\"Lsh\":\"↰\",\"Lstrok\":\"Ł\",\"Lt\":\"≪\",\"Map\":\"⤅\",\"Mcy\":\"М\",\"MediumSpace\":\" \",\"Mellintrf\":\"ℳ\",\"Mfr\":\"𝔐\",\"MinusPlus\":\"∓\",\"Mopf\":\"𝕄\",\"Mscr\":\"ℳ\",\"Mu\":\"Μ\",\"NJcy\":\"Њ\",\"Nacute\":\"Ń\",\"Ncaron\":\"Ň\",\"Ncedil\":\"Ņ\",\"Ncy\":\"Н\",\"NegativeMediumSpace\":\"​\",\"NegativeThickSpace\":\"​\",\"NegativeThinSpace\":\"​\",\"NegativeVeryThinSpace\":\"​\",\"NestedGreaterGreater\":\"≫\",\"NestedLessLess\":\"≪\",\"NewLine\":\"\\n\",\"Nfr\":\"𝔑\",\"NoBreak\":\"⁠\",\"NonBreakingSpace\":\" \",\"Nopf\":\"ℕ\",\"Not\":\"⫬\",\"NotCongruent\":\"≢\",\"NotCupCap\":\"≭\",\"NotDoubleVerticalBar\":\"∦\",\"NotElement\":\"∉\",\"NotEqual\":\"≠\",\"NotEqualTilde\":\"≂̸\",\"NotExists\":\"∄\",\"NotGreater\":\"≯\",\"NotGreaterEqual\":\"≱\",\"NotGreaterFullEqual\":\"≧̸\",\"NotGreaterGreater\":\"≫̸\",\"NotGreaterLess\":\"≹\",\"NotGreaterSlantEqual\":\"⩾̸\",\"NotGreaterTilde\":\"≵\",\"NotHumpDownHump\":\"≎̸\",\"NotHumpEqual\":\"≏̸\",\"NotLeftTriangle\":\"⋪\",\"NotLeftTriangleBar\":\"⧏̸\",\"NotLeftTriangleEqual\":\"⋬\",\"NotLess\":\"≮\",\"NotLessEqual\":\"≰\",\"NotLessGreater\":\"≸\",\"NotLessLess\":\"≪̸\",\"NotLessSlantEqual\":\"⩽̸\",\"NotLessTilde\":\"≴\",\"NotNestedGreaterGreater\":\"⪢̸\",\"NotNestedLessLess\":\"⪡̸\",\"NotPrecedes\":\"⊀\",\"NotPrecedesEqual\":\"⪯̸\",\"NotPrecedesSlantEqual\":\"⋠\",\"NotReverseElement\":\"∌\",\"NotRightTriangle\":\"⋫\",\"NotRightTriangleBar\":\"⧐̸\",\"NotRightTriangleEqual\":\"⋭\",\"NotSquareSubset\":\"⊏̸\",\"NotSquareSubsetEqual\":\"⋢\",\"NotSquareSuperset\":\"⊐̸\",\"NotSquareSupersetEqual\":\"⋣\",\"NotSubset\":\"⊂⃒\",\"NotSubsetEqual\":\"⊈\",\"NotSucceeds\":\"⊁\",\"NotSucceedsEqual\":\"⪰̸\",\"NotSucceedsSlantEqual\":\"⋡\",\"NotSucceedsTilde\":\"≿̸\",\"NotSuperset\":\"⊃⃒\",\"NotSupersetEqual\":\"⊉\",\"NotTilde\":\"≁\",\"NotTildeEqual\":\"≄\",\"NotTildeFullEqual\":\"≇\",\"NotTildeTilde\":\"≉\",\"NotVerticalBar\":\"∤\",\"Nscr\":\"𝒩\",\"Ntild\":\"Ñ\",\"Ntilde\":\"Ñ\",\"Nu\":\"Ν\",\"OElig\":\"Œ\",\"Oacut\":\"Ó\",\"Oacute\":\"Ó\",\"Ocir\":\"Ô\",\"Ocirc\":\"Ô\",\"Ocy\":\"О\",\"Odblac\":\"Ő\",\"Ofr\":\"𝔒\",\"Ograv\":\"Ò\",\"Ograve\":\"Ò\",\"Omacr\":\"Ō\",\"Omega\":\"Ω\",\"Omicron\":\"Ο\",\"Oopf\":\"𝕆\",\"OpenCurlyDoubleQuote\":\"“\",\"OpenCurlyQuote\":\"‘\",\"Or\":\"⩔\",\"Oscr\":\"𝒪\",\"Oslas\":\"Ø\",\"Oslash\":\"Ø\",\"Otild\":\"Õ\",\"Otilde\":\"Õ\",\"Otimes\":\"⨷\",\"Oum\":\"Ö\",\"Ouml\":\"Ö\",\"OverBar\":\"‾\",\"OverBrace\":\"⏞\",\"OverBracket\":\"⎴\",\"OverParenthesis\":\"⏜\",\"PartialD\":\"∂\",\"Pcy\":\"П\",\"Pfr\":\"𝔓\",\"Phi\":\"Φ\",\"Pi\":\"Π\",\"PlusMinus\":\"±\",\"Poincareplane\":\"ℌ\",\"Popf\":\"ℙ\",\"Pr\":\"⪻\",\"Precedes\":\"≺\",\"PrecedesEqual\":\"⪯\",\"PrecedesSlantEqual\":\"≼\",\"PrecedesTilde\":\"≾\",\"Prime\":\"″\",\"Product\":\"∏\",\"Proportion\":\"∷\",\"Proportional\":\"∝\",\"Pscr\":\"𝒫\",\"Psi\":\"Ψ\",\"QUO\":\"\\\"\",\"QUOT\":\"\\\"\",\"Qfr\":\"𝔔\",\"Qopf\":\"ℚ\",\"Qscr\":\"𝒬\",\"RBarr\":\"⤐\",\"RE\":\"®\",\"REG\":\"®\",\"Racute\":\"Ŕ\",\"Rang\":\"⟫\",\"Rarr\":\"↠\",\"Rarrtl\":\"⤖\",\"Rcaron\":\"Ř\",\"Rcedil\":\"Ŗ\",\"Rcy\":\"Р\",\"Re\":\"ℜ\",\"ReverseElement\":\"∋\",\"ReverseEquilibrium\":\"⇋\",\"ReverseUpEquilibrium\":\"⥯\",\"Rfr\":\"ℜ\",\"Rho\":\"Ρ\",\"RightAngleBracket\":\"⟩\",\"RightArrow\":\"→\",\"RightArrowBar\":\"⇥\",\"RightArrowLeftArrow\":\"⇄\",\"RightCeiling\":\"⌉\",\"RightDoubleBracket\":\"⟧\",\"RightDownTeeVector\":\"⥝\",\"RightDownVector\":\"⇂\",\"RightDownVectorBar\":\"⥕\",\"RightFloor\":\"⌋\",\"RightTee\":\"⊢\",\"RightTeeArrow\":\"↦\",\"RightTeeVector\":\"⥛\",\"RightTriangle\":\"⊳\",\"RightTriangleBar\":\"⧐\",\"RightTriangleEqual\":\"⊵\",\"RightUpDownVector\":\"⥏\",\"RightUpTeeVector\":\"⥜\",\"RightUpVector\":\"↾\",\"RightUpVectorBar\":\"⥔\",\"RightVector\":\"⇀\",\"RightVectorBar\":\"⥓\",\"Rightarrow\":\"⇒\",\"Ropf\":\"ℝ\",\"RoundImplies\":\"⥰\",\"Rrightarrow\":\"⇛\",\"Rscr\":\"ℛ\",\"Rsh\":\"↱\",\"RuleDelayed\":\"⧴\",\"SHCHcy\":\"Щ\",\"SHcy\":\"Ш\",\"SOFTcy\":\"Ь\",\"Sacute\":\"Ś\",\"Sc\":\"⪼\",\"Scaron\":\"Š\",\"Scedil\":\"Ş\",\"Scirc\":\"Ŝ\",\"Scy\":\"С\",\"Sfr\":\"𝔖\",\"ShortDownArrow\":\"↓\",\"ShortLeftArrow\":\"←\",\"ShortRightArrow\":\"→\",\"ShortUpArrow\":\"↑\",\"Sigma\":\"Σ\",\"SmallCircle\":\"∘\",\"Sopf\":\"𝕊\",\"Sqrt\":\"√\",\"Square\":\"□\",\"SquareIntersection\":\"⊓\",\"SquareSubset\":\"⊏\",\"SquareSubsetEqual\":\"⊑\",\"SquareSuperset\":\"⊐\",\"SquareSupersetEqual\":\"⊒\",\"SquareUnion\":\"⊔\",\"Sscr\":\"𝒮\",\"Star\":\"⋆\",\"Sub\":\"⋐\",\"Subset\":\"⋐\",\"SubsetEqual\":\"⊆\",\"Succeeds\":\"≻\",\"SucceedsEqual\":\"⪰\",\"SucceedsSlantEqual\":\"≽\",\"SucceedsTilde\":\"≿\",\"SuchThat\":\"∋\",\"Sum\":\"∑\",\"Sup\":\"⋑\",\"Superset\":\"⊃\",\"SupersetEqual\":\"⊇\",\"Supset\":\"⋑\",\"THOR\":\"Þ\",\"THORN\":\"Þ\",\"TRADE\":\"™\",\"TSHcy\":\"Ћ\",\"TScy\":\"Ц\",\"Tab\":\"\\t\",\"Tau\":\"Τ\",\"Tcaron\":\"Ť\",\"Tcedil\":\"Ţ\",\"Tcy\":\"Т\",\"Tfr\":\"𝔗\",\"Therefore\":\"∴\",\"Theta\":\"Θ\",\"ThickSpace\":\"  \",\"ThinSpace\":\" \",\"Tilde\":\"∼\",\"TildeEqual\":\"≃\",\"TildeFullEqual\":\"≅\",\"TildeTilde\":\"≈\",\"Topf\":\"𝕋\",\"TripleDot\":\"⃛\",\"Tscr\":\"𝒯\",\"Tstrok\":\"Ŧ\",\"Uacut\":\"Ú\",\"Uacute\":\"Ú\",\"Uarr\":\"↟\",\"Uarrocir\":\"⥉\",\"Ubrcy\":\"Ў\",\"Ubreve\":\"Ŭ\",\"Ucir\":\"Û\",\"Ucirc\":\"Û\",\"Ucy\":\"У\",\"Udblac\":\"Ű\",\"Ufr\":\"𝔘\",\"Ugrav\":\"Ù\",\"Ugrave\":\"Ù\",\"Umacr\":\"Ū\",\"UnderBar\":\"_\",\"UnderBrace\":\"⏟\",\"UnderBracket\":\"⎵\",\"UnderParenthesis\":\"⏝\",\"Union\":\"⋃\",\"UnionPlus\":\"⊎\",\"Uogon\":\"Ų\",\"Uopf\":\"𝕌\",\"UpArrow\":\"↑\",\"UpArrowBar\":\"⤒\",\"UpArrowDownArrow\":\"⇅\",\"UpDownArrow\":\"↕\",\"UpEquilibrium\":\"⥮\",\"UpTee\":\"⊥\",\"UpTeeArrow\":\"↥\",\"Uparrow\":\"⇑\",\"Updownarrow\":\"⇕\",\"UpperLeftArrow\":\"↖\",\"UpperRightArrow\":\"↗\",\"Upsi\":\"ϒ\",\"Upsilon\":\"Υ\",\"Uring\":\"Ů\",\"Uscr\":\"𝒰\",\"Utilde\":\"Ũ\",\"Uum\":\"Ü\",\"Uuml\":\"Ü\",\"VDash\":\"⊫\",\"Vbar\":\"⫫\",\"Vcy\":\"В\",\"Vdash\":\"⊩\",\"Vdashl\":\"⫦\",\"Vee\":\"⋁\",\"Verbar\":\"‖\",\"Vert\":\"‖\",\"VerticalBar\":\"∣\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"❘\",\"VerticalTilde\":\"≀\",\"VeryThinSpace\":\" \",\"Vfr\":\"𝔙\",\"Vopf\":\"𝕍\",\"Vscr\":\"𝒱\",\"Vvdash\":\"⊪\",\"Wcirc\":\"Ŵ\",\"Wedge\":\"⋀\",\"Wfr\":\"𝔚\",\"Wopf\":\"𝕎\",\"Wscr\":\"𝒲\",\"Xfr\":\"𝔛\",\"Xi\":\"Ξ\",\"Xopf\":\"𝕏\",\"Xscr\":\"𝒳\",\"YAcy\":\"Я\",\"YIcy\":\"Ї\",\"YUcy\":\"Ю\",\"Yacut\":\"Ý\",\"Yacute\":\"Ý\",\"Ycirc\":\"Ŷ\",\"Ycy\":\"Ы\",\"Yfr\":\"𝔜\",\"Yopf\":\"𝕐\",\"Yscr\":\"𝒴\",\"Yuml\":\"Ÿ\",\"ZHcy\":\"Ж\",\"Zacute\":\"Ź\",\"Zcaron\":\"Ž\",\"Zcy\":\"З\",\"Zdot\":\"Ż\",\"ZeroWidthSpace\":\"​\",\"Zeta\":\"Ζ\",\"Zfr\":\"ℨ\",\"Zopf\":\"ℤ\",\"Zscr\":\"𝒵\",\"aacut\":\"á\",\"aacute\":\"á\",\"abreve\":\"ă\",\"ac\":\"∾\",\"acE\":\"∾̳\",\"acd\":\"∿\",\"acir\":\"â\",\"acirc\":\"â\",\"acut\":\"´\",\"acute\":\"´\",\"acy\":\"а\",\"aeli\":\"æ\",\"aelig\":\"æ\",\"af\":\"⁡\",\"afr\":\"𝔞\",\"agrav\":\"à\",\"agrave\":\"à\",\"alefsym\":\"ℵ\",\"aleph\":\"ℵ\",\"alpha\":\"α\",\"amacr\":\"ā\",\"amalg\":\"⨿\",\"am\":\"&\",\"amp\":\"&\",\"and\":\"∧\",\"andand\":\"⩕\",\"andd\":\"⩜\",\"andslope\":\"⩘\",\"andv\":\"⩚\",\"ang\":\"∠\",\"ange\":\"⦤\",\"angle\":\"∠\",\"angmsd\":\"∡\",\"angmsdaa\":\"⦨\",\"angmsdab\":\"⦩\",\"angmsdac\":\"⦪\",\"angmsdad\":\"⦫\",\"angmsdae\":\"⦬\",\"angmsdaf\":\"⦭\",\"angmsdag\":\"⦮\",\"angmsdah\":\"⦯\",\"angrt\":\"∟\",\"angrtvb\":\"⊾\",\"angrtvbd\":\"⦝\",\"angsph\":\"∢\",\"angst\":\"Å\",\"angzarr\":\"⍼\",\"aogon\":\"ą\",\"aopf\":\"𝕒\",\"ap\":\"≈\",\"apE\":\"⩰\",\"apacir\":\"⩯\",\"ape\":\"≊\",\"apid\":\"≋\",\"apos\":\"'\",\"approx\":\"≈\",\"approxeq\":\"≊\",\"arin\":\"å\",\"aring\":\"å\",\"ascr\":\"𝒶\",\"ast\":\"*\",\"asymp\":\"≈\",\"asympeq\":\"≍\",\"atild\":\"ã\",\"atilde\":\"ã\",\"aum\":\"ä\",\"auml\":\"ä\",\"awconint\":\"∳\",\"awint\":\"⨑\",\"bNot\":\"⫭\",\"backcong\":\"≌\",\"backepsilon\":\"϶\",\"backprime\":\"‵\",\"backsim\":\"∽\",\"backsimeq\":\"⋍\",\"barvee\":\"⊽\",\"barwed\":\"⌅\",\"barwedge\":\"⌅\",\"bbrk\":\"⎵\",\"bbrktbrk\":\"⎶\",\"bcong\":\"≌\",\"bcy\":\"б\",\"bdquo\":\"„\",\"becaus\":\"∵\",\"because\":\"∵\",\"bemptyv\":\"⦰\",\"bepsi\":\"϶\",\"bernou\":\"ℬ\",\"beta\":\"β\",\"beth\":\"ℶ\",\"between\":\"≬\",\"bfr\":\"𝔟\",\"bigcap\":\"⋂\",\"bigcirc\":\"◯\",\"bigcup\":\"⋃\",\"bigodot\":\"⨀\",\"bigoplus\":\"⨁\",\"bigotimes\":\"⨂\",\"bigsqcup\":\"⨆\",\"bigstar\":\"★\",\"bigtriangledown\":\"▽\",\"bigtriangleup\":\"△\",\"biguplus\":\"⨄\",\"bigvee\":\"⋁\",\"bigwedge\":\"⋀\",\"bkarow\":\"⤍\",\"blacklozenge\":\"⧫\",\"blacksquare\":\"▪\",\"blacktriangle\":\"▴\",\"blacktriangledown\":\"▾\",\"blacktriangleleft\":\"◂\",\"blacktriangleright\":\"▸\",\"blank\":\"␣\",\"blk12\":\"▒\",\"blk14\":\"░\",\"blk34\":\"▓\",\"block\":\"█\",\"bne\":\"=⃥\",\"bnequiv\":\"≡⃥\",\"bnot\":\"⌐\",\"bopf\":\"𝕓\",\"bot\":\"⊥\",\"bottom\":\"⊥\",\"bowtie\":\"⋈\",\"boxDL\":\"╗\",\"boxDR\":\"╔\",\"boxDl\":\"╖\",\"boxDr\":\"╓\",\"boxH\":\"═\",\"boxHD\":\"╦\",\"boxHU\":\"╩\",\"boxHd\":\"╤\",\"boxHu\":\"╧\",\"boxUL\":\"╝\",\"boxUR\":\"╚\",\"boxUl\":\"╜\",\"boxUr\":\"╙\",\"boxV\":\"║\",\"boxVH\":\"╬\",\"boxVL\":\"╣\",\"boxVR\":\"╠\",\"boxVh\":\"╫\",\"boxVl\":\"╢\",\"boxVr\":\"╟\",\"boxbox\":\"⧉\",\"boxdL\":\"╕\",\"boxdR\":\"╒\",\"boxdl\":\"┐\",\"boxdr\":\"┌\",\"boxh\":\"─\",\"boxhD\":\"╥\",\"boxhU\":\"╨\",\"boxhd\":\"┬\",\"boxhu\":\"┴\",\"boxminus\":\"⊟\",\"boxplus\":\"⊞\",\"boxtimes\":\"⊠\",\"boxuL\":\"╛\",\"boxuR\":\"╘\",\"boxul\":\"┘\",\"boxur\":\"└\",\"boxv\":\"│\",\"boxvH\":\"╪\",\"boxvL\":\"╡\",\"boxvR\":\"╞\",\"boxvh\":\"┼\",\"boxvl\":\"┤\",\"boxvr\":\"├\",\"bprime\":\"‵\",\"breve\":\"˘\",\"brvba\":\"¦\",\"brvbar\":\"¦\",\"bscr\":\"𝒷\",\"bsemi\":\"⁏\",\"bsim\":\"∽\",\"bsime\":\"⋍\",\"bsol\":\"\\\\\",\"bsolb\":\"⧅\",\"bsolhsub\":\"⟈\",\"bull\":\"•\",\"bullet\":\"•\",\"bump\":\"≎\",\"bumpE\":\"⪮\",\"bumpe\":\"≏\",\"bumpeq\":\"≏\",\"cacute\":\"ć\",\"cap\":\"∩\",\"capand\":\"⩄\",\"capbrcup\":\"⩉\",\"capcap\":\"⩋\",\"capcup\":\"⩇\",\"capdot\":\"⩀\",\"caps\":\"∩︀\",\"caret\":\"⁁\",\"caron\":\"ˇ\",\"ccaps\":\"⩍\",\"ccaron\":\"č\",\"ccedi\":\"ç\",\"ccedil\":\"ç\",\"ccirc\":\"ĉ\",\"ccups\":\"⩌\",\"ccupssm\":\"⩐\",\"cdot\":\"ċ\",\"cedi\":\"¸\",\"cedil\":\"¸\",\"cemptyv\":\"⦲\",\"cen\":\"¢\",\"cent\":\"¢\",\"centerdot\":\"·\",\"cfr\":\"𝔠\",\"chcy\":\"ч\",\"check\":\"✓\",\"checkmark\":\"✓\",\"chi\":\"χ\",\"cir\":\"○\",\"cirE\":\"⧃\",\"circ\":\"ˆ\",\"circeq\":\"≗\",\"circlearrowleft\":\"↺\",\"circlearrowright\":\"↻\",\"circledR\":\"®\",\"circledS\":\"Ⓢ\",\"circledast\":\"⊛\",\"circledcirc\":\"⊚\",\"circleddash\":\"⊝\",\"cire\":\"≗\",\"cirfnint\":\"⨐\",\"cirmid\":\"⫯\",\"cirscir\":\"⧂\",\"clubs\":\"♣\",\"clubsuit\":\"♣\",\"colon\":\":\",\"colone\":\"≔\",\"coloneq\":\"≔\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"∁\",\"compfn\":\"∘\",\"complement\":\"∁\",\"complexes\":\"ℂ\",\"cong\":\"≅\",\"congdot\":\"⩭\",\"conint\":\"∮\",\"copf\":\"𝕔\",\"coprod\":\"∐\",\"cop\":\"©\",\"copy\":\"©\",\"copysr\":\"℗\",\"crarr\":\"↵\",\"cross\":\"✗\",\"cscr\":\"𝒸\",\"csub\":\"⫏\",\"csube\":\"⫑\",\"csup\":\"⫐\",\"csupe\":\"⫒\",\"ctdot\":\"⋯\",\"cudarrl\":\"⤸\",\"cudarrr\":\"⤵\",\"cuepr\":\"⋞\",\"cuesc\":\"⋟\",\"cularr\":\"↶\",\"cularrp\":\"⤽\",\"cup\":\"∪\",\"cupbrcap\":\"⩈\",\"cupcap\":\"⩆\",\"cupcup\":\"⩊\",\"cupdot\":\"⊍\",\"cupor\":\"⩅\",\"cups\":\"∪︀\",\"curarr\":\"↷\",\"curarrm\":\"⤼\",\"curlyeqprec\":\"⋞\",\"curlyeqsucc\":\"⋟\",\"curlyvee\":\"⋎\",\"curlywedge\":\"⋏\",\"curre\":\"¤\",\"curren\":\"¤\",\"curvearrowleft\":\"↶\",\"curvearrowright\":\"↷\",\"cuvee\":\"⋎\",\"cuwed\":\"⋏\",\"cwconint\":\"∲\",\"cwint\":\"∱\",\"cylcty\":\"⌭\",\"dArr\":\"⇓\",\"dHar\":\"⥥\",\"dagger\":\"†\",\"daleth\":\"ℸ\",\"darr\":\"↓\",\"dash\":\"‐\",\"dashv\":\"⊣\",\"dbkarow\":\"⤏\",\"dblac\":\"˝\",\"dcaron\":\"ď\",\"dcy\":\"д\",\"dd\":\"ⅆ\",\"ddagger\":\"‡\",\"ddarr\":\"⇊\",\"ddotseq\":\"⩷\",\"de\":\"°\",\"deg\":\"°\",\"delta\":\"δ\",\"demptyv\":\"⦱\",\"dfisht\":\"⥿\",\"dfr\":\"𝔡\",\"dharl\":\"⇃\",\"dharr\":\"⇂\",\"diam\":\"⋄\",\"diamond\":\"⋄\",\"diamondsuit\":\"♦\",\"diams\":\"♦\",\"die\":\"¨\",\"digamma\":\"ϝ\",\"disin\":\"⋲\",\"div\":\"÷\",\"divid\":\"÷\",\"divide\":\"÷\",\"divideontimes\":\"⋇\",\"divonx\":\"⋇\",\"djcy\":\"ђ\",\"dlcorn\":\"⌞\",\"dlcrop\":\"⌍\",\"dollar\":\"$\",\"dopf\":\"𝕕\",\"dot\":\"˙\",\"doteq\":\"≐\",\"doteqdot\":\"≑\",\"dotminus\":\"∸\",\"dotplus\":\"∔\",\"dotsquare\":\"⊡\",\"doublebarwedge\":\"⌆\",\"downarrow\":\"↓\",\"downdownarrows\":\"⇊\",\"downharpoonleft\":\"⇃\",\"downharpoonright\":\"⇂\",\"drbkarow\":\"⤐\",\"drcorn\":\"⌟\",\"drcrop\":\"⌌\",\"dscr\":\"𝒹\",\"dscy\":\"ѕ\",\"dsol\":\"⧶\",\"dstrok\":\"đ\",\"dtdot\":\"⋱\",\"dtri\":\"▿\",\"dtrif\":\"▾\",\"duarr\":\"⇵\",\"duhar\":\"⥯\",\"dwangle\":\"⦦\",\"dzcy\":\"џ\",\"dzigrarr\":\"⟿\",\"eDDot\":\"⩷\",\"eDot\":\"≑\",\"eacut\":\"é\",\"eacute\":\"é\",\"easter\":\"⩮\",\"ecaron\":\"ě\",\"ecir\":\"ê\",\"ecirc\":\"ê\",\"ecolon\":\"≕\",\"ecy\":\"э\",\"edot\":\"ė\",\"ee\":\"ⅇ\",\"efDot\":\"≒\",\"efr\":\"𝔢\",\"eg\":\"⪚\",\"egrav\":\"è\",\"egrave\":\"è\",\"egs\":\"⪖\",\"egsdot\":\"⪘\",\"el\":\"⪙\",\"elinters\":\"⏧\",\"ell\":\"ℓ\",\"els\":\"⪕\",\"elsdot\":\"⪗\",\"emacr\":\"ē\",\"empty\":\"∅\",\"emptyset\":\"∅\",\"emptyv\":\"∅\",\"emsp13\":\" \",\"emsp14\":\" \",\"emsp\":\" \",\"eng\":\"ŋ\",\"ensp\":\" \",\"eogon\":\"ę\",\"eopf\":\"𝕖\",\"epar\":\"⋕\",\"eparsl\":\"⧣\",\"eplus\":\"⩱\",\"epsi\":\"ε\",\"epsilon\":\"ε\",\"epsiv\":\"ϵ\",\"eqcirc\":\"≖\",\"eqcolon\":\"≕\",\"eqsim\":\"≂\",\"eqslantgtr\":\"⪖\",\"eqslantless\":\"⪕\",\"equals\":\"=\",\"equest\":\"≟\",\"equiv\":\"≡\",\"equivDD\":\"⩸\",\"eqvparsl\":\"⧥\",\"erDot\":\"≓\",\"erarr\":\"⥱\",\"escr\":\"ℯ\",\"esdot\":\"≐\",\"esim\":\"≂\",\"eta\":\"η\",\"et\":\"ð\",\"eth\":\"ð\",\"eum\":\"ë\",\"euml\":\"ë\",\"euro\":\"€\",\"excl\":\"!\",\"exist\":\"∃\",\"expectation\":\"ℰ\",\"exponentiale\":\"ⅇ\",\"fallingdotseq\":\"≒\",\"fcy\":\"ф\",\"female\":\"♀\",\"ffilig\":\"ﬃ\",\"fflig\":\"ﬀ\",\"ffllig\":\"ﬄ\",\"ffr\":\"𝔣\",\"filig\":\"ﬁ\",\"fjlig\":\"fj\",\"flat\":\"♭\",\"fllig\":\"ﬂ\",\"fltns\":\"▱\",\"fnof\":\"ƒ\",\"fopf\":\"𝕗\",\"forall\":\"∀\",\"fork\":\"⋔\",\"forkv\":\"⫙\",\"fpartint\":\"⨍\",\"frac1\":\"¼\",\"frac12\":\"½\",\"frac13\":\"⅓\",\"frac14\":\"¼\",\"frac15\":\"⅕\",\"frac16\":\"⅙\",\"frac18\":\"⅛\",\"frac23\":\"⅔\",\"frac25\":\"⅖\",\"frac3\":\"¾\",\"frac34\":\"¾\",\"frac35\":\"⅗\",\"frac38\":\"⅜\",\"frac45\":\"⅘\",\"frac56\":\"⅚\",\"frac58\":\"⅝\",\"frac78\":\"⅞\",\"frasl\":\"⁄\",\"frown\":\"⌢\",\"fscr\":\"𝒻\",\"gE\":\"≧\",\"gEl\":\"⪌\",\"gacute\":\"ǵ\",\"gamma\":\"γ\",\"gammad\":\"ϝ\",\"gap\":\"⪆\",\"gbreve\":\"ğ\",\"gcirc\":\"ĝ\",\"gcy\":\"г\",\"gdot\":\"ġ\",\"ge\":\"≥\",\"gel\":\"⋛\",\"geq\":\"≥\",\"geqq\":\"≧\",\"geqslant\":\"⩾\",\"ges\":\"⩾\",\"gescc\":\"⪩\",\"gesdot\":\"⪀\",\"gesdoto\":\"⪂\",\"gesdotol\":\"⪄\",\"gesl\":\"⋛︀\",\"gesles\":\"⪔\",\"gfr\":\"𝔤\",\"gg\":\"≫\",\"ggg\":\"⋙\",\"gimel\":\"ℷ\",\"gjcy\":\"ѓ\",\"gl\":\"≷\",\"glE\":\"⪒\",\"gla\":\"⪥\",\"glj\":\"⪤\",\"gnE\":\"≩\",\"gnap\":\"⪊\",\"gnapprox\":\"⪊\",\"gne\":\"⪈\",\"gneq\":\"⪈\",\"gneqq\":\"≩\",\"gnsim\":\"⋧\",\"gopf\":\"𝕘\",\"grave\":\"`\",\"gscr\":\"ℊ\",\"gsim\":\"≳\",\"gsime\":\"⪎\",\"gsiml\":\"⪐\",\"g\":\">\",\"gt\":\">\",\"gtcc\":\"⪧\",\"gtcir\":\"⩺\",\"gtdot\":\"⋗\",\"gtlPar\":\"⦕\",\"gtquest\":\"⩼\",\"gtrapprox\":\"⪆\",\"gtrarr\":\"⥸\",\"gtrdot\":\"⋗\",\"gtreqless\":\"⋛\",\"gtreqqless\":\"⪌\",\"gtrless\":\"≷\",\"gtrsim\":\"≳\",\"gvertneqq\":\"≩︀\",\"gvnE\":\"≩︀\",\"hArr\":\"⇔\",\"hairsp\":\" \",\"half\":\"½\",\"hamilt\":\"ℋ\",\"hardcy\":\"ъ\",\"harr\":\"↔\",\"harrcir\":\"⥈\",\"harrw\":\"↭\",\"hbar\":\"ℏ\",\"hcirc\":\"ĥ\",\"hearts\":\"♥\",\"heartsuit\":\"♥\",\"hellip\":\"…\",\"hercon\":\"⊹\",\"hfr\":\"𝔥\",\"hksearow\":\"⤥\",\"hkswarow\":\"⤦\",\"hoarr\":\"⇿\",\"homtht\":\"∻\",\"hookleftarrow\":\"↩\",\"hookrightarrow\":\"↪\",\"hopf\":\"𝕙\",\"horbar\":\"―\",\"hscr\":\"𝒽\",\"hslash\":\"ℏ\",\"hstrok\":\"ħ\",\"hybull\":\"⁃\",\"hyphen\":\"‐\",\"iacut\":\"í\",\"iacute\":\"í\",\"ic\":\"⁣\",\"icir\":\"î\",\"icirc\":\"î\",\"icy\":\"и\",\"iecy\":\"е\",\"iexc\":\"¡\",\"iexcl\":\"¡\",\"iff\":\"⇔\",\"ifr\":\"𝔦\",\"igrav\":\"ì\",\"igrave\":\"ì\",\"ii\":\"ⅈ\",\"iiiint\":\"⨌\",\"iiint\":\"∭\",\"iinfin\":\"⧜\",\"iiota\":\"℩\",\"ijlig\":\"ĳ\",\"imacr\":\"ī\",\"image\":\"ℑ\",\"imagline\":\"ℐ\",\"imagpart\":\"ℑ\",\"imath\":\"ı\",\"imof\":\"⊷\",\"imped\":\"Ƶ\",\"in\":\"∈\",\"incare\":\"℅\",\"infin\":\"∞\",\"infintie\":\"⧝\",\"inodot\":\"ı\",\"int\":\"∫\",\"intcal\":\"⊺\",\"integers\":\"ℤ\",\"intercal\":\"⊺\",\"intlarhk\":\"⨗\",\"intprod\":\"⨼\",\"iocy\":\"ё\",\"iogon\":\"į\",\"iopf\":\"𝕚\",\"iota\":\"ι\",\"iprod\":\"⨼\",\"iques\":\"¿\",\"iquest\":\"¿\",\"iscr\":\"𝒾\",\"isin\":\"∈\",\"isinE\":\"⋹\",\"isindot\":\"⋵\",\"isins\":\"⋴\",\"isinsv\":\"⋳\",\"isinv\":\"∈\",\"it\":\"⁢\",\"itilde\":\"ĩ\",\"iukcy\":\"і\",\"ium\":\"ï\",\"iuml\":\"ï\",\"jcirc\":\"ĵ\",\"jcy\":\"й\",\"jfr\":\"𝔧\",\"jmath\":\"ȷ\",\"jopf\":\"𝕛\",\"jscr\":\"𝒿\",\"jsercy\":\"ј\",\"jukcy\":\"є\",\"kappa\":\"κ\",\"kappav\":\"ϰ\",\"kcedil\":\"ķ\",\"kcy\":\"к\",\"kfr\":\"𝔨\",\"kgreen\":\"ĸ\",\"khcy\":\"х\",\"kjcy\":\"ќ\",\"kopf\":\"𝕜\",\"kscr\":\"𝓀\",\"lAarr\":\"⇚\",\"lArr\":\"⇐\",\"lAtail\":\"⤛\",\"lBarr\":\"⤎\",\"lE\":\"≦\",\"lEg\":\"⪋\",\"lHar\":\"⥢\",\"lacute\":\"ĺ\",\"laemptyv\":\"⦴\",\"lagran\":\"ℒ\",\"lambda\":\"λ\",\"lang\":\"⟨\",\"langd\":\"⦑\",\"langle\":\"⟨\",\"lap\":\"⪅\",\"laqu\":\"«\",\"laquo\":\"«\",\"larr\":\"←\",\"larrb\":\"⇤\",\"larrbfs\":\"⤟\",\"larrfs\":\"⤝\",\"larrhk\":\"↩\",\"larrlp\":\"↫\",\"larrpl\":\"⤹\",\"larrsim\":\"⥳\",\"larrtl\":\"↢\",\"lat\":\"⪫\",\"latail\":\"⤙\",\"late\":\"⪭\",\"lates\":\"⪭︀\",\"lbarr\":\"⤌\",\"lbbrk\":\"❲\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"⦋\",\"lbrksld\":\"⦏\",\"lbrkslu\":\"⦍\",\"lcaron\":\"ľ\",\"lcedil\":\"ļ\",\"lceil\":\"⌈\",\"lcub\":\"{\",\"lcy\":\"л\",\"ldca\":\"⤶\",\"ldquo\":\"“\",\"ldquor\":\"„\",\"ldrdhar\":\"⥧\",\"ldrushar\":\"⥋\",\"ldsh\":\"↲\",\"le\":\"≤\",\"leftarrow\":\"←\",\"leftarrowtail\":\"↢\",\"leftharpoondown\":\"↽\",\"leftharpoonup\":\"↼\",\"leftleftarrows\":\"⇇\",\"leftrightarrow\":\"↔\",\"leftrightarrows\":\"⇆\",\"leftrightharpoons\":\"⇋\",\"leftrightsquigarrow\":\"↭\",\"leftthreetimes\":\"⋋\",\"leg\":\"⋚\",\"leq\":\"≤\",\"leqq\":\"≦\",\"leqslant\":\"⩽\",\"les\":\"⩽\",\"lescc\":\"⪨\",\"lesdot\":\"⩿\",\"lesdoto\":\"⪁\",\"lesdotor\":\"⪃\",\"lesg\":\"⋚︀\",\"lesges\":\"⪓\",\"lessapprox\":\"⪅\",\"lessdot\":\"⋖\",\"lesseqgtr\":\"⋚\",\"lesseqqgtr\":\"⪋\",\"lessgtr\":\"≶\",\"lesssim\":\"≲\",\"lfisht\":\"⥼\",\"lfloor\":\"⌊\",\"lfr\":\"𝔩\",\"lg\":\"≶\",\"lgE\":\"⪑\",\"lhard\":\"↽\",\"lharu\":\"↼\",\"lharul\":\"⥪\",\"lhblk\":\"▄\",\"ljcy\":\"љ\",\"ll\":\"≪\",\"llarr\":\"⇇\",\"llcorner\":\"⌞\",\"llhard\":\"⥫\",\"lltri\":\"◺\",\"lmidot\":\"ŀ\",\"lmoust\":\"⎰\",\"lmoustache\":\"⎰\",\"lnE\":\"≨\",\"lnap\":\"⪉\",\"lnapprox\":\"⪉\",\"lne\":\"⪇\",\"lneq\":\"⪇\",\"lneqq\":\"≨\",\"lnsim\":\"⋦\",\"loang\":\"⟬\",\"loarr\":\"⇽\",\"lobrk\":\"⟦\",\"longleftarrow\":\"⟵\",\"longleftrightarrow\":\"⟷\",\"longmapsto\":\"⟼\",\"longrightarrow\":\"⟶\",\"looparrowleft\":\"↫\",\"looparrowright\":\"↬\",\"lopar\":\"⦅\",\"lopf\":\"𝕝\",\"loplus\":\"⨭\",\"lotimes\":\"⨴\",\"lowast\":\"∗\",\"lowbar\":\"_\",\"loz\":\"◊\",\"lozenge\":\"◊\",\"lozf\":\"⧫\",\"lpar\":\"(\",\"lparlt\":\"⦓\",\"lrarr\":\"⇆\",\"lrcorner\":\"⌟\",\"lrhar\":\"⇋\",\"lrhard\":\"⥭\",\"lrm\":\"‎\",\"lrtri\":\"⊿\",\"lsaquo\":\"‹\",\"lscr\":\"𝓁\",\"lsh\":\"↰\",\"lsim\":\"≲\",\"lsime\":\"⪍\",\"lsimg\":\"⪏\",\"lsqb\":\"[\",\"lsquo\":\"‘\",\"lsquor\":\"‚\",\"lstrok\":\"ł\",\"l\":\"<\",\"lt\":\"<\",\"ltcc\":\"⪦\",\"ltcir\":\"⩹\",\"ltdot\":\"⋖\",\"lthree\":\"⋋\",\"ltimes\":\"⋉\",\"ltlarr\":\"⥶\",\"ltquest\":\"⩻\",\"ltrPar\":\"⦖\",\"ltri\":\"◃\",\"ltrie\":\"⊴\",\"ltrif\":\"◂\",\"lurdshar\":\"⥊\",\"luruhar\":\"⥦\",\"lvertneqq\":\"≨︀\",\"lvnE\":\"≨︀\",\"mDDot\":\"∺\",\"mac\":\"¯\",\"macr\":\"¯\",\"male\":\"♂\",\"malt\":\"✠\",\"maltese\":\"✠\",\"map\":\"↦\",\"mapsto\":\"↦\",\"mapstodown\":\"↧\",\"mapstoleft\":\"↤\",\"mapstoup\":\"↥\",\"marker\":\"▮\",\"mcomma\":\"⨩\",\"mcy\":\"м\",\"mdash\":\"—\",\"measuredangle\":\"∡\",\"mfr\":\"𝔪\",\"mho\":\"℧\",\"micr\":\"µ\",\"micro\":\"µ\",\"mid\":\"∣\",\"midast\":\"*\",\"midcir\":\"⫰\",\"middo\":\"·\",\"middot\":\"·\",\"minus\":\"−\",\"minusb\":\"⊟\",\"minusd\":\"∸\",\"minusdu\":\"⨪\",\"mlcp\":\"⫛\",\"mldr\":\"…\",\"mnplus\":\"∓\",\"models\":\"⊧\",\"mopf\":\"𝕞\",\"mp\":\"∓\",\"mscr\":\"𝓂\",\"mstpos\":\"∾\",\"mu\":\"μ\",\"multimap\":\"⊸\",\"mumap\":\"⊸\",\"nGg\":\"⋙̸\",\"nGt\":\"≫⃒\",\"nGtv\":\"≫̸\",\"nLeftarrow\":\"⇍\",\"nLeftrightarrow\":\"⇎\",\"nLl\":\"⋘̸\",\"nLt\":\"≪⃒\",\"nLtv\":\"≪̸\",\"nRightarrow\":\"⇏\",\"nVDash\":\"⊯\",\"nVdash\":\"⊮\",\"nabla\":\"∇\",\"nacute\":\"ń\",\"nang\":\"∠⃒\",\"nap\":\"≉\",\"napE\":\"⩰̸\",\"napid\":\"≋̸\",\"napos\":\"ŉ\",\"napprox\":\"≉\",\"natur\":\"♮\",\"natural\":\"♮\",\"naturals\":\"ℕ\",\"nbs\":\" \",\"nbsp\":\" \",\"nbump\":\"≎̸\",\"nbumpe\":\"≏̸\",\"ncap\":\"⩃\",\"ncaron\":\"ň\",\"ncedil\":\"ņ\",\"ncong\":\"≇\",\"ncongdot\":\"⩭̸\",\"ncup\":\"⩂\",\"ncy\":\"н\",\"ndash\":\"–\",\"ne\":\"≠\",\"neArr\":\"⇗\",\"nearhk\":\"⤤\",\"nearr\":\"↗\",\"nearrow\":\"↗\",\"nedot\":\"≐̸\",\"nequiv\":\"≢\",\"nesear\":\"⤨\",\"nesim\":\"≂̸\",\"nexist\":\"∄\",\"nexists\":\"∄\",\"nfr\":\"𝔫\",\"ngE\":\"≧̸\",\"nge\":\"≱\",\"ngeq\":\"≱\",\"ngeqq\":\"≧̸\",\"ngeqslant\":\"⩾̸\",\"nges\":\"⩾̸\",\"ngsim\":\"≵\",\"ngt\":\"≯\",\"ngtr\":\"≯\",\"nhArr\":\"⇎\",\"nharr\":\"↮\",\"nhpar\":\"⫲\",\"ni\":\"∋\",\"nis\":\"⋼\",\"nisd\":\"⋺\",\"niv\":\"∋\",\"njcy\":\"њ\",\"nlArr\":\"⇍\",\"nlE\":\"≦̸\",\"nlarr\":\"↚\",\"nldr\":\"‥\",\"nle\":\"≰\",\"nleftarrow\":\"↚\",\"nleftrightarrow\":\"↮\",\"nleq\":\"≰\",\"nleqq\":\"≦̸\",\"nleqslant\":\"⩽̸\",\"nles\":\"⩽̸\",\"nless\":\"≮\",\"nlsim\":\"≴\",\"nlt\":\"≮\",\"nltri\":\"⋪\",\"nltrie\":\"⋬\",\"nmid\":\"∤\",\"nopf\":\"𝕟\",\"no\":\"¬\",\"not\":\"¬\",\"notin\":\"∉\",\"notinE\":\"⋹̸\",\"notindot\":\"⋵̸\",\"notinva\":\"∉\",\"notinvb\":\"⋷\",\"notinvc\":\"⋶\",\"notni\":\"∌\",\"notniva\":\"∌\",\"notnivb\":\"⋾\",\"notnivc\":\"⋽\",\"npar\":\"∦\",\"nparallel\":\"∦\",\"nparsl\":\"⫽⃥\",\"npart\":\"∂̸\",\"npolint\":\"⨔\",\"npr\":\"⊀\",\"nprcue\":\"⋠\",\"npre\":\"⪯̸\",\"nprec\":\"⊀\",\"npreceq\":\"⪯̸\",\"nrArr\":\"⇏\",\"nrarr\":\"↛\",\"nrarrc\":\"⤳̸\",\"nrarrw\":\"↝̸\",\"nrightarrow\":\"↛\",\"nrtri\":\"⋫\",\"nrtrie\":\"⋭\",\"nsc\":\"⊁\",\"nsccue\":\"⋡\",\"nsce\":\"⪰̸\",\"nscr\":\"𝓃\",\"nshortmid\":\"∤\",\"nshortparallel\":\"∦\",\"nsim\":\"≁\",\"nsime\":\"≄\",\"nsimeq\":\"≄\",\"nsmid\":\"∤\",\"nspar\":\"∦\",\"nsqsube\":\"⋢\",\"nsqsupe\":\"⋣\",\"nsub\":\"⊄\",\"nsubE\":\"⫅̸\",\"nsube\":\"⊈\",\"nsubset\":\"⊂⃒\",\"nsubseteq\":\"⊈\",\"nsubseteqq\":\"⫅̸\",\"nsucc\":\"⊁\",\"nsucceq\":\"⪰̸\",\"nsup\":\"⊅\",\"nsupE\":\"⫆̸\",\"nsupe\":\"⊉\",\"nsupset\":\"⊃⃒\",\"nsupseteq\":\"⊉\",\"nsupseteqq\":\"⫆̸\",\"ntgl\":\"≹\",\"ntild\":\"ñ\",\"ntilde\":\"ñ\",\"ntlg\":\"≸\",\"ntriangleleft\":\"⋪\",\"ntrianglelefteq\":\"⋬\",\"ntriangleright\":\"⋫\",\"ntrianglerighteq\":\"⋭\",\"nu\":\"ν\",\"num\":\"#\",\"numero\":\"№\",\"numsp\":\" \",\"nvDash\":\"⊭\",\"nvHarr\":\"⤄\",\"nvap\":\"≍⃒\",\"nvdash\":\"⊬\",\"nvge\":\"≥⃒\",\"nvgt\":\">⃒\",\"nvinfin\":\"⧞\",\"nvlArr\":\"⤂\",\"nvle\":\"≤⃒\",\"nvlt\":\"<⃒\",\"nvltrie\":\"⊴⃒\",\"nvrArr\":\"⤃\",\"nvrtrie\":\"⊵⃒\",\"nvsim\":\"∼⃒\",\"nwArr\":\"⇖\",\"nwarhk\":\"⤣\",\"nwarr\":\"↖\",\"nwarrow\":\"↖\",\"nwnear\":\"⤧\",\"oS\":\"Ⓢ\",\"oacut\":\"ó\",\"oacute\":\"ó\",\"oast\":\"⊛\",\"ocir\":\"ô\",\"ocirc\":\"ô\",\"ocy\":\"о\",\"odash\":\"⊝\",\"odblac\":\"ő\",\"odiv\":\"⨸\",\"odot\":\"⊙\",\"odsold\":\"⦼\",\"oelig\":\"œ\",\"ofcir\":\"⦿\",\"ofr\":\"𝔬\",\"ogon\":\"˛\",\"ograv\":\"ò\",\"ograve\":\"ò\",\"ogt\":\"⧁\",\"ohbar\":\"⦵\",\"ohm\":\"Ω\",\"oint\":\"∮\",\"olarr\":\"↺\",\"olcir\":\"⦾\",\"olcross\":\"⦻\",\"oline\":\"‾\",\"olt\":\"⧀\",\"omacr\":\"ō\",\"omega\":\"ω\",\"omicron\":\"ο\",\"omid\":\"⦶\",\"ominus\":\"⊖\",\"oopf\":\"𝕠\",\"opar\":\"⦷\",\"operp\":\"⦹\",\"oplus\":\"⊕\",\"or\":\"∨\",\"orarr\":\"↻\",\"ord\":\"º\",\"order\":\"ℴ\",\"orderof\":\"ℴ\",\"ordf\":\"ª\",\"ordm\":\"º\",\"origof\":\"⊶\",\"oror\":\"⩖\",\"orslope\":\"⩗\",\"orv\":\"⩛\",\"oscr\":\"ℴ\",\"oslas\":\"ø\",\"oslash\":\"ø\",\"osol\":\"⊘\",\"otild\":\"õ\",\"otilde\":\"õ\",\"otimes\":\"⊗\",\"otimesas\":\"⨶\",\"oum\":\"ö\",\"ouml\":\"ö\",\"ovbar\":\"⌽\",\"par\":\"¶\",\"para\":\"¶\",\"parallel\":\"∥\",\"parsim\":\"⫳\",\"parsl\":\"⫽\",\"part\":\"∂\",\"pcy\":\"п\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"‰\",\"perp\":\"⊥\",\"pertenk\":\"‱\",\"pfr\":\"𝔭\",\"phi\":\"φ\",\"phiv\":\"ϕ\",\"phmmat\":\"ℳ\",\"phone\":\"☎\",\"pi\":\"π\",\"pitchfork\":\"⋔\",\"piv\":\"ϖ\",\"planck\":\"ℏ\",\"planckh\":\"ℎ\",\"plankv\":\"ℏ\",\"plus\":\"+\",\"plusacir\":\"⨣\",\"plusb\":\"⊞\",\"pluscir\":\"⨢\",\"plusdo\":\"∔\",\"plusdu\":\"⨥\",\"pluse\":\"⩲\",\"plusm\":\"±\",\"plusmn\":\"±\",\"plussim\":\"⨦\",\"plustwo\":\"⨧\",\"pm\":\"±\",\"pointint\":\"⨕\",\"popf\":\"𝕡\",\"poun\":\"£\",\"pound\":\"£\",\"pr\":\"≺\",\"prE\":\"⪳\",\"prap\":\"⪷\",\"prcue\":\"≼\",\"pre\":\"⪯\",\"prec\":\"≺\",\"precapprox\":\"⪷\",\"preccurlyeq\":\"≼\",\"preceq\":\"⪯\",\"precnapprox\":\"⪹\",\"precneqq\":\"⪵\",\"precnsim\":\"⋨\",\"precsim\":\"≾\",\"prime\":\"′\",\"primes\":\"ℙ\",\"prnE\":\"⪵\",\"prnap\":\"⪹\",\"prnsim\":\"⋨\",\"prod\":\"∏\",\"profalar\":\"⌮\",\"profline\":\"⌒\",\"profsurf\":\"⌓\",\"prop\":\"∝\",\"propto\":\"∝\",\"prsim\":\"≾\",\"prurel\":\"⊰\",\"pscr\":\"𝓅\",\"psi\":\"ψ\",\"puncsp\":\" \",\"qfr\":\"𝔮\",\"qint\":\"⨌\",\"qopf\":\"𝕢\",\"qprime\":\"⁗\",\"qscr\":\"𝓆\",\"quaternions\":\"ℍ\",\"quatint\":\"⨖\",\"quest\":\"?\",\"questeq\":\"≟\",\"quo\":\"\\\"\",\"quot\":\"\\\"\",\"rAarr\":\"⇛\",\"rArr\":\"⇒\",\"rAtail\":\"⤜\",\"rBarr\":\"⤏\",\"rHar\":\"⥤\",\"race\":\"∽̱\",\"racute\":\"ŕ\",\"radic\":\"√\",\"raemptyv\":\"⦳\",\"rang\":\"⟩\",\"rangd\":\"⦒\",\"range\":\"⦥\",\"rangle\":\"⟩\",\"raqu\":\"»\",\"raquo\":\"»\",\"rarr\":\"→\",\"rarrap\":\"⥵\",\"rarrb\":\"⇥\",\"rarrbfs\":\"⤠\",\"rarrc\":\"⤳\",\"rarrfs\":\"⤞\",\"rarrhk\":\"↪\",\"rarrlp\":\"↬\",\"rarrpl\":\"⥅\",\"rarrsim\":\"⥴\",\"rarrtl\":\"↣\",\"rarrw\":\"↝\",\"ratail\":\"⤚\",\"ratio\":\"∶\",\"rationals\":\"ℚ\",\"rbarr\":\"⤍\",\"rbbrk\":\"❳\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"⦌\",\"rbrksld\":\"⦎\",\"rbrkslu\":\"⦐\",\"rcaron\":\"ř\",\"rcedil\":\"ŗ\",\"rceil\":\"⌉\",\"rcub\":\"}\",\"rcy\":\"р\",\"rdca\":\"⤷\",\"rdldhar\":\"⥩\",\"rdquo\":\"”\",\"rdquor\":\"”\",\"rdsh\":\"↳\",\"real\":\"ℜ\",\"realine\":\"ℛ\",\"realpart\":\"ℜ\",\"reals\":\"ℝ\",\"rect\":\"▭\",\"re\":\"®\",\"reg\":\"®\",\"rfisht\":\"⥽\",\"rfloor\":\"⌋\",\"rfr\":\"𝔯\",\"rhard\":\"⇁\",\"rharu\":\"⇀\",\"rharul\":\"⥬\",\"rho\":\"ρ\",\"rhov\":\"ϱ\",\"rightarrow\":\"→\",\"rightarrowtail\":\"↣\",\"rightharpoondown\":\"⇁\",\"rightharpoonup\":\"⇀\",\"rightleftarrows\":\"⇄\",\"rightleftharpoons\":\"⇌\",\"rightrightarrows\":\"⇉\",\"rightsquigarrow\":\"↝\",\"rightthreetimes\":\"⋌\",\"ring\":\"˚\",\"risingdotseq\":\"≓\",\"rlarr\":\"⇄\",\"rlhar\":\"⇌\",\"rlm\":\"‏\",\"rmoust\":\"⎱\",\"rmoustache\":\"⎱\",\"rnmid\":\"⫮\",\"roang\":\"⟭\",\"roarr\":\"⇾\",\"robrk\":\"⟧\",\"ropar\":\"⦆\",\"ropf\":\"𝕣\",\"roplus\":\"⨮\",\"rotimes\":\"⨵\",\"rpar\":\")\",\"rpargt\":\"⦔\",\"rppolint\":\"⨒\",\"rrarr\":\"⇉\",\"rsaquo\":\"›\",\"rscr\":\"𝓇\",\"rsh\":\"↱\",\"rsqb\":\"]\",\"rsquo\":\"’\",\"rsquor\":\"’\",\"rthree\":\"⋌\",\"rtimes\":\"⋊\",\"rtri\":\"▹\",\"rtrie\":\"⊵\",\"rtrif\":\"▸\",\"rtriltri\":\"⧎\",\"ruluhar\":\"⥨\",\"rx\":\"℞\",\"sacute\":\"ś\",\"sbquo\":\"‚\",\"sc\":\"≻\",\"scE\":\"⪴\",\"scap\":\"⪸\",\"scaron\":\"š\",\"sccue\":\"≽\",\"sce\":\"⪰\",\"scedil\":\"ş\",\"scirc\":\"ŝ\",\"scnE\":\"⪶\",\"scnap\":\"⪺\",\"scnsim\":\"⋩\",\"scpolint\":\"⨓\",\"scsim\":\"≿\",\"scy\":\"с\",\"sdot\":\"⋅\",\"sdotb\":\"⊡\",\"sdote\":\"⩦\",\"seArr\":\"⇘\",\"searhk\":\"⤥\",\"searr\":\"↘\",\"searrow\":\"↘\",\"sec\":\"§\",\"sect\":\"§\",\"semi\":\";\",\"seswar\":\"⤩\",\"setminus\":\"∖\",\"setmn\":\"∖\",\"sext\":\"✶\",\"sfr\":\"𝔰\",\"sfrown\":\"⌢\",\"sharp\":\"♯\",\"shchcy\":\"щ\",\"shcy\":\"ш\",\"shortmid\":\"∣\",\"shortparallel\":\"∥\",\"sh\":\"­\",\"shy\":\"­\",\"sigma\":\"σ\",\"sigmaf\":\"ς\",\"sigmav\":\"ς\",\"sim\":\"∼\",\"simdot\":\"⩪\",\"sime\":\"≃\",\"simeq\":\"≃\",\"simg\":\"⪞\",\"simgE\":\"⪠\",\"siml\":\"⪝\",\"simlE\":\"⪟\",\"simne\":\"≆\",\"simplus\":\"⨤\",\"simrarr\":\"⥲\",\"slarr\":\"←\",\"smallsetminus\":\"∖\",\"smashp\":\"⨳\",\"smeparsl\":\"⧤\",\"smid\":\"∣\",\"smile\":\"⌣\",\"smt\":\"⪪\",\"smte\":\"⪬\",\"smtes\":\"⪬︀\",\"softcy\":\"ь\",\"sol\":\"/\",\"solb\":\"⧄\",\"solbar\":\"⌿\",\"sopf\":\"𝕤\",\"spades\":\"♠\",\"spadesuit\":\"♠\",\"spar\":\"∥\",\"sqcap\":\"⊓\",\"sqcaps\":\"⊓︀\",\"sqcup\":\"⊔\",\"sqcups\":\"⊔︀\",\"sqsub\":\"⊏\",\"sqsube\":\"⊑\",\"sqsubset\":\"⊏\",\"sqsubseteq\":\"⊑\",\"sqsup\":\"⊐\",\"sqsupe\":\"⊒\",\"sqsupset\":\"⊐\",\"sqsupseteq\":\"⊒\",\"squ\":\"□\",\"square\":\"□\",\"squarf\":\"▪\",\"squf\":\"▪\",\"srarr\":\"→\",\"sscr\":\"𝓈\",\"ssetmn\":\"∖\",\"ssmile\":\"⌣\",\"sstarf\":\"⋆\",\"star\":\"☆\",\"starf\":\"★\",\"straightepsilon\":\"ϵ\",\"straightphi\":\"ϕ\",\"strns\":\"¯\",\"sub\":\"⊂\",\"subE\":\"⫅\",\"subdot\":\"⪽\",\"sube\":\"⊆\",\"subedot\":\"⫃\",\"submult\":\"⫁\",\"subnE\":\"⫋\",\"subne\":\"⊊\",\"subplus\":\"⪿\",\"subrarr\":\"⥹\",\"subset\":\"⊂\",\"subseteq\":\"⊆\",\"subseteqq\":\"⫅\",\"subsetneq\":\"⊊\",\"subsetneqq\":\"⫋\",\"subsim\":\"⫇\",\"subsub\":\"⫕\",\"subsup\":\"⫓\",\"succ\":\"≻\",\"succapprox\":\"⪸\",\"succcurlyeq\":\"≽\",\"succeq\":\"⪰\",\"succnapprox\":\"⪺\",\"succneqq\":\"⪶\",\"succnsim\":\"⋩\",\"succsim\":\"≿\",\"sum\":\"∑\",\"sung\":\"♪\",\"sup\":\"⊃\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"supE\":\"⫆\",\"supdot\":\"⪾\",\"supdsub\":\"⫘\",\"supe\":\"⊇\",\"supedot\":\"⫄\",\"suphsol\":\"⟉\",\"suphsub\":\"⫗\",\"suplarr\":\"⥻\",\"supmult\":\"⫂\",\"supnE\":\"⫌\",\"supne\":\"⊋\",\"supplus\":\"⫀\",\"supset\":\"⊃\",\"supseteq\":\"⊇\",\"supseteqq\":\"⫆\",\"supsetneq\":\"⊋\",\"supsetneqq\":\"⫌\",\"supsim\":\"⫈\",\"supsub\":\"⫔\",\"supsup\":\"⫖\",\"swArr\":\"⇙\",\"swarhk\":\"⤦\",\"swarr\":\"↙\",\"swarrow\":\"↙\",\"swnwar\":\"⤪\",\"szli\":\"ß\",\"szlig\":\"ß\",\"target\":\"⌖\",\"tau\":\"τ\",\"tbrk\":\"⎴\",\"tcaron\":\"ť\",\"tcedil\":\"ţ\",\"tcy\":\"т\",\"tdot\":\"⃛\",\"telrec\":\"⌕\",\"tfr\":\"𝔱\",\"there4\":\"∴\",\"therefore\":\"∴\",\"theta\":\"θ\",\"thetasym\":\"ϑ\",\"thetav\":\"ϑ\",\"thickapprox\":\"≈\",\"thicksim\":\"∼\",\"thinsp\":\" \",\"thkap\":\"≈\",\"thksim\":\"∼\",\"thor\":\"þ\",\"thorn\":\"þ\",\"tilde\":\"˜\",\"time\":\"×\",\"times\":\"×\",\"timesb\":\"⊠\",\"timesbar\":\"⨱\",\"timesd\":\"⨰\",\"tint\":\"∭\",\"toea\":\"⤨\",\"top\":\"⊤\",\"topbot\":\"⌶\",\"topcir\":\"⫱\",\"topf\":\"𝕥\",\"topfork\":\"⫚\",\"tosa\":\"⤩\",\"tprime\":\"‴\",\"trade\":\"™\",\"triangle\":\"▵\",\"triangledown\":\"▿\",\"triangleleft\":\"◃\",\"trianglelefteq\":\"⊴\",\"triangleq\":\"≜\",\"triangleright\":\"▹\",\"trianglerighteq\":\"⊵\",\"tridot\":\"◬\",\"trie\":\"≜\",\"triminus\":\"⨺\",\"triplus\":\"⨹\",\"trisb\":\"⧍\",\"tritime\":\"⨻\",\"trpezium\":\"⏢\",\"tscr\":\"𝓉\",\"tscy\":\"ц\",\"tshcy\":\"ћ\",\"tstrok\":\"ŧ\",\"twixt\":\"≬\",\"twoheadleftarrow\":\"↞\",\"twoheadrightarrow\":\"↠\",\"uArr\":\"⇑\",\"uHar\":\"⥣\",\"uacut\":\"ú\",\"uacute\":\"ú\",\"uarr\":\"↑\",\"ubrcy\":\"ў\",\"ubreve\":\"ŭ\",\"ucir\":\"û\",\"ucirc\":\"û\",\"ucy\":\"у\",\"udarr\":\"⇅\",\"udblac\":\"ű\",\"udhar\":\"⥮\",\"ufisht\":\"⥾\",\"ufr\":\"𝔲\",\"ugrav\":\"ù\",\"ugrave\":\"ù\",\"uharl\":\"↿\",\"uharr\":\"↾\",\"uhblk\":\"▀\",\"ulcorn\":\"⌜\",\"ulcorner\":\"⌜\",\"ulcrop\":\"⌏\",\"ultri\":\"◸\",\"umacr\":\"ū\",\"um\":\"¨\",\"uml\":\"¨\",\"uogon\":\"ų\",\"uopf\":\"𝕦\",\"uparrow\":\"↑\",\"updownarrow\":\"↕\",\"upharpoonleft\":\"↿\",\"upharpoonright\":\"↾\",\"uplus\":\"⊎\",\"upsi\":\"υ\",\"upsih\":\"ϒ\",\"upsilon\":\"υ\",\"upuparrows\":\"⇈\",\"urcorn\":\"⌝\",\"urcorner\":\"⌝\",\"urcrop\":\"⌎\",\"uring\":\"ů\",\"urtri\":\"◹\",\"uscr\":\"𝓊\",\"utdot\":\"⋰\",\"utilde\":\"ũ\",\"utri\":\"▵\",\"utrif\":\"▴\",\"uuarr\":\"⇈\",\"uum\":\"ü\",\"uuml\":\"ü\",\"uwangle\":\"⦧\",\"vArr\":\"⇕\",\"vBar\":\"⫨\",\"vBarv\":\"⫩\",\"vDash\":\"⊨\",\"vangrt\":\"⦜\",\"varepsilon\":\"ϵ\",\"varkappa\":\"ϰ\",\"varnothing\":\"∅\",\"varphi\":\"ϕ\",\"varpi\":\"ϖ\",\"varpropto\":\"∝\",\"varr\":\"↕\",\"varrho\":\"ϱ\",\"varsigma\":\"ς\",\"varsubsetneq\":\"⊊︀\",\"varsubsetneqq\":\"⫋︀\",\"varsupsetneq\":\"⊋︀\",\"varsupsetneqq\":\"⫌︀\",\"vartheta\":\"ϑ\",\"vartriangleleft\":\"⊲\",\"vartriangleright\":\"⊳\",\"vcy\":\"в\",\"vdash\":\"⊢\",\"vee\":\"∨\",\"veebar\":\"⊻\",\"veeeq\":\"≚\",\"vellip\":\"⋮\",\"verbar\":\"|\",\"vert\":\"|\",\"vfr\":\"𝔳\",\"vltri\":\"⊲\",\"vnsub\":\"⊂⃒\",\"vnsup\":\"⊃⃒\",\"vopf\":\"𝕧\",\"vprop\":\"∝\",\"vrtri\":\"⊳\",\"vscr\":\"𝓋\",\"vsubnE\":\"⫋︀\",\"vsubne\":\"⊊︀\",\"vsupnE\":\"⫌︀\",\"vsupne\":\"⊋︀\",\"vzigzag\":\"⦚\",\"wcirc\":\"ŵ\",\"wedbar\":\"⩟\",\"wedge\":\"∧\",\"wedgeq\":\"≙\",\"weierp\":\"℘\",\"wfr\":\"𝔴\",\"wopf\":\"𝕨\",\"wp\":\"℘\",\"wr\":\"≀\",\"wreath\":\"≀\",\"wscr\":\"𝓌\",\"xcap\":\"⋂\",\"xcirc\":\"◯\",\"xcup\":\"⋃\",\"xdtri\":\"▽\",\"xfr\":\"𝔵\",\"xhArr\":\"⟺\",\"xharr\":\"⟷\",\"xi\":\"ξ\",\"xlArr\":\"⟸\",\"xlarr\":\"⟵\",\"xmap\":\"⟼\",\"xnis\":\"⋻\",\"xodot\":\"⨀\",\"xopf\":\"𝕩\",\"xoplus\":\"⨁\",\"xotime\":\"⨂\",\"xrArr\":\"⟹\",\"xrarr\":\"⟶\",\"xscr\":\"𝓍\",\"xsqcup\":\"⨆\",\"xuplus\":\"⨄\",\"xutri\":\"△\",\"xvee\":\"⋁\",\"xwedge\":\"⋀\",\"yacut\":\"ý\",\"yacute\":\"ý\",\"yacy\":\"я\",\"ycirc\":\"ŷ\",\"ycy\":\"ы\",\"ye\":\"¥\",\"yen\":\"¥\",\"yfr\":\"𝔶\",\"yicy\":\"ї\",\"yopf\":\"𝕪\",\"yscr\":\"𝓎\",\"yucy\":\"ю\",\"yum\":\"ÿ\",\"yuml\":\"ÿ\",\"zacute\":\"ź\",\"zcaron\":\"ž\",\"zcy\":\"з\",\"zdot\":\"ż\",\"zeetrf\":\"ℨ\",\"zeta\":\"ζ\",\"zfr\":\"𝔷\",\"zhcy\":\"ж\",\"zigrarr\":\"⇝\",\"zopf\":\"𝕫\",\"zscr\":\"𝓏\",\"zwj\":\"‍\",\"zwnj\":\"‌\"}");

/***/ }),

/***/ 1608:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("{\"af\":{\"and\":[\"* \",\"En \"],\"background\":[\"Agtergrond\"],\"but\":[\"* \",\"Maar \"],\"examples\":[\"Voorbeelde\"],\"feature\":[\"Funksie\",\"Besigheid Behoefte\",\"Vermoë\"],\"given\":[\"* \",\"Gegewe \"],\"name\":\"Afrikaans\",\"native\":\"Afrikaans\",\"rule\":[\"Rule\"],\"scenario\":[\"Voorbeeld\",\"Situasie\"],\"scenarioOutline\":[\"Situasie Uiteensetting\"],\"then\":[\"* \",\"Dan \"],\"when\":[\"* \",\"Wanneer \"]},\"am\":{\"and\":[\"* \",\"Եվ \"],\"background\":[\"Կոնտեքստ\"],\"but\":[\"* \",\"Բայց \"],\"examples\":[\"Օրինակներ\"],\"feature\":[\"Ֆունկցիոնալություն\",\"Հատկություն\"],\"given\":[\"* \",\"Դիցուք \"],\"name\":\"Armenian\",\"native\":\"հայերեն\",\"rule\":[\"Rule\"],\"scenario\":[\"Օրինակ\",\"Սցենար\"],\"scenarioOutline\":[\"Սցենարի կառուցվացքը\"],\"then\":[\"* \",\"Ապա \"],\"when\":[\"* \",\"Եթե \",\"Երբ \"]},\"an\":{\"and\":[\"* \",\"Y \",\"E \"],\"background\":[\"Antecedents\"],\"but\":[\"* \",\"Pero \"],\"examples\":[\"Eixemplos\"],\"feature\":[\"Caracteristica\"],\"given\":[\"* \",\"Dau \",\"Dada \",\"Daus \",\"Dadas \"],\"name\":\"Aragonese\",\"native\":\"Aragonés\",\"rule\":[\"Rule\"],\"scenario\":[\"Eixemplo\",\"Caso\"],\"scenarioOutline\":[\"Esquema del caso\"],\"then\":[\"* \",\"Alavez \",\"Allora \",\"Antonces \"],\"when\":[\"* \",\"Cuan \"]},\"ar\":{\"and\":[\"* \",\"و \"],\"background\":[\"الخلفية\"],\"but\":[\"* \",\"لكن \"],\"examples\":[\"امثلة\"],\"feature\":[\"خاصية\"],\"given\":[\"* \",\"بفرض \"],\"name\":\"Arabic\",\"native\":\"العربية\",\"rule\":[\"Rule\"],\"scenario\":[\"مثال\",\"سيناريو\"],\"scenarioOutline\":[\"سيناريو مخطط\"],\"then\":[\"* \",\"اذاً \",\"ثم \"],\"when\":[\"* \",\"متى \",\"عندما \"]},\"ast\":{\"and\":[\"* \",\"Y \",\"Ya \"],\"background\":[\"Antecedentes\"],\"but\":[\"* \",\"Peru \"],\"examples\":[\"Exemplos\"],\"feature\":[\"Carauterística\"],\"given\":[\"* \",\"Dáu \",\"Dada \",\"Daos \",\"Daes \"],\"name\":\"Asturian\",\"native\":\"asturianu\",\"rule\":[\"Rule\"],\"scenario\":[\"Exemplo\",\"Casu\"],\"scenarioOutline\":[\"Esbozu del casu\"],\"then\":[\"* \",\"Entós \"],\"when\":[\"* \",\"Cuando \"]},\"az\":{\"and\":[\"* \",\"Və \",\"Həm \"],\"background\":[\"Keçmiş\",\"Kontekst\"],\"but\":[\"* \",\"Amma \",\"Ancaq \"],\"examples\":[\"Nümunələr\"],\"feature\":[\"Özəllik\"],\"given\":[\"* \",\"Tutaq ki \",\"Verilir \"],\"name\":\"Azerbaijani\",\"native\":\"Azərbaycanca\",\"rule\":[\"Rule\"],\"scenario\":[\"Nümunə\",\"Ssenari\"],\"scenarioOutline\":[\"Ssenarinin strukturu\"],\"then\":[\"* \",\"O halda \"],\"when\":[\"* \",\"Əgər \",\"Nə vaxt ki \"]},\"bg\":{\"and\":[\"* \",\"И \"],\"background\":[\"Предистория\"],\"but\":[\"* \",\"Но \"],\"examples\":[\"Примери\"],\"feature\":[\"Функционалност\"],\"given\":[\"* \",\"Дадено \"],\"name\":\"Bulgarian\",\"native\":\"български\",\"rule\":[\"Rule\"],\"scenario\":[\"Пример\",\"Сценарий\"],\"scenarioOutline\":[\"Рамка на сценарий\"],\"then\":[\"* \",\"То \"],\"when\":[\"* \",\"Когато \"]},\"bm\":{\"and\":[\"* \",\"Dan \"],\"background\":[\"Latar Belakang\"],\"but\":[\"* \",\"Tetapi \",\"Tapi \"],\"examples\":[\"Contoh\"],\"feature\":[\"Fungsi\"],\"given\":[\"* \",\"Diberi \",\"Bagi \"],\"name\":\"Malay\",\"native\":\"Bahasa Melayu\",\"rule\":[\"Rule\"],\"scenario\":[\"Senario\",\"Situasi\",\"Keadaan\"],\"scenarioOutline\":[\"Kerangka Senario\",\"Kerangka Situasi\",\"Kerangka Keadaan\",\"Garis Panduan Senario\"],\"then\":[\"* \",\"Maka \",\"Kemudian \"],\"when\":[\"* \",\"Apabila \"]},\"bs\":{\"and\":[\"* \",\"I \",\"A \"],\"background\":[\"Pozadina\"],\"but\":[\"* \",\"Ali \"],\"examples\":[\"Primjeri\"],\"feature\":[\"Karakteristika\"],\"given\":[\"* \",\"Dato \"],\"name\":\"Bosnian\",\"native\":\"Bosanski\",\"rule\":[\"Rule\"],\"scenario\":[\"Primjer\",\"Scenariju\",\"Scenario\"],\"scenarioOutline\":[\"Scenariju-obris\",\"Scenario-outline\"],\"then\":[\"* \",\"Zatim \"],\"when\":[\"* \",\"Kada \"]},\"ca\":{\"and\":[\"* \",\"I \"],\"background\":[\"Rerefons\",\"Antecedents\"],\"but\":[\"* \",\"Però \"],\"examples\":[\"Exemples\"],\"feature\":[\"Característica\",\"Funcionalitat\"],\"given\":[\"* \",\"Donat \",\"Donada \",\"Atès \",\"Atesa \"],\"name\":\"Catalan\",\"native\":\"català\",\"rule\":[\"Rule\"],\"scenario\":[\"Exemple\",\"Escenari\"],\"scenarioOutline\":[\"Esquema de l'escenari\"],\"then\":[\"* \",\"Aleshores \",\"Cal \"],\"when\":[\"* \",\"Quan \"]},\"cs\":{\"and\":[\"* \",\"A také \",\"A \"],\"background\":[\"Pozadí\",\"Kontext\"],\"but\":[\"* \",\"Ale \"],\"examples\":[\"Příklady\"],\"feature\":[\"Požadavek\"],\"given\":[\"* \",\"Pokud \",\"Za předpokladu \"],\"name\":\"Czech\",\"native\":\"Česky\",\"rule\":[\"Rule\"],\"scenario\":[\"Příklad\",\"Scénář\"],\"scenarioOutline\":[\"Náčrt Scénáře\",\"Osnova scénáře\"],\"then\":[\"* \",\"Pak \"],\"when\":[\"* \",\"Když \"]},\"cy-GB\":{\"and\":[\"* \",\"A \"],\"background\":[\"Cefndir\"],\"but\":[\"* \",\"Ond \"],\"examples\":[\"Enghreifftiau\"],\"feature\":[\"Arwedd\"],\"given\":[\"* \",\"Anrhegedig a \"],\"name\":\"Welsh\",\"native\":\"Cymraeg\",\"rule\":[\"Rule\"],\"scenario\":[\"Enghraifft\",\"Scenario\"],\"scenarioOutline\":[\"Scenario Amlinellol\"],\"then\":[\"* \",\"Yna \"],\"when\":[\"* \",\"Pryd \"]},\"da\":{\"and\":[\"* \",\"Og \"],\"background\":[\"Baggrund\"],\"but\":[\"* \",\"Men \"],\"examples\":[\"Eksempler\"],\"feature\":[\"Egenskab\"],\"given\":[\"* \",\"Givet \"],\"name\":\"Danish\",\"native\":\"dansk\",\"rule\":[\"Rule\"],\"scenario\":[\"Eksempel\",\"Scenarie\"],\"scenarioOutline\":[\"Abstrakt Scenario\"],\"then\":[\"* \",\"Så \"],\"when\":[\"* \",\"Når \"]},\"de\":{\"and\":[\"* \",\"Und \"],\"background\":[\"Grundlage\"],\"but\":[\"* \",\"Aber \"],\"examples\":[\"Beispiele\"],\"feature\":[\"Funktionalität\"],\"given\":[\"* \",\"Angenommen \",\"Gegeben sei \",\"Gegeben seien \"],\"name\":\"German\",\"native\":\"Deutsch\",\"rule\":[\"Rule\"],\"scenario\":[\"Beispiel\",\"Szenario\"],\"scenarioOutline\":[\"Szenariogrundriss\"],\"then\":[\"* \",\"Dann \"],\"when\":[\"* \",\"Wenn \"]},\"el\":{\"and\":[\"* \",\"Και \"],\"background\":[\"Υπόβαθρο\"],\"but\":[\"* \",\"Αλλά \"],\"examples\":[\"Παραδείγματα\",\"Σενάρια\"],\"feature\":[\"Δυνατότητα\",\"Λειτουργία\"],\"given\":[\"* \",\"Δεδομένου \"],\"name\":\"Greek\",\"native\":\"Ελληνικά\",\"rule\":[\"Rule\"],\"scenario\":[\"Παράδειγμα\",\"Σενάριο\"],\"scenarioOutline\":[\"Περιγραφή Σεναρίου\",\"Περίγραμμα Σεναρίου\"],\"then\":[\"* \",\"Τότε \"],\"when\":[\"* \",\"Όταν \"]},\"em\":{\"and\":[\"* \",\"😂\"],\"background\":[\"💤\"],\"but\":[\"* \",\"😔\"],\"examples\":[\"📓\"],\"feature\":[\"📚\"],\"given\":[\"* \",\"😐\"],\"name\":\"Emoji\",\"native\":\"😀\",\"rule\":[\"Rule\"],\"scenario\":[\"🥒\",\"📕\"],\"scenarioOutline\":[\"📖\"],\"then\":[\"* \",\"🙏\"],\"when\":[\"* \",\"🎬\"]},\"en\":{\"and\":[\"* \",\"And \"],\"background\":[\"Background\"],\"but\":[\"* \",\"But \"],\"examples\":[\"Examples\",\"Scenarios\"],\"feature\":[\"Feature\",\"Business Need\",\"Ability\"],\"given\":[\"* \",\"Given \"],\"name\":\"English\",\"native\":\"English\",\"rule\":[\"Rule\"],\"scenario\":[\"Example\",\"Scenario\"],\"scenarioOutline\":[\"Scenario Outline\",\"Scenario Template\"],\"then\":[\"* \",\"Then \"],\"when\":[\"* \",\"When \"]},\"en-Scouse\":{\"and\":[\"* \",\"An \"],\"background\":[\"Dis is what went down\"],\"but\":[\"* \",\"Buh \"],\"examples\":[\"Examples\"],\"feature\":[\"Feature\"],\"given\":[\"* \",\"Givun \",\"Youse know when youse got \"],\"name\":\"Scouse\",\"native\":\"Scouse\",\"rule\":[\"Rule\"],\"scenario\":[\"The thing of it is\"],\"scenarioOutline\":[\"Wharrimean is\"],\"then\":[\"* \",\"Dun \",\"Den youse gotta \"],\"when\":[\"* \",\"Wun \",\"Youse know like when \"]},\"en-au\":{\"and\":[\"* \",\"Too right \"],\"background\":[\"First off\"],\"but\":[\"* \",\"Yeah nah \"],\"examples\":[\"You'll wanna\"],\"feature\":[\"Pretty much\"],\"given\":[\"* \",\"Y'know \"],\"name\":\"Australian\",\"native\":\"Australian\",\"rule\":[\"Rule\"],\"scenario\":[\"Awww, look mate\"],\"scenarioOutline\":[\"Reckon it's like\"],\"then\":[\"* \",\"But at the end of the day I reckon \"],\"when\":[\"* \",\"It's just unbelievable \"]},\"en-lol\":{\"and\":[\"* \",\"AN \"],\"background\":[\"B4\"],\"but\":[\"* \",\"BUT \"],\"examples\":[\"EXAMPLZ\"],\"feature\":[\"OH HAI\"],\"given\":[\"* \",\"I CAN HAZ \"],\"name\":\"LOLCAT\",\"native\":\"LOLCAT\",\"rule\":[\"Rule\"],\"scenario\":[\"MISHUN\"],\"scenarioOutline\":[\"MISHUN SRSLY\"],\"then\":[\"* \",\"DEN \"],\"when\":[\"* \",\"WEN \"]},\"en-old\":{\"and\":[\"* \",\"Ond \",\"7 \"],\"background\":[\"Aer\",\"Ær\"],\"but\":[\"* \",\"Ac \"],\"examples\":[\"Se the\",\"Se þe\",\"Se ðe\"],\"feature\":[\"Hwaet\",\"Hwæt\"],\"given\":[\"* \",\"Thurh \",\"Þurh \",\"Ðurh \"],\"name\":\"Old English\",\"native\":\"Englisc\",\"rule\":[\"Rule\"],\"scenario\":[\"Swa\"],\"scenarioOutline\":[\"Swa hwaer swa\",\"Swa hwær swa\"],\"then\":[\"* \",\"Tha \",\"Þa \",\"Ða \",\"Tha the \",\"Þa þe \",\"Ða ðe \"],\"when\":[\"* \",\"Tha \",\"Þa \",\"Ða \"]},\"en-pirate\":{\"and\":[\"* \",\"Aye \"],\"background\":[\"Yo-ho-ho\"],\"but\":[\"* \",\"Avast! \"],\"examples\":[\"Dead men tell no tales\"],\"feature\":[\"Ahoy matey!\"],\"given\":[\"* \",\"Gangway! \"],\"name\":\"Pirate\",\"native\":\"Pirate\",\"rule\":[\"Rule\"],\"scenario\":[\"Heave to\"],\"scenarioOutline\":[\"Shiver me timbers\"],\"then\":[\"* \",\"Let go and haul \"],\"when\":[\"* \",\"Blimey! \"]},\"eo\":{\"and\":[\"* \",\"Kaj \"],\"background\":[\"Fono\"],\"but\":[\"* \",\"Sed \"],\"examples\":[\"Ekzemploj\"],\"feature\":[\"Trajto\"],\"given\":[\"* \",\"Donitaĵo \",\"Komence \"],\"name\":\"Esperanto\",\"native\":\"Esperanto\",\"rule\":[\"Rule\"],\"scenario\":[\"Ekzemplo\",\"Scenaro\",\"Kazo\"],\"scenarioOutline\":[\"Konturo de la scenaro\",\"Skizo\",\"Kazo-skizo\"],\"then\":[\"* \",\"Do \"],\"when\":[\"* \",\"Se \"]},\"es\":{\"and\":[\"* \",\"Y \",\"E \"],\"background\":[\"Antecedentes\"],\"but\":[\"* \",\"Pero \"],\"examples\":[\"Ejemplos\"],\"feature\":[\"Característica\"],\"given\":[\"* \",\"Dado \",\"Dada \",\"Dados \",\"Dadas \"],\"name\":\"Spanish\",\"native\":\"español\",\"rule\":[\"Regla\"],\"scenario\":[\"Ejemplo\",\"Escenario\"],\"scenarioOutline\":[\"Esquema del escenario\"],\"then\":[\"* \",\"Entonces \"],\"when\":[\"* \",\"Cuando \"]},\"et\":{\"and\":[\"* \",\"Ja \"],\"background\":[\"Taust\"],\"but\":[\"* \",\"Kuid \"],\"examples\":[\"Juhtumid\"],\"feature\":[\"Omadus\"],\"given\":[\"* \",\"Eeldades \"],\"name\":\"Estonian\",\"native\":\"eesti keel\",\"rule\":[\"Rule\"],\"scenario\":[\"Juhtum\",\"Stsenaarium\"],\"scenarioOutline\":[\"Raamstjuhtum\",\"Raamstsenaarium\"],\"then\":[\"* \",\"Siis \"],\"when\":[\"* \",\"Kui \"]},\"fa\":{\"and\":[\"* \",\"و \"],\"background\":[\"زمینه\"],\"but\":[\"* \",\"اما \"],\"examples\":[\"نمونه ها\"],\"feature\":[\"وِیژگی\"],\"given\":[\"* \",\"با فرض \"],\"name\":\"Persian\",\"native\":\"فارسی\",\"rule\":[\"Rule\"],\"scenario\":[\"مثال\",\"سناریو\"],\"scenarioOutline\":[\"الگوی سناریو\"],\"then\":[\"* \",\"آنگاه \"],\"when\":[\"* \",\"هنگامی \"]},\"fi\":{\"and\":[\"* \",\"Ja \"],\"background\":[\"Tausta\"],\"but\":[\"* \",\"Mutta \"],\"examples\":[\"Tapaukset\"],\"feature\":[\"Ominaisuus\"],\"given\":[\"* \",\"Oletetaan \"],\"name\":\"Finnish\",\"native\":\"suomi\",\"rule\":[\"Rule\"],\"scenario\":[\"Tapaus\"],\"scenarioOutline\":[\"Tapausaihio\"],\"then\":[\"* \",\"Niin \"],\"when\":[\"* \",\"Kun \"]},\"fr\":{\"and\":[\"* \",\"Et que \",\"Et qu'\",\"Et \"],\"background\":[\"Contexte\"],\"but\":[\"* \",\"Mais que \",\"Mais qu'\",\"Mais \"],\"examples\":[\"Exemples\"],\"feature\":[\"Fonctionnalité\"],\"given\":[\"* \",\"Soit \",\"Sachant que \",\"Sachant qu'\",\"Sachant \",\"Etant donné que \",\"Etant donné qu'\",\"Etant donné \",\"Etant donnée \",\"Etant donnés \",\"Etant données \",\"Étant donné que \",\"Étant donné qu'\",\"Étant donné \",\"Étant donnée \",\"Étant donnés \",\"Étant données \"],\"name\":\"French\",\"native\":\"français\",\"rule\":[\"Règle\"],\"scenario\":[\"Exemple\",\"Scénario\"],\"scenarioOutline\":[\"Plan du scénario\",\"Plan du Scénario\"],\"then\":[\"* \",\"Alors \",\"Donc \"],\"when\":[\"* \",\"Quand \",\"Lorsque \",\"Lorsqu'\"]},\"ga\":{\"and\":[\"* \",\"Agus\"],\"background\":[\"Cúlra\"],\"but\":[\"* \",\"Ach\"],\"examples\":[\"Samplaí\"],\"feature\":[\"Gné\"],\"given\":[\"* \",\"Cuir i gcás go\",\"Cuir i gcás nach\",\"Cuir i gcás gur\",\"Cuir i gcás nár\"],\"name\":\"Irish\",\"native\":\"Gaeilge\",\"rule\":[\"Rule\"],\"scenario\":[\"Sampla\",\"Cás\"],\"scenarioOutline\":[\"Cás Achomair\"],\"then\":[\"* \",\"Ansin\"],\"when\":[\"* \",\"Nuair a\",\"Nuair nach\",\"Nuair ba\",\"Nuair nár\"]},\"gj\":{\"and\":[\"* \",\"અને \"],\"background\":[\"બેકગ્રાઉન્ડ\"],\"but\":[\"* \",\"પણ \"],\"examples\":[\"ઉદાહરણો\"],\"feature\":[\"લક્ષણ\",\"વ્યાપાર જરૂર\",\"ક્ષમતા\"],\"given\":[\"* \",\"આપેલ છે \"],\"name\":\"Gujarati\",\"native\":\"ગુજરાતી\",\"rule\":[\"Rule\"],\"scenario\":[\"ઉદાહરણ\",\"સ્થિતિ\"],\"scenarioOutline\":[\"પરિદ્દશ્ય રૂપરેખા\",\"પરિદ્દશ્ય ઢાંચો\"],\"then\":[\"* \",\"પછી \"],\"when\":[\"* \",\"ક્યારે \"]},\"gl\":{\"and\":[\"* \",\"E \"],\"background\":[\"Contexto\"],\"but\":[\"* \",\"Mais \",\"Pero \"],\"examples\":[\"Exemplos\"],\"feature\":[\"Característica\"],\"given\":[\"* \",\"Dado \",\"Dada \",\"Dados \",\"Dadas \"],\"name\":\"Galician\",\"native\":\"galego\",\"rule\":[\"Rule\"],\"scenario\":[\"Exemplo\",\"Escenario\"],\"scenarioOutline\":[\"Esbozo do escenario\"],\"then\":[\"* \",\"Entón \",\"Logo \"],\"when\":[\"* \",\"Cando \"]},\"he\":{\"and\":[\"* \",\"וגם \"],\"background\":[\"רקע\"],\"but\":[\"* \",\"אבל \"],\"examples\":[\"דוגמאות\"],\"feature\":[\"תכונה\"],\"given\":[\"* \",\"בהינתן \"],\"name\":\"Hebrew\",\"native\":\"עברית\",\"rule\":[\"Rule\"],\"scenario\":[\"דוגמא\",\"תרחיש\"],\"scenarioOutline\":[\"תבנית תרחיש\"],\"then\":[\"* \",\"אז \",\"אזי \"],\"when\":[\"* \",\"כאשר \"]},\"hi\":{\"and\":[\"* \",\"और \",\"तथा \"],\"background\":[\"पृष्ठभूमि\"],\"but\":[\"* \",\"पर \",\"परन्तु \",\"किन्तु \"],\"examples\":[\"उदाहरण\"],\"feature\":[\"रूप लेख\"],\"given\":[\"* \",\"अगर \",\"यदि \",\"चूंकि \"],\"name\":\"Hindi\",\"native\":\"हिंदी\",\"rule\":[\"Rule\"],\"scenario\":[\"परिदृश्य\"],\"scenarioOutline\":[\"परिदृश्य रूपरेखा\"],\"then\":[\"* \",\"तब \",\"तदा \"],\"when\":[\"* \",\"जब \",\"कदा \"]},\"hr\":{\"and\":[\"* \",\"I \"],\"background\":[\"Pozadina\"],\"but\":[\"* \",\"Ali \"],\"examples\":[\"Primjeri\",\"Scenariji\"],\"feature\":[\"Osobina\",\"Mogućnost\",\"Mogucnost\"],\"given\":[\"* \",\"Zadan \",\"Zadani \",\"Zadano \",\"Ukoliko \"],\"name\":\"Croatian\",\"native\":\"hrvatski\",\"rule\":[\"Rule\"],\"scenario\":[\"Primjer\",\"Scenarij\"],\"scenarioOutline\":[\"Skica\",\"Koncept\"],\"then\":[\"* \",\"Onda \"],\"when\":[\"* \",\"Kada \",\"Kad \"]},\"ht\":{\"and\":[\"* \",\"Ak \",\"Epi \",\"E \"],\"background\":[\"Kontèks\",\"Istorik\"],\"but\":[\"* \",\"Men \"],\"examples\":[\"Egzanp\"],\"feature\":[\"Karakteristik\",\"Mak\",\"Fonksyonalite\"],\"given\":[\"* \",\"Sipoze \",\"Sipoze ke \",\"Sipoze Ke \"],\"name\":\"Creole\",\"native\":\"kreyòl\",\"rule\":[\"Rule\"],\"scenario\":[\"Senaryo\"],\"scenarioOutline\":[\"Plan senaryo\",\"Plan Senaryo\",\"Senaryo deskripsyon\",\"Senaryo Deskripsyon\",\"Dyagram senaryo\",\"Dyagram Senaryo\"],\"then\":[\"* \",\"Lè sa a \",\"Le sa a \"],\"when\":[\"* \",\"Lè \",\"Le \"]},\"hu\":{\"and\":[\"* \",\"És \"],\"background\":[\"Háttér\"],\"but\":[\"* \",\"De \"],\"examples\":[\"Példák\"],\"feature\":[\"Jellemző\"],\"given\":[\"* \",\"Amennyiben \",\"Adott \"],\"name\":\"Hungarian\",\"native\":\"magyar\",\"rule\":[\"Rule\"],\"scenario\":[\"Példa\",\"Forgatókönyv\"],\"scenarioOutline\":[\"Forgatókönyv vázlat\"],\"then\":[\"* \",\"Akkor \"],\"when\":[\"* \",\"Majd \",\"Ha \",\"Amikor \"]},\"id\":{\"and\":[\"* \",\"Dan \"],\"background\":[\"Dasar\"],\"but\":[\"* \",\"Tapi \"],\"examples\":[\"Contoh\"],\"feature\":[\"Fitur\"],\"given\":[\"* \",\"Dengan \"],\"name\":\"Indonesian\",\"native\":\"Bahasa Indonesia\",\"rule\":[\"Rule\"],\"scenario\":[\"Skenario\"],\"scenarioOutline\":[\"Skenario konsep\"],\"then\":[\"* \",\"Maka \"],\"when\":[\"* \",\"Ketika \"]},\"is\":{\"and\":[\"* \",\"Og \"],\"background\":[\"Bakgrunnur\"],\"but\":[\"* \",\"En \"],\"examples\":[\"Dæmi\",\"Atburðarásir\"],\"feature\":[\"Eiginleiki\"],\"given\":[\"* \",\"Ef \"],\"name\":\"Icelandic\",\"native\":\"Íslenska\",\"rule\":[\"Rule\"],\"scenario\":[\"Atburðarás\"],\"scenarioOutline\":[\"Lýsing Atburðarásar\",\"Lýsing Dæma\"],\"then\":[\"* \",\"Þá \"],\"when\":[\"* \",\"Þegar \"]},\"it\":{\"and\":[\"* \",\"E \"],\"background\":[\"Contesto\"],\"but\":[\"* \",\"Ma \"],\"examples\":[\"Esempi\"],\"feature\":[\"Funzionalità\"],\"given\":[\"* \",\"Dato \",\"Data \",\"Dati \",\"Date \"],\"name\":\"Italian\",\"native\":\"italiano\",\"rule\":[\"Rule\"],\"scenario\":[\"Esempio\",\"Scenario\"],\"scenarioOutline\":[\"Schema dello scenario\"],\"then\":[\"* \",\"Allora \"],\"when\":[\"* \",\"Quando \"]},\"ja\":{\"and\":[\"* \",\"かつ\"],\"background\":[\"背景\"],\"but\":[\"* \",\"しかし\",\"但し\",\"ただし\"],\"examples\":[\"例\",\"サンプル\"],\"feature\":[\"フィーチャ\",\"機能\"],\"given\":[\"* \",\"前提\"],\"name\":\"Japanese\",\"native\":\"日本語\",\"rule\":[\"Rule\"],\"scenario\":[\"シナリオ\"],\"scenarioOutline\":[\"シナリオアウトライン\",\"シナリオテンプレート\",\"テンプレ\",\"シナリオテンプレ\"],\"then\":[\"* \",\"ならば\"],\"when\":[\"* \",\"もし\"]},\"jv\":{\"and\":[\"* \",\"Lan \"],\"background\":[\"Dasar\"],\"but\":[\"* \",\"Tapi \",\"Nanging \",\"Ananging \"],\"examples\":[\"Conto\",\"Contone\"],\"feature\":[\"Fitur\"],\"given\":[\"* \",\"Nalika \",\"Nalikaning \"],\"name\":\"Javanese\",\"native\":\"Basa Jawa\",\"rule\":[\"Rule\"],\"scenario\":[\"Skenario\"],\"scenarioOutline\":[\"Konsep skenario\"],\"then\":[\"* \",\"Njuk \",\"Banjur \"],\"when\":[\"* \",\"Manawa \",\"Menawa \"]},\"ka\":{\"and\":[\"* \",\"და\"],\"background\":[\"კონტექსტი\"],\"but\":[\"* \",\"მაგ­რამ\"],\"examples\":[\"მაგალითები\"],\"feature\":[\"თვისება\"],\"given\":[\"* \",\"მოცემული\"],\"name\":\"Georgian\",\"native\":\"ქართველი\",\"rule\":[\"Rule\"],\"scenario\":[\"მაგალითად\",\"სცენარის\"],\"scenarioOutline\":[\"სცენარის ნიმუში\"],\"then\":[\"* \",\"მაშინ\"],\"when\":[\"* \",\"როდესაც\"]},\"kn\":{\"and\":[\"* \",\"ಮತ್ತು \"],\"background\":[\"ಹಿನ್ನೆಲೆ\"],\"but\":[\"* \",\"ಆದರೆ \"],\"examples\":[\"ಉದಾಹರಣೆಗಳು\"],\"feature\":[\"ಹೆಚ್ಚಳ\"],\"given\":[\"* \",\"ನೀಡಿದ \"],\"name\":\"Kannada\",\"native\":\"ಕನ್ನಡ\",\"rule\":[\"Rule\"],\"scenario\":[\"ಉದಾಹರಣೆ\",\"ಕಥಾಸಾರಾಂಶ\"],\"scenarioOutline\":[\"ವಿವರಣೆ\"],\"then\":[\"* \",\"ನಂತರ \"],\"when\":[\"* \",\"ಸ್ಥಿತಿಯನ್ನು \"]},\"ko\":{\"and\":[\"* \",\"그리고\"],\"background\":[\"배경\"],\"but\":[\"* \",\"하지만\",\"단\"],\"examples\":[\"예\"],\"feature\":[\"기능\"],\"given\":[\"* \",\"조건\",\"먼저\"],\"name\":\"Korean\",\"native\":\"한국어\",\"rule\":[\"Rule\"],\"scenario\":[\"시나리오\"],\"scenarioOutline\":[\"시나리오 개요\"],\"then\":[\"* \",\"그러면\"],\"when\":[\"* \",\"만일\",\"만약\"]},\"lt\":{\"and\":[\"* \",\"Ir \"],\"background\":[\"Kontekstas\"],\"but\":[\"* \",\"Bet \"],\"examples\":[\"Pavyzdžiai\",\"Scenarijai\",\"Variantai\"],\"feature\":[\"Savybė\"],\"given\":[\"* \",\"Duota \"],\"name\":\"Lithuanian\",\"native\":\"lietuvių kalba\",\"rule\":[\"Rule\"],\"scenario\":[\"Pavyzdys\",\"Scenarijus\"],\"scenarioOutline\":[\"Scenarijaus šablonas\"],\"then\":[\"* \",\"Tada \"],\"when\":[\"* \",\"Kai \"]},\"lu\":{\"and\":[\"* \",\"an \",\"a \"],\"background\":[\"Hannergrond\"],\"but\":[\"* \",\"awer \",\"mä \"],\"examples\":[\"Beispiller\"],\"feature\":[\"Funktionalitéit\"],\"given\":[\"* \",\"ugeholl \"],\"name\":\"Luxemburgish\",\"native\":\"Lëtzebuergesch\",\"rule\":[\"Rule\"],\"scenario\":[\"Beispill\",\"Szenario\"],\"scenarioOutline\":[\"Plang vum Szenario\"],\"then\":[\"* \",\"dann \"],\"when\":[\"* \",\"wann \"]},\"lv\":{\"and\":[\"* \",\"Un \"],\"background\":[\"Konteksts\",\"Situācija\"],\"but\":[\"* \",\"Bet \"],\"examples\":[\"Piemēri\",\"Paraugs\"],\"feature\":[\"Funkcionalitāte\",\"Fīča\"],\"given\":[\"* \",\"Kad \"],\"name\":\"Latvian\",\"native\":\"latviešu\",\"rule\":[\"Rule\"],\"scenario\":[\"Piemērs\",\"Scenārijs\"],\"scenarioOutline\":[\"Scenārijs pēc parauga\"],\"then\":[\"* \",\"Tad \"],\"when\":[\"* \",\"Ja \"]},\"mk-Cyrl\":{\"and\":[\"* \",\"И \"],\"background\":[\"Контекст\",\"Содржина\"],\"but\":[\"* \",\"Но \"],\"examples\":[\"Примери\",\"Сценарија\"],\"feature\":[\"Функционалност\",\"Бизнис потреба\",\"Можност\"],\"given\":[\"* \",\"Дадено \",\"Дадена \"],\"name\":\"Macedonian\",\"native\":\"Македонски\",\"rule\":[\"Rule\"],\"scenario\":[\"Пример\",\"Сценарио\",\"На пример\"],\"scenarioOutline\":[\"Преглед на сценарија\",\"Скица\",\"Концепт\"],\"then\":[\"* \",\"Тогаш \"],\"when\":[\"* \",\"Кога \"]},\"mk-Latn\":{\"and\":[\"* \",\"I \"],\"background\":[\"Kontekst\",\"Sodrzhina\"],\"but\":[\"* \",\"No \"],\"examples\":[\"Primeri\",\"Scenaria\"],\"feature\":[\"Funkcionalnost\",\"Biznis potreba\",\"Mozhnost\"],\"given\":[\"* \",\"Dadeno \",\"Dadena \"],\"name\":\"Macedonian (Latin)\",\"native\":\"Makedonski (Latinica)\",\"rule\":[\"Rule\"],\"scenario\":[\"Scenario\",\"Na primer\"],\"scenarioOutline\":[\"Pregled na scenarija\",\"Skica\",\"Koncept\"],\"then\":[\"* \",\"Togash \"],\"when\":[\"* \",\"Koga \"]},\"mn\":{\"and\":[\"* \",\"Мөн \",\"Тэгээд \"],\"background\":[\"Агуулга\"],\"but\":[\"* \",\"Гэхдээ \",\"Харин \"],\"examples\":[\"Тухайлбал\"],\"feature\":[\"Функц\",\"Функционал\"],\"given\":[\"* \",\"Өгөгдсөн нь \",\"Анх \"],\"name\":\"Mongolian\",\"native\":\"монгол\",\"rule\":[\"Rule\"],\"scenario\":[\"Сценар\"],\"scenarioOutline\":[\"Сценарын төлөвлөгөө\"],\"then\":[\"* \",\"Тэгэхэд \",\"Үүний дараа \"],\"when\":[\"* \",\"Хэрэв \"]},\"nl\":{\"and\":[\"* \",\"En \"],\"background\":[\"Achtergrond\"],\"but\":[\"* \",\"Maar \"],\"examples\":[\"Voorbeelden\"],\"feature\":[\"Functionaliteit\"],\"given\":[\"* \",\"Gegeven \",\"Stel \"],\"name\":\"Dutch\",\"native\":\"Nederlands\",\"rule\":[\"Rule\"],\"scenario\":[\"Voorbeeld\",\"Scenario\"],\"scenarioOutline\":[\"Abstract Scenario\"],\"then\":[\"* \",\"Dan \"],\"when\":[\"* \",\"Als \",\"Wanneer \"]},\"no\":{\"and\":[\"* \",\"Og \"],\"background\":[\"Bakgrunn\"],\"but\":[\"* \",\"Men \"],\"examples\":[\"Eksempler\"],\"feature\":[\"Egenskap\"],\"given\":[\"* \",\"Gitt \"],\"name\":\"Norwegian\",\"native\":\"norsk\",\"rule\":[\"Regel\"],\"scenario\":[\"Eksempel\",\"Scenario\"],\"scenarioOutline\":[\"Scenariomal\",\"Abstrakt Scenario\"],\"then\":[\"* \",\"Så \"],\"when\":[\"* \",\"Når \"]},\"pa\":{\"and\":[\"* \",\"ਅਤੇ \"],\"background\":[\"ਪਿਛੋਕੜ\"],\"but\":[\"* \",\"ਪਰ \"],\"examples\":[\"ਉਦਾਹਰਨਾਂ\"],\"feature\":[\"ਖਾਸੀਅਤ\",\"ਮੁਹਾਂਦਰਾ\",\"ਨਕਸ਼ ਨੁਹਾਰ\"],\"given\":[\"* \",\"ਜੇਕਰ \",\"ਜਿਵੇਂ ਕਿ \"],\"name\":\"Panjabi\",\"native\":\"ਪੰਜਾਬੀ\",\"rule\":[\"Rule\"],\"scenario\":[\"ਉਦਾਹਰਨ\",\"ਪਟਕਥਾ\"],\"scenarioOutline\":[\"ਪਟਕਥਾ ਢਾਂਚਾ\",\"ਪਟਕਥਾ ਰੂਪ ਰੇਖਾ\"],\"then\":[\"* \",\"ਤਦ \"],\"when\":[\"* \",\"ਜਦੋਂ \"]},\"pl\":{\"and\":[\"* \",\"Oraz \",\"I \"],\"background\":[\"Założenia\"],\"but\":[\"* \",\"Ale \"],\"examples\":[\"Przykłady\"],\"feature\":[\"Właściwość\",\"Funkcja\",\"Aspekt\",\"Potrzeba biznesowa\"],\"given\":[\"* \",\"Zakładając \",\"Mając \",\"Zakładając, że \"],\"name\":\"Polish\",\"native\":\"polski\",\"rule\":[\"Rule\"],\"scenario\":[\"Przykład\",\"Scenariusz\"],\"scenarioOutline\":[\"Szablon scenariusza\"],\"then\":[\"* \",\"Wtedy \"],\"when\":[\"* \",\"Jeżeli \",\"Jeśli \",\"Gdy \",\"Kiedy \"]},\"pt\":{\"and\":[\"* \",\"E \"],\"background\":[\"Contexto\",\"Cenário de Fundo\",\"Cenario de Fundo\",\"Fundo\"],\"but\":[\"* \",\"Mas \"],\"examples\":[\"Exemplos\",\"Cenários\",\"Cenarios\"],\"feature\":[\"Funcionalidade\",\"Característica\",\"Caracteristica\"],\"given\":[\"* \",\"Dado \",\"Dada \",\"Dados \",\"Dadas \"],\"name\":\"Portuguese\",\"native\":\"português\",\"rule\":[\"Regra\"],\"scenario\":[\"Exemplo\",\"Cenário\",\"Cenario\"],\"scenarioOutline\":[\"Esquema do Cenário\",\"Esquema do Cenario\",\"Delineação do Cenário\",\"Delineacao do Cenario\"],\"then\":[\"* \",\"Então \",\"Entao \"],\"when\":[\"* \",\"Quando \"]},\"ro\":{\"and\":[\"* \",\"Si \",\"Și \",\"Şi \"],\"background\":[\"Context\"],\"but\":[\"* \",\"Dar \"],\"examples\":[\"Exemple\"],\"feature\":[\"Functionalitate\",\"Funcționalitate\",\"Funcţionalitate\"],\"given\":[\"* \",\"Date fiind \",\"Dat fiind \",\"Dată fiind\",\"Dati fiind \",\"Dați fiind \",\"Daţi fiind \"],\"name\":\"Romanian\",\"native\":\"română\",\"rule\":[\"Rule\"],\"scenario\":[\"Exemplu\",\"Scenariu\"],\"scenarioOutline\":[\"Structura scenariu\",\"Structură scenariu\"],\"then\":[\"* \",\"Atunci \"],\"when\":[\"* \",\"Cand \",\"Când \"]},\"ru\":{\"and\":[\"* \",\"И \",\"К тому же \",\"Также \"],\"background\":[\"Предыстория\",\"Контекст\"],\"but\":[\"* \",\"Но \",\"А \",\"Иначе \"],\"examples\":[\"Примеры\"],\"feature\":[\"Функция\",\"Функциональность\",\"Функционал\",\"Свойство\"],\"given\":[\"* \",\"Допустим \",\"Дано \",\"Пусть \"],\"name\":\"Russian\",\"native\":\"русский\",\"rule\":[\"Rule\"],\"scenario\":[\"Пример\",\"Сценарий\"],\"scenarioOutline\":[\"Структура сценария\"],\"then\":[\"* \",\"То \",\"Затем \",\"Тогда \"],\"when\":[\"* \",\"Когда \",\"Если \"]},\"sk\":{\"and\":[\"* \",\"A \",\"A tiež \",\"A taktiež \",\"A zároveň \"],\"background\":[\"Pozadie\"],\"but\":[\"* \",\"Ale \"],\"examples\":[\"Príklady\"],\"feature\":[\"Požiadavka\",\"Funkcia\",\"Vlastnosť\"],\"given\":[\"* \",\"Pokiaľ \",\"Za predpokladu \"],\"name\":\"Slovak\",\"native\":\"Slovensky\",\"rule\":[\"Rule\"],\"scenario\":[\"Príklad\",\"Scenár\"],\"scenarioOutline\":[\"Náčrt Scenáru\",\"Náčrt Scenára\",\"Osnova Scenára\"],\"then\":[\"* \",\"Tak \",\"Potom \"],\"when\":[\"* \",\"Keď \",\"Ak \"]},\"sl\":{\"and\":[\"In \",\"Ter \"],\"background\":[\"Kontekst\",\"Osnova\",\"Ozadje\"],\"but\":[\"Toda \",\"Ampak \",\"Vendar \"],\"examples\":[\"Primeri\",\"Scenariji\"],\"feature\":[\"Funkcionalnost\",\"Funkcija\",\"Možnosti\",\"Moznosti\",\"Lastnost\",\"Značilnost\"],\"given\":[\"Dano \",\"Podano \",\"Zaradi \",\"Privzeto \"],\"name\":\"Slovenian\",\"native\":\"Slovenski\",\"rule\":[\"Rule\"],\"scenario\":[\"Primer\",\"Scenarij\"],\"scenarioOutline\":[\"Struktura scenarija\",\"Skica\",\"Koncept\",\"Oris scenarija\",\"Osnutek\"],\"then\":[\"Nato \",\"Potem \",\"Takrat \"],\"when\":[\"Ko \",\"Ce \",\"Če \",\"Kadar \"]},\"sr-Cyrl\":{\"and\":[\"* \",\"И \"],\"background\":[\"Контекст\",\"Основа\",\"Позадина\"],\"but\":[\"* \",\"Али \"],\"examples\":[\"Примери\",\"Сценарији\"],\"feature\":[\"Функционалност\",\"Могућност\",\"Особина\"],\"given\":[\"* \",\"За дато \",\"За дате \",\"За дати \"],\"name\":\"Serbian\",\"native\":\"Српски\",\"rule\":[\"Rule\"],\"scenario\":[\"Пример\",\"Сценарио\",\"Пример\"],\"scenarioOutline\":[\"Структура сценарија\",\"Скица\",\"Концепт\"],\"then\":[\"* \",\"Онда \"],\"when\":[\"* \",\"Када \",\"Кад \"]},\"sr-Latn\":{\"and\":[\"* \",\"I \"],\"background\":[\"Kontekst\",\"Osnova\",\"Pozadina\"],\"but\":[\"* \",\"Ali \"],\"examples\":[\"Primeri\",\"Scenariji\"],\"feature\":[\"Funkcionalnost\",\"Mogućnost\",\"Mogucnost\",\"Osobina\"],\"given\":[\"* \",\"Za dato \",\"Za date \",\"Za dati \"],\"name\":\"Serbian (Latin)\",\"native\":\"Srpski (Latinica)\",\"rule\":[\"Rule\"],\"scenario\":[\"Scenario\",\"Primer\"],\"scenarioOutline\":[\"Struktura scenarija\",\"Skica\",\"Koncept\"],\"then\":[\"* \",\"Onda \"],\"when\":[\"* \",\"Kada \",\"Kad \"]},\"sv\":{\"and\":[\"* \",\"Och \"],\"background\":[\"Bakgrund\"],\"but\":[\"* \",\"Men \"],\"examples\":[\"Exempel\"],\"feature\":[\"Egenskap\"],\"given\":[\"* \",\"Givet \"],\"name\":\"Swedish\",\"native\":\"Svenska\",\"rule\":[\"Rule\"],\"scenario\":[\"Scenario\"],\"scenarioOutline\":[\"Abstrakt Scenario\",\"Scenariomall\"],\"then\":[\"* \",\"Så \"],\"when\":[\"* \",\"När \"]},\"ta\":{\"and\":[\"* \",\"மேலும்  \",\"மற்றும் \"],\"background\":[\"பின்னணி\"],\"but\":[\"* \",\"ஆனால்  \"],\"examples\":[\"எடுத்துக்காட்டுகள்\",\"காட்சிகள்\",\"நிலைமைகளில்\"],\"feature\":[\"அம்சம்\",\"வணிக தேவை\",\"திறன்\"],\"given\":[\"* \",\"கொடுக்கப்பட்ட \"],\"name\":\"Tamil\",\"native\":\"தமிழ்\",\"rule\":[\"Rule\"],\"scenario\":[\"உதாரணமாக\",\"காட்சி\"],\"scenarioOutline\":[\"காட்சி சுருக்கம்\",\"காட்சி வார்ப்புரு\"],\"then\":[\"* \",\"அப்பொழுது \"],\"when\":[\"* \",\"எப்போது \"]},\"th\":{\"and\":[\"* \",\"และ \"],\"background\":[\"แนวคิด\"],\"but\":[\"* \",\"แต่ \"],\"examples\":[\"ชุดของตัวอย่าง\",\"ชุดของเหตุการณ์\"],\"feature\":[\"โครงหลัก\",\"ความต้องการทางธุรกิจ\",\"ความสามารถ\"],\"given\":[\"* \",\"กำหนดให้ \"],\"name\":\"Thai\",\"native\":\"ไทย\",\"rule\":[\"Rule\"],\"scenario\":[\"เหตุการณ์\"],\"scenarioOutline\":[\"สรุปเหตุการณ์\",\"โครงสร้างของเหตุการณ์\"],\"then\":[\"* \",\"ดังนั้น \"],\"when\":[\"* \",\"เมื่อ \"]},\"tl\":{\"and\":[\"* \",\"మరియు \"],\"background\":[\"నేపథ్యం\"],\"but\":[\"* \",\"కాని \"],\"examples\":[\"ఉదాహరణలు\"],\"feature\":[\"గుణము\"],\"given\":[\"* \",\"చెప్పబడినది \"],\"name\":\"Telugu\",\"native\":\"తెలుగు\",\"rule\":[\"Rule\"],\"scenario\":[\"ఉదాహరణ\",\"సన్నివేశం\"],\"scenarioOutline\":[\"కథనం\"],\"then\":[\"* \",\"అప్పుడు \"],\"when\":[\"* \",\"ఈ పరిస్థితిలో \"]},\"tlh\":{\"and\":[\"* \",\"'ej \",\"latlh \"],\"background\":[\"mo'\"],\"but\":[\"* \",\"'ach \",\"'a \"],\"examples\":[\"ghantoH\",\"lutmey\"],\"feature\":[\"Qap\",\"Qu'meH 'ut\",\"perbogh\",\"poQbogh malja'\",\"laH\"],\"given\":[\"* \",\"ghu' noblu' \",\"DaH ghu' bejlu' \"],\"name\":\"Klingon\",\"native\":\"tlhIngan\",\"rule\":[\"Rule\"],\"scenario\":[\"lut\"],\"scenarioOutline\":[\"lut chovnatlh\"],\"then\":[\"* \",\"vaj \"],\"when\":[\"* \",\"qaSDI' \"]},\"tr\":{\"and\":[\"* \",\"Ve \"],\"background\":[\"Geçmiş\"],\"but\":[\"* \",\"Fakat \",\"Ama \"],\"examples\":[\"Örnekler\"],\"feature\":[\"Özellik\"],\"given\":[\"* \",\"Diyelim ki \"],\"name\":\"Turkish\",\"native\":\"Türkçe\",\"rule\":[\"Rule\"],\"scenario\":[\"Örnek\",\"Senaryo\"],\"scenarioOutline\":[\"Senaryo taslağı\"],\"then\":[\"* \",\"O zaman \"],\"when\":[\"* \",\"Eğer ki \"]},\"tt\":{\"and\":[\"* \",\"Һәм \",\"Вә \"],\"background\":[\"Кереш\"],\"but\":[\"* \",\"Ләкин \",\"Әмма \"],\"examples\":[\"Үрнәкләр\",\"Мисаллар\"],\"feature\":[\"Мөмкинлек\",\"Үзенчәлеклелек\"],\"given\":[\"* \",\"Әйтик \"],\"name\":\"Tatar\",\"native\":\"Татарча\",\"rule\":[\"Rule\"],\"scenario\":[\"Сценарий\"],\"scenarioOutline\":[\"Сценарийның төзелеше\"],\"then\":[\"* \",\"Нәтиҗәдә \"],\"when\":[\"* \",\"Әгәр \"]},\"uk\":{\"and\":[\"* \",\"І \",\"А також \",\"Та \"],\"background\":[\"Передумова\"],\"but\":[\"* \",\"Але \"],\"examples\":[\"Приклади\"],\"feature\":[\"Функціонал\"],\"given\":[\"* \",\"Припустимо \",\"Припустимо, що \",\"Нехай \",\"Дано \"],\"name\":\"Ukrainian\",\"native\":\"Українська\",\"rule\":[\"Rule\"],\"scenario\":[\"Приклад\",\"Сценарій\"],\"scenarioOutline\":[\"Структура сценарію\"],\"then\":[\"* \",\"То \",\"Тоді \"],\"when\":[\"* \",\"Якщо \",\"Коли \"]},\"ur\":{\"and\":[\"* \",\"اور \"],\"background\":[\"پس منظر\"],\"but\":[\"* \",\"لیکن \"],\"examples\":[\"مثالیں\"],\"feature\":[\"صلاحیت\",\"کاروبار کی ضرورت\",\"خصوصیت\"],\"given\":[\"* \",\"اگر \",\"بالفرض \",\"فرض کیا \"],\"name\":\"Urdu\",\"native\":\"اردو\",\"rule\":[\"Rule\"],\"scenario\":[\"منظرنامہ\"],\"scenarioOutline\":[\"منظر نامے کا خاکہ\"],\"then\":[\"* \",\"پھر \",\"تب \"],\"when\":[\"* \",\"جب \"]},\"uz\":{\"and\":[\"* \",\"Ва \"],\"background\":[\"Тарих\"],\"but\":[\"* \",\"Лекин \",\"Бирок \",\"Аммо \"],\"examples\":[\"Мисоллар\"],\"feature\":[\"Функционал\"],\"given\":[\"* \",\"Агар \"],\"name\":\"Uzbek\",\"native\":\"Узбекча\",\"rule\":[\"Rule\"],\"scenario\":[\"Сценарий\"],\"scenarioOutline\":[\"Сценарий структураси\"],\"then\":[\"* \",\"Унда \"],\"when\":[\"* \",\"Агар \"]},\"vi\":{\"and\":[\"* \",\"Và \"],\"background\":[\"Bối cảnh\"],\"but\":[\"* \",\"Nhưng \"],\"examples\":[\"Dữ liệu\"],\"feature\":[\"Tính năng\"],\"given\":[\"* \",\"Biết \",\"Cho \"],\"name\":\"Vietnamese\",\"native\":\"Tiếng Việt\",\"rule\":[\"Rule\"],\"scenario\":[\"Tình huống\",\"Kịch bản\"],\"scenarioOutline\":[\"Khung tình huống\",\"Khung kịch bản\"],\"then\":[\"* \",\"Thì \"],\"when\":[\"* \",\"Khi \"]},\"zh-CN\":{\"and\":[\"* \",\"而且\",\"并且\",\"同时\"],\"background\":[\"背景\"],\"but\":[\"* \",\"但是\"],\"examples\":[\"例子\"],\"feature\":[\"功能\"],\"given\":[\"* \",\"假如\",\"假设\",\"假定\"],\"name\":\"Chinese simplified\",\"native\":\"简体中文\",\"rule\":[\"Rule\"],\"scenario\":[\"场景\",\"剧本\"],\"scenarioOutline\":[\"场景大纲\",\"剧本大纲\"],\"then\":[\"* \",\"那么\"],\"when\":[\"* \",\"当\"]},\"zh-TW\":{\"and\":[\"* \",\"而且\",\"並且\",\"同時\"],\"background\":[\"背景\"],\"but\":[\"* \",\"但是\"],\"examples\":[\"例子\"],\"feature\":[\"功能\"],\"given\":[\"* \",\"假如\",\"假設\",\"假定\"],\"name\":\"Chinese traditional\",\"native\":\"繁體中文\",\"rule\":[\"Rule\"],\"scenario\":[\"場景\",\"劇本\"],\"scenarioOutline\":[\"場景大綱\",\"劇本大綱\"],\"then\":[\"* \",\"那麼\"],\"when\":[\"* \",\"當\"]}}");

/***/ }),

/***/ 2357:
/***/ ((module) => {

"use strict";
module.exports = require("assert");;

/***/ }),

/***/ 3129:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");;

/***/ }),

/***/ 6417:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");;

/***/ }),

/***/ 8614:
/***/ ((module) => {

"use strict";
module.exports = require("events");;

/***/ }),

/***/ 5747:
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),

/***/ 8605:
/***/ ((module) => {

"use strict";
module.exports = require("http");;

/***/ }),

/***/ 7211:
/***/ ((module) => {

"use strict";
module.exports = require("https");;

/***/ }),

/***/ 1631:
/***/ ((module) => {

"use strict";
module.exports = require("net");;

/***/ }),

/***/ 2087:
/***/ ((module) => {

"use strict";
module.exports = require("os");;

/***/ }),

/***/ 5622:
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ }),

/***/ 2413:
/***/ ((module) => {

"use strict";
module.exports = require("stream");;

/***/ }),

/***/ 4016:
/***/ ((module) => {

"use strict";
module.exports = require("tls");;

/***/ }),

/***/ 8835:
/***/ ((module) => {

"use strict";
module.exports = require("url");;

/***/ }),

/***/ 1669:
/***/ ((module) => {

"use strict";
module.exports = require("util");;

/***/ }),

/***/ 8761:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	__webpack_require__.ab = __dirname + "/";/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(3109);
/******/ })()
;
//# sourceMappingURL=index.js.map